# 基于 Git 的 Nuxt 项目内容管理系统

::u-page-hero
---
orientation: horizontal
---
  :::code-group
  ```mdc [content/index.md]
  ---
  color: neutral
  label: 打开可视化编辑器
  size: xl
  target: _blank
  to: https://nuxt.studio
  variant: subtle
  ---

  ::my-vue-hero-component{orientation="horizontal"}
  #title
  欢迎来到山脉网站。
  #description
  这是一个关于山脉的网站描述。
  ::

  这是一个包含 **加粗** 和 _斜体_ 文本的段落。
  ```

  ```vue [pages/index.vue]
  <script setup lang="ts">
  const { data } = await useAsyncData('home', () => {
    return queryCollection('content').path('/').first()
  })

  useSeoMeta({
    title: data.value?.title,
    description: data.value?.description
  })
  </script>

  <template>
    <ContentRenderer :value="data" />
  </template>
  ```
  :::

#headline
  :::u-button
  ---
  class: mb-3 rounded-full
  size: sm
  to: https://github.com/nuxt-content/studio/releases/tag/v1.0.0-beta.0
  trailing-icon: i-lucide-arrow-right
  variant: outline
  ---
  Nuxt Studio alpha 已发布
  :::

#title{unwrap="p"}
基于 Git 的 :br Nuxt 项目内容管理系统。

#description
Nuxt Content 是 Nuxt 的一个模块，提供了一种简单的方式管理您的应用内容。它允许开发者以 Markdown、YAML、CSV 或 JSON 文件格式编写内容，然后在应用中查询并展示它们。

#links
  :::u-button
  ---
  label: 开始使用
  size: xl
  to: https://nuxt-content.zhcndoc.com/docs/getting-started/installation
  trailingIcon: i-lucide-arrow-right
  ---
  :::

:u-input-copy{value="npx nuxt module add content"}
::

::u-container{.pb-12.xl:pb-24}
  :::u-page-grid
    ::::u-page-feature
    ---
    icon: i-lucide-files
    ---
    #title{unwrap="p"}
    基于文件的 CMS

    #description{unwrap="p"}
    以 Markdown、YAML、CSV 或 JSON 格式编写内容，并在组件中查询。
    ::::

    ::::u-page-feature
    ---
    icon: i-lucide-filter
    ---
    #title{unwrap="p"}
    查询构建器

    #description{unwrap="p"}
    使用类 MongoDB 的 API 查询内容，按需获取正确的数据。
    ::::

    ::::u-page-feature
    ---
    icon: i-lucide-database
    ---
    #title{unwrap="p"}
    SQLite 驱动

    #description{unwrap="p"}
    向内容中添加自定义字段，适用于各种类型的项目。
    ::::

    ::::u-page-feature
    ---
    icon: i-simple-icons-markdown
    ---
    #title{unwrap="p"}
    Markdown 与 Vue

    #description{unwrap="p"}
    在 Markdown 文件中使用 Vue 组件，支持 props、插槽和嵌套组件。
    ::::

    ::::u-page-feature
    ---
    icon: i-lucide-list-minus
    ---
    #title{unwrap="p"}
    代码高亮

    #description{unwrap="p"}
    结合 Shiki 集成支持 VS Code 主题，在网站上显示漂亮的代码块。
    ::::

    ::::u-page-feature
    ---
    icon: i-lucide-mouse-pointer-click
    ---
    #title{unwrap="p"}
    可视化编辑器

    #description{unwrap="p"}
    通过我们的可视化编辑器 Nuxt Studio，让团队成员轻松编辑 Nuxt Content 项目。
    ::::

    ::::u-page-feature
    ---
    icon: i-lucide-panel-left
    ---
    #title{unwrap="p"}
    导航生成

    #description{unwrap="p"}
    从内容文件生成结构化对象，几分钟内展示导航菜单。
    ::::

    ::::u-page-feature
    ---
    icon: i-lucide-heading-1
    ---
    #title{unwrap="p"}
    文章组件

    #description{unwrap="p"}
    使用 Vue 组件自定义 HTML 排版标签，让内容风格统一。
    ::::

    ::::u-page-feature
    ---
    icon: i-lucide-globe
    ---
    #title{unwrap="p"}
    部署无处不在

    #description{unwrap="p"}
    Nuxt Content 兼容所有托管服务，支持静态、服务端、无服务器和边缘部署。
    ::::
  :::

  :::u-page-section
  #title
  内容管理所需的一切

  #description
  结合基于文件的简单性与 Vue 组件的强大功能。构建内容丰富的网站，从文档页到复杂应用。

    ::::div{.hidden.md:block}
    :u-color-mode-image{.size-full.absolute.top-0.inset-0 dark="/home/features-dark.svg" light="/home/features-light.svg"}
    ::::
  :::

  :::u-page-section
  ---
  reverse: true
  orientation: horizontal
  ---
    ::::tabs
      :::::tabs-item{icon="i-lucide-eye" label="预览"}
        ::::::browser-frame
          :::::::example-landing-hero
          ---
          image: /mountains/everest.jpg
          ---
          #title
          珠穆朗玛峰

          #description
          珠穆朗玛峰是世界上最高的山，海拔 8,848 米。
          :::::::
        ::::::
      :::::

      :::::tabs-item{icon="i-simple-icons-markdown" label="content/index.md"}
      ```mdc [content/index.md]
      ---
      title: 山脉网站
      description: 一个关于世界上最具标志性的山脉的网站。
      ---

      ::landing-hero
      ---
      image: /mountains/everest.jpg
      ---
      #title
      珠穆朗玛峰

      #description
      珠穆朗玛峰是世界上最高的山，海拔 8,848 米。
      ::

      ```
      :::::

      :::::tabs-item
      ---
      icon: i-simple-icons-vuedotjs
      label: components/LandingHero.vue
      ---
      ```vue [components/LandingHero.vue]
        <script setup lang="ts">
        defineProps<{
          image: string 
        }>()
        </script>
        
        <template>
          <section class="flex flex-col sm:flex-row sm:items-center gap-4 py-8 sm:gap-12 sm:py-12">
            <div>
              <h1 class="text-4xl font-semibold">
                <slot name="title" />
              </h1>
              <div class="text-base text-gray-600 dark:text-gray-300">
                <slot name="description" />
              </div>
            </div>
            <img :src="image" class="w-1/2 rounded-lg">
          </section>
        </template>
      ```
      :::::
    ::::

  #title
  Markdown 遇见 [Vue]{.text-(--ui-primary)} 组件

  #description
  我们创造了 MDC 语法，让你可以在 Markdown 文件中使用带有 props 和插槽的 Vue 组件。

  #features
    ::::u-page-feature
    ---
    icon: i-lucide-list
    ---
    #title{unwrap="p"}
    用 frontmatter 语法指定 props
    ::::

    ::::u-page-feature
    ---
    icon: i-lucide-hash
    ---
    #title{unwrap="p"}
    使用 `#` 来定义组件插槽
    ::::

    ::::u-page-feature
    ---
    icon: i-lucide-code-xml
    ---
    #title{unwrap="p"}
    添加任意其他 HTML 属性
    ::::

  #links
    ::::u-button
    ---
    color: neutral
    label: 了解更多关于 MDC
    to: https://nuxt-content.zhcndoc.com/docs/files/markdown#mdc-syntax
    trailingIcon: i-lucide-arrow-right
    variant: subtle
    ---
    ::::
  :::

  :::u-page-section
  ---
  orientation: horizontal
  ---
    ::::tabs
      :::::tabs-item{icon="i-simple-icons-vuedotjs" label="pages/blog.vue"}
      ```vue [pages/blog.vue]
      <script setup lang="ts">
      const { data: posts } = await useAsyncData('blog', () => {
        return queryCollection('blog').all()
      })
      </script>

      <template>
        <div>
          <h1>博客</h1>
          <ul>
            <li v-for="post in posts" :key="post.id">
              <NuxtLink :to="post.path">{{ post.title }}</NuxtLink>
            </li>
          </ul>
        </div>
      </template>
      ```
      :::::

      :::::tabs-item{icon="i-simple-icons-typescript" label="content.config.ts"}
      ```ts [content.config.ts]
      import { defineContentConfig, defineCollection } from '@nuxt/content'
      import { z } from 'zod'

      export default defineContentConfig({
        collections: {
          blog: defineCollection({
            source: 'blog/*.md',
            type: 'page',
            // 定义文档集合的自定义 schema
            schema: z.object({
              tags: z.array(z.string()),
              image: z.string(),
              date: z.Date()
            })
          })
        }
      })
      ```
      :::::
    ::::

  #title
  [类型安全]{.text-(--ui-secondary)} 查询

  #description
  使用集合定义内容结构，并通过 schema 验证实现完全的类型安全查询。

  #features
    ::::u-page-feature
    ---
    icon: i-lucide-layout-grid
    ---
    #title{unwrap="p"}
    为相似内容文件创建集合
    ::::

    ::::u-page-feature
    ---
    icon: i-lucide-circle-check
    ---
    #title{unwrap="p"}
    为集合 frontmatter 定义 schema
    ::::

    ::::u-page-feature
    ---
    icon: i-lucide-text-cursor
    ---
    #title{unwrap="p"}
    在 Vue 文件中获得自动补全
    ::::

  #links
    ::::u-button
    ---
    color: neutral
    label: 了解更多关于内容集合
    to: https://nuxt-content.zhcndoc.com/docs/collections/define
    trailingIcon: i-lucide-arrow-right
    variant: subtle
    ---
    ::::
  :::

  :::u-page-section
  ---
  reverse: true
  orientation: horizontal
  ---
  :video{autoplay controls loop src="https://res.cloudinary.com/nuxt/video/upload/v1733494722/contentv3final_rc8bvu.mp4"}

  #title{unwrap="p"}
  让 [任何人编辑]{.text-(--ui-primary)} 您的网站

  #description
  通过 **Studio** 编辑您的 Nuxt Content 网站——我们的 CMS 平台，提供类似 Notion 的 Markdown 编辑器和为 `YAML` 与 `JSON` 文件生成的表单。支持实时预览和在线协作。

  #features
    ::::u-page-feature
    ---
    icon: i-lucide-mouse-pointer-click
    ---
    #title{unwrap="p"}
    拖拽式 Markdown 可视化编辑器
    ::::

    ::::u-page-feature
    ---
    icon: i-lucide-file-text
    ---
    #title{unwrap="p"}
    为 YML 和 JSON 文件生成表单
    ::::

    ::::u-page-feature
    ---
    icon: i-simple-icons-google
    ---
    #title{unwrap="p"}
    邀请编辑者通过 Google 登录并发布更改
    ::::

  #links
    ::::u-button
    ---
    color: neutral
    label: 探索 Studio
    to: https://nuxt-content.zhcndoc.com/studio
    trailingIcon: i-lucide-arrow-right
    ---
    ::::
  :::

  :::u-page-section
    ::::div{.hidden.md:block}
    :u-color-mode-image{.size-full.absolute.bottom-0.inset-0.z-[-1] dark="/home/cta-dark.svg" light="/home/cta-light.svg"}
    ::::

  #title
  为您的 Nuxt 项目添加基于 Git 的 CMS。

  #links
  :u-button{label="阅读文档" to="https://nuxt-content.zhcndoc.com/docs/getting-started/installation" trailingIcon="i-lucide-arrow-right"}

    ::::u-button
    ---
    color: neutral
    label: 打开 Studio
    target: _blank
    to: https://nuxt.studio
    variant: outline
    ---
    ::::
  :::
::


# 认识 Studio，为所有人打造的内容编辑

::u-page-hero
  :::div{.hidden.md:block}
  :u-color-mode-image{.size-full.absolute.bottom-0.inset-x-4.z-[-1] dark="/home/hero-dark.svg" light="/home/hero-light.svg"}
  :::

#title{unwrap="p"}
认识 Studio，内容编辑 :br 面向每个人。

#description
**Nuxt Studio** 为您的 Nuxt Content 项目带来可视化编辑。任何人都可以借助我们多功能的编辑器贡献网站内容，该编辑器兼容 markdown、YAML 或 JSON。无需技术专长。*为开发者打造，适用于所有人。*

#links{unwrap="p"}
  :::u-button
  ---
  label: 免费开始使用
  size: xl
  target: _blank
  to: https://nuxt.studio/signin
  trailingIcon: i-lucide-arrow-right
  ---
  :::

  :::u-button
  ---
  color: neutral
  label: 阅读文档
  size: xl
  to: https://nuxt-content.zhcndoc.com/docs/studio/setup
  variant: subtle
  ---
  :::
::

::u-page-section
#features
  :::u-page-feature
  ---
  icon: i-lucide-circle-user
  ---
  #title{unwrap="p"}
  GitHub 与 Google 认证

  #description{unwrap="p"}
  为各角色提供个性化工作空间：开发者、撰写者及客户。
  :::

  :::u-page-feature
  ---
  icon: i-lucide-file-pen
  ---
  #title{unwrap="p"}
  轻松更新内容

  #description{unwrap="p"}
  从 Markdown 到 YAML 编辑，我们的可视化编辑器专为非技术用户设计。
  :::

  :::u-page-feature
  ---
  icon: i-lucide-users
  ---
  #title{unwrap="p"}
  实时协作

  #description{unwrap="p"}
  利用我们的协作功能，团队成员能实时共同撰写。
  :::

  :::u-page-feature
  ---
  icon: i-lucide-sparkles
  ---
  #title{unwrap="p"}
  从代码到编辑

  #description{unwrap="p"}
  开发者构建基础，撰写者则可安全地编辑内容。
  :::

  :::u-page-feature
  ---
  icon: i-lucide-panels-top-left
  ---
  #title{unwrap="p"}
  发布前审核

  #description{unwrap="p"}
  在网站上线前审核您的更改内容。
  :::

  :::u-page-feature
  ---
  icon: i-lucide-mouse-pointer-click
  ---
  #title{unwrap="p"}
  即用模板

  #description{unwrap="p"}
  利用为 SaaS 网站、博客、文档等预构建的模板快速开始。
  :::
::

::u-page-section
---
orientation: horizontal
---
  :::tabs
    ::::tabs-item
    ---
    class: overflow-x-auto !text-sm
    icon: i-simple-icons-markdown
    label: content/index.md
    ---
    ```mdc [content/index.md]
    ---
    title: The Mountains Website
    description: A website about the most iconic mountains in the world.
    ---

    ::landing-hero
    ---
    image: /mountains/everest.jpg
    ---
    #title
    The Everest.

    #description
    The Everest is the highest mountain in the world, standing at 8,848 meters above sea level.
    ::

    ```
    ::::

    ::::tabs-item
    ---
    class: overflow-x-auto text-md
    icon: i-simple-icons-vuedotjs
    label: components/LandingHero.vue
    ---
    ```vue [components/LandingHero.vue]
      <script setup lang="ts">
      defineProps<{
        image: string 
      }>()
      </script>
      
      <template>
        <section class="flex flex-col sm:flex-row sm:items-center gap-4 py-8 sm:gap-12 sm:py-12">
          <div>
            <h1 class="text-4xl font-semibold">
              <slot name="title" />
            </h1>
            <div class="text-base text-gray-600 dark:text-gray-300">
              <slot name="description" />
            </div>
          </div>
          <img :src="image" class="w-1/2 rounded-lg">
        </section>
      </template>
    ```
    ::::

    ::::tabs-item{icon="i-lucide-eye" label="Preview"}
      :::::browser-frame
      ![vue component edition on Studio](https://nuxt-content.zhcndoc.com/docs/studio/home-content-studio-dark.webp)
      :::::
    ::::
  :::

#title{unwrap="p"}
开发者创建 [编辑体验]{.text-(--ui-primary)}

#description
开发者以自己的方式构建基础设施：自定义组件、媒体库及网站配置。

#features
  :::u-page-feature
  ---
  icon: i-lucide-settings-2
  ---
  #title{unwrap="p"}
  可定制且可编辑的 Vue 组件
  :::

  :::u-page-feature
  ---
  icon: i-simple-icons-markdown
  ---
  #title{unwrap="p"}
  使用我们的可视化编辑器编辑 Markdown
  :::

  :::u-page-feature
  ---
  icon: i-lucide-brush
  ---
  #title{unwrap="p"}
  可视化编辑您的 app.config
  :::

#links
  :::u-button
  ---
  color: neutral
  label: 了解更多关于自定义组件
  to: https://nuxt-content.zhcndoc.com/docs/files/markdown#vue-components
  trailingIcon: i-lucide-arrow-right
  variant: subtle
  ---
  :::
::

::u-page-section
---
reverse: true
orientation: horizontal
---
:video{autoplay controls loop src="https://res.cloudinary.com/nuxt/video/upload/v1744126742/studio/finalpropscomps_usfabp.mp4"}

#title{unwrap="p"}
让 [任何人编辑]{.text-(--ui-primary)} 您的 Nuxt Content 网站

#description
团队和客户获得功能强大的可视化编辑器用于内容管理，从文本编辑到媒体管理——全程无需接触代码。

#features
  :::u-page-feature
  ---
  icon: i-lucide-mouse-pointer-click
  ---
  #title{unwrap="p"}
  带拖拽的 Markdown 可视化编辑器
  :::

  :::u-page-feature
  ---
  icon: i-lucide-file-text
  ---
  #title{unwrap="p"}
  为 `YML` 和 `JSON` 文件生成表单
  :::

  :::u-page-feature
  ---
  icon: i-lucide-image
  ---
  #title{unwrap="p"}
  集中管理所有媒体资源
  :::
::

::u-page-section
---
orientation: horizontal
---
:u-color-mode-image{.size-full dark="/home/pro-dark.svg" light="/home/pro-light.svg"}

#title
[一起编辑]{.text-(--ui-primary)}，即时预览

#description
团队协同编辑内容并通过实时预览看到网站实时变化。从文本编辑到组件更新，每一次更改都会反映在最终网站设计中。体验无延迟、无需手动刷新且顺畅的内容创作流程。

#features
  :::u-page-feature
  ---
  icon: i-lucide-files
  ---
  #title{unwrap="p"}
  实时在网站上查看您的更改
  :::

  :::u-page-feature
  ---
  icon: i-lucide-link
  ---
  #title{unwrap="p"}
  分享带有实时更新的预览链接给任何人
  :::

  :::u-page-feature
  ---
  icon: i-lucide-list
  ---
  #title{unwrap="p"}
  发布前回顾所有更改
  :::
::

::u-page-section
  :::div{.hidden.md:block}
  :u-color-mode-image{.size-full.absolute.bottom-0.inset-x-4.z-[-1] dark="/home/cta-dark.svg" light="/home/cta-light.svg"}
  :::

#title
编辑您的 [Nuxt Content]{.text-(--ui-primary)} 网站的 [最佳方式]{.text-(--ui-primary)}

#links
  :::u-button
  ---
  label: 免费开始使用
  target: _blank
  to: https://nuxt.studio/signin
  trailingIcon: i-lucide-arrow-right
  ---
  :::

  :::u-button
  ---
  color: neutral
  label: 查看价格
  to: https://nuxt-content.zhcndoc.com/studio/pricing
  variant: outline
  ---
  :::

#description
导入您的 Nuxt Content 网站并邀请团队立即协作。
::


# Nuxt Content v3

欢迎使用 Nuxt Content v3，这是一次重大升级，为您的 Nuxt 项目带来更高性能和创新功能。我们基于 Git 的 CMS 的最新版本针对现代应用开发进行了优化。

## 新功能

### 内容集合

集合用于组织项目中的相关项，帮助您更高效地管理大型数据集。主要优势包括：

- **结构化数据**：在 [`content.config.ts`](https://nuxt-content.zhcndoc.com/docs/collections/define#defining-collections) 中配置数据库架构并定义集合
- **类型安全查询**：所有工具均支持 TypeScript 直接集成
- **自动验证**：确保 Frontmatter 字段和数据文件（json、yml 等）的一致性
- **高级查询构建器**：轻松过滤、排序和分页集合数据
- **Studio 集成**：通过 [Studio](https://nuxt-content.zhcndoc.com/studio) 实现更好的表单生成和优化的编辑体验

了解更多关于[内容集合](https://nuxt-content.zhcndoc.com/docs/collections/define)的信息。

### 性能提升

v2 中的一个主要挑战是用于存储文件的大体积包，特别影响无服务器部署。

v3 通过在生产环境中切换到基于 SQL 的存储解决了这一问题。此转换无需任何配置，支持开发模式、静态生成、服务器托管、无服务器和边缘部署。

::prose-note
新的数据库系统改进了数据文件的存储和结构方式，确保更佳的性能和可扩展性。此更新全部在后台完成，不影响您在 Content 中使用的文件类型（

`yml`

、

`json`

 和 

`markdown`

）。
::

优势包括：

- **优化的查询**：SQL 存储实现超高速数据检索
- **通用兼容性**：我们的基于适配器的系统可整合 SQL 数据库，支持所有部署模式（[服务器](https://nuxt-content.zhcndoc.com/docs/deploy/server)、[无服务器](https://nuxt-content.zhcndoc.com/docs/deploy/serverless) 和 [静态](https://nuxt-content.zhcndoc.com/docs/deploy/static)）。我们欢迎社区贡献更多适配器。

### TypeScript 集成

新的集合系统为您的所有数据自动生成 TypeScript 类型。所有工具和 API 都基于您的集合定义强类型，确保开发过程中的类型安全。

### Nuxt Studio 集成 :badge[即将推出]{color="neutral"}

[Nuxt Studio](https://nuxt-content.zhcndoc.com/docs/studio/setup) 与 v3 设计上完美互补。[studio 模块](https://github.com/nuxtlabs/studio-module){rel="&#x22;nofollow&#x22;"}现已直接集成到 Nuxt Content 中，打造理想环境，开发者专注编码，团队成员则通过直观界面管理内容。

---

我们很高兴您能探索这些新功能。深入阅读文档，了解如何集成该模块并在您的下一个项目中实践最佳方案。

## Content V2 迁移

了解如何从 Content v2 迁移到 v3，请参见[迁移指南](https://nuxt-content.zhcndoc.com/docs/getting-started/migration)。


# 安装

## 安装包

选择你喜欢的包管理器来安装 Nuxt Content v3：

::code-group
```bash [pnpm]
pnpm add @nuxt/content
```

```bash [yarn]
yarn add @nuxt/content
```

```bash [npm]
npm install @nuxt/content
```

```bash [bun]
bun add @nuxt/content
```
::

## 注册模块

在你的 `nuxt.config.ts` 文件中添加 Nuxt Content 模块：

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  modules: ['@nuxt/content']
})
```

## 自动安装

使用 `create-nuxt` CLI 创建新 Nuxt 项目时，可以直接从交互式模块选择器中选择 `@nuxt/content`。这将自动为你安装并注册该模块。

::code-group
```bash [npm]
npm create nuxt <project-name>
```

```bash [yarn]
yarn create nuxt <project-name>
```

```bash [pnpm]
pnpm create nuxt <project-name>
```

```bash [bun]
bun create nuxt <project-name>
```

```bash [deno]
deno -A npm:create-nuxt@latest <project-name>
```
::

::note{color="warning"}
当你在 Node.js 中运行项目时，Nuxt Content 会询问你使用哪个数据库连接器。
你可以选择安装 `better-sqlite3` 或 `sqlite3` 包。

:br

如果你不想安装任何包，可以使用从 Node.js\@v22.5.0 或更新版本自带的原生 SQLite。
请查看 [`experimental.nativeSqlite` 配置](https://nuxt-content.zhcndoc.com/docs/getting-started/configuration#experimentalnativesqlite-deprecated-use-sqliteconnector)。
::

## 创建你的第一个集合

在项目根目录创建一个 `content.config.ts` 文件：

```ts [content.config.ts]
import { defineContentConfig, defineCollection } from '@nuxt/content'

export default defineContentConfig({
  collections: {
    content: defineCollection({
      type: 'page',
      source: '**/*.md'
    })
  }
})
```

该配置创建了一个默认的 `content` 集合，用于处理项目 `content` 文件夹内的所有 Markdown 文件。你可以根据需要自定义集合配置。

::tip
`type: page`

 表示内容文件和网站页面之间是一对一的关系。
::

::note{to="https://nuxt-content.zhcndoc.com/docs/collections/define"}
了解更多，请查看我们的 

**集合指南**

。
::

## 创建你的第一个 Markdown 页面

在项目根目录创建 `content/index.md` 文件：

```md [content/index.md]
# 我的第一个页面

这里是一段内容。
```

查看更多关于编写 [Markdown 页面](https://nuxt-content.zhcndoc.com/docs/files/markdown) 的信息。

## 显示你的页面

创建 `pages/index.vue` 文件并展示页面内容：

```vue [pages/index.vue]
<script setup lang="ts">
const { data: home } = await useAsyncData(() => queryCollection('content').path('/').first())

useSeoMeta({
  title: home.value?.title,
  description: home.value?.description
})
</script>

<template>
  <ContentRenderer v-if="home" :value="home" />
  <div v-else>首页未找到</div>
</template>
```

::note{icon="i-lucide-info"}
如果你在一个新的 Nuxt 项目中安装 Nuxt Content，并且项目中没有 `pages` 目录，你还需要更新 `app.vue` 文件，通过添加 `NuxtPage` 组件来允许渲染页面。（如果你的项目已有页面，则无需此操作。）

```vue [app.vue]
<template>
  <NuxtLayout>
    <NuxtPage />
  </NuxtLayout>
</template>
```
::

::tip{icon="i-lucide-rocket"}
就是这样！你已经创建了你的第一个 Nuxt Content 页面。
::


# 配置

要配置内容模块并自定义其行为，您可以在 `nuxt.config` 中使用 `content` 属性：

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  content: {
    // 选项
  }
})
```

::note{to="https://github.com/nuxt-modules/mdc#configurations"}
除了通过 

`content.markdown`

 配置外，您还可以使用 Markdown 组件 (MDC) 通过 

`mdc`

 属性自定义 Markdown 元素的渲染。
::

## `build`

Nuxt Content 会在构建时读取并解析所有可用内容。此选项允许您控制内容解析。

### `markdown`

配置 markdown 解析器。

#### `toc`

::code-group
```ts [默认]
toc: {
  depth: 2,
  searchDepth: 2
}
```

```ts [类型定义]
type Toc = {
  depth: number
  searchDepth: number
}
```
::

控制目录（Table of Contents）的生成行为。

取值：

- `depth`：目录中包含的最大标题深度。
- `searchDepth`：搜索标题时嵌套标签的最大深度。

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  content: {
    build: {
      markdown: {
        toc: {
          depth: 3, // 包含 h3 标题
        }
      }
    }
  }
})
```

#### `remarkPlugins`

::code-group
```ts [默认]
remarkPlugins: {}
```

```ts [类型定义]
type RemarkPlugins = Record<string, false | MarkdownPlugin>
```
::

使用的 [remark](https://github.com/remarkjs/remark){rel="&#x22;nofollow&#x22;"} 插件列表。

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  content: {
    build: {
      markdown: {
        // 对象语法可用于覆盖默认选项
        remarkPlugins: {
          // 覆盖 remark-emoji 选项
          'remark-emoji': {
            options: {
              emoticon: true
            }
          },
          // 禁用 remark-gfm
          'remark-gfm': false,
          // 添加 remark-oembed
          'remark-oembed': {
            // 选项
          }
        },
      }
    }
  }
})
```

#### `rehypePlugins`

::code-group
```ts [默认]
rehypePlugins: {}
```

```ts [类型定义]
type RehypePlugins = object
```
::

使用的 [rehype](https://github.com/remarkjs/remark-rehype){rel="&#x22;nofollow&#x22;"} 插件列表。

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  content: {
    build: {
      markdown: {
        // 对象语法可用于覆盖默认选项
        rehypePlugins: {
          'rehype-figure': {

          }
        },
      }
    }
  }
})
```

#### `contentHeading`

::code-group
```ts [Default]
contentHeading: true
```

```ts [Signature]
type ContentHeading = boolean
```
::

将此选项设置为 `false` 时，禁用自动生成的 `title` 和 `description` 字段（默认从第一个 H1 标题及其后续段落中提取）。

#### `highlight`

::code-group
```ts [默认]
highlight: false
```

```ts [类型定义]
type Highlight = false | object
```
::

Nuxt Content 使用 [Shiki](https://github.com/shikijs/shiki){rel="&#x22;nofollow&#x22;"} 为 [`ProsePre`](https://nuxt-content.zhcndoc.com/docs/components/prose#prosepre) 和 [`ProseCode`](https://nuxt-content.zhcndoc.com/docs/components/prose#prosecode) 提供语法高亮。

| 选项      | 类型                                          | 说明                                                                                                       |
| ------- | ------------------------------------------- | -------------------------------------------------------------------------------------------------------- |
| `theme` | `ShikiTheme` 或 `Record<string, ShikiTheme>` | 要使用的[颜色主题](https://github.com/shikijs/shiki/blob/main/docs/themes.md){rel="&#x22;nofollow&#x22;"}。       |
| `langs` | `ShikiLang[]`                               | 可用于高亮的[加载的语言](https://github.com/shikijs/shiki/blob/main/docs/languages.md){rel="&#x22;nofollow&#x22;"}。 |

- `highlight.theme`

主题可以是单个字符串，也支持带多个主题的对象。

此选项兼容 [Color Mode 模块](https://color-mode.nuxtjs.org/){rel="&#x22;nofollow&#x22;"}。

如果您使用多个主题，建议始终指定 `default` 主题。

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  content: {
    build: {
      markdown: {
        highlight: {
          // 所有配色方案中使用的主题
          theme: 'github-light',
          // 或者
          theme: {
            // 默认主题（同单一字符串）
            default: 'github-light',
            // `html.dark` 时使用的主题
            dark: 'github-dark',
            // `html.sepia` 时使用的主题
            sepia: 'monokai'
          }
        }
      }
    }
  }
})
```

- `highlight.langs`

默认情况下，模块加载了若干语言用于语法高亮：

```ts [默认]
['json', 'js', 'ts', 'html', 'css', 'vue', 'shell', 'mdc', 'md', 'yaml']
```

如果您计划使用其他语言的代码示例，需要在该选项中定义该语言。

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  content: {
    build: {
      markdown: {
        highlight: {
          langs: [
            'c',
            'cpp',
            'java'
          ]
        }
      }
    }
  }
})
```

如果您想为不支持的语言添加高亮，可以通过加载该语言的语法文件实现。

```ts [nuxt.config.ts]
import { readFileSync } from 'node:fs'

export default defineNuxtConfig({
  content: {
    build: {
      markdown: {
        highlight: {
          langs: [
            // 更多关于 Shiki 语言请参阅：https://shiki.style/guide/load-lang
            JSON.parse(
              readFileSync('./shiki/languages/gdscript.tmLanguage.json', 'utf-8'),
            ),
          ]
        }
      }
    }
  }
})
```

更多关于添加语言信息，请参阅 [Shiki 文档](https://github.com/shikijs/shiki/blob/main/docs/languages.md#adding-grammar){rel="&#x22;nofollow&#x22;"}。

### `pathMeta`

内容模块使用文件路径生成 slug、默认标题和内容排序，您可以通过 `pathMeta` 选项自定义此行为。

#### `pathMeta.forceLeadingSlash`

如果设置为 `true`，路径将强制添加前置斜杠。默认值为 `true`。

#### `pathMeta.slugifyOptions`

内容模块使用 [slugify](https://github.com/simov/slugify){rel="&#x22;nofollow&#x22;"} 生成 slug，您可以通过此选项自定义 slugify 行为。

更多信息请查看 [slugify options](https://github.com/simov/slugify#options){rel="&#x22;nofollow&#x22;"}。

### `transformers`

Nuxt Content 为每种内容类型提供特定的转换器，用于解析原始内容并准备查询和渲染。通过此选项，您可以定义自定义转换器以支持新内容类型或增强支持的内容类型功能。

::code-group
```ts [nuxt.config.ts]
export default defineNuxtConfig({
  content: {
    build: {
      transformers: [
        '~/transformers/title-suffix',
      ],
    },
  },
})
```

```ts [~/transformers/title-suffix.ts]
import { defineTransformer } from '@nuxt/content'

export default defineTransformer({
  name: 'title-suffix',
  extensions: ['.md'],
  transform(file) {
    return {
      ...file,
      title: file.title + ' (suffix)',
    }
  },
})
```
::

更多关于转换器内容，请参阅 [Transformers](https://nuxt-content.zhcndoc.com/docs/advanced/transformers) 文档。

## `database`

默认情况下，Nuxt Content 使用本地 SQLite 数据库存储和查询内容。如果您想使用其他数据库，或计划部署到 Cloudflare Workers，可修改此选项。

以下是支持的数据库适配器列表：

### `SQLite`

如果想更改默认数据库位置并移动到其他地方，可使用 `sqlite` 适配器。这是 `database` 选项的默认值。根据运行环境，使用不同的 sqlite 适配器（Node：better-sqlite-3，Bun：bun\:sqlite）。

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  content: {
    database: {
      type: 'sqlite',
      filename: 'SQLITE_DB_LOCATION'
    }
  }
})
```

如果您无法使用普通的文件存储 SQLite 数据库（例如因只读文件系统或平台限制），您可以完全在内存中运行 SQLite。Nuxt Content 会在首次查询时从生成的转储文件恢复数据库。在无服务器平台上，该数据库会在每次冷启动时重新创建；尽可能预渲染更多路由以避免重复的运行时初始化。

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  content: {
    database: {
      type: 'sqlite',
      filename: ':memory:'
    }
  }
})
```

### `D1`

如果计划将应用部署到 Cloudflare Workers，需要使用 `d1` 数据库适配器。在 Cloudflare 控制面板创建 `d1` 绑定，并填写 `bindingName` 字段。

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  content: {
    database: {
      type: 'd1',
      bindingName: 'CF_BINDING_NAME'
    }
  }
})
```

### `Postgres`

如果计划使用 PostgreSQL 数据库部署应用，需要使用 `postgresql` 数据库适配器。

首先，确保安装 `pg` 包：

```bash [终端]
npm i pg
```

然后，在 `nuxt.config.ts` 配置 `postgresql` 适配器：

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  content: {
    database: {
      type: 'postgresql',
      url: process.env.POSTGRES_URL,
      /* 其他 `pg` 选项 */
    }
  }
})
```

### `LibSQL`

如果计划使用 LibSQL 数据库部署应用，需要使用 `libsql` 数据库适配器。

首先，确保安装 `@libsql/client` 包：

```bash [终端]
npm i @libsql/client
```

然后，在 `nuxt.config.ts` 配置 `libsql` 适配器：

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  content: {
    database: {
      type: 'libsql',
      url: process.env.TURSO_DATABASE_URL,
      authToken: process.env.TURSO_AUTH_TOKEN,
    }
  }
})
```

::note
最流行的 LibSQL 托管服务是 

[Turso](https://turso.tech/){rel=""nofollow""}

。
::

### `PGlite`

如果计划使用 PGlite 数据库部署应用，需要使用 `pglite` 数据库适配器。

首先，确保安装 `@electric-sql/pglite` 包：

```bash [终端]
npm i @electric-sql/pglite
```

然后，在 `nuxt.config.ts` 配置 `pglite` 适配器：

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  content: {
    database: {
      type: 'pglite',
      dataDir: '.data/content/pglite'
    }
  }
})
```

::note
建议仅在开发环境使用 PGlite。
::

## `renderer`

配置内容渲染器。

### `anchorLinks`

::code-group
```ts [默认]
{ h2: true, h3: true, h4: true }
```

```ts [类型定义]
type AnchorLinks = boolean | Record<'h1' | 'h2' | 'h3' | 'h4' | 'h5' | 'h6', boolean>
```
::

控制锚点链接的生成，默认为 `h2`、`h3` 和 `h4` 标题生成锚点链接。

取值：

- `false`：禁用链接生成。
- `true`：为所有标题启用链接生成。

### `alias`

::code-group
```ts [默认]
alias: {}
```

```ts [类型定义]
type Alias = Record<string, string>
```
::

别名用于替换 markdown 组件，渲染自定义组件替代默认组件。

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  content: {
    renderer: {
      alias: {
        p: 'MyCustomParagraph'
      }
    }
  }
})
```

## `watch`

```ts [默认]
watch: {
  enabled: true
}
```

配置开发环境中的内容热重载。

取值：

- `enabled`：启用/禁用热重载。
- `port`：WebSocket 服务器使用的端口。
- `showURL`：切换开发服务器启动消息中是否显示 URL。

Nuxt Content 使用 [listhen](https://github.com/unjs/listhen){rel="&#x22;nofollow&#x22;"} 提供本地开发服务器。更多信息请查阅 [listhen 文档](https://github.com/unjs/listhen#options){rel="&#x22;nofollow&#x22;"}。

::callout
观察器为开发特性，生产环境不会包含。
::

::code-group
```ts [启用]
export default defineNuxtConfig({
  content: {
    watch: {
      port: 4000,
      showURL: true
    }
  }
})
```

```ts [禁用]
export default defineNuxtConfig({
  content: {
    watch: {
      enabled: false
    }
  }
})
```

## `experimental`

尚未稳定的实验性功能。

### `experimental.sqliteConnector`

SQLite 连接器在不同环境下有不同限制。有些能在无服务器环境下工作，而有些不能。Nuxt Content 支持三种不同的 SQLite 连接器以覆盖各种环境：

- `better-sqlite3`：适用于所有 Node 环境、GitHub CI、Vercel CI 和生产环境、Cloudflare CI 流水线等。（**不**支持 WebContainers 和 StackBlitz）
- `sqlite3`：适用于 Node 环境、GitHub CI 和 StackBlitz。（**不**支持 Vercel 或 Cloudflare）
- `native`：从 Node.js v22.5.0 起，`node:sqlite` 模块在 Node.js 原生支持。该连接器在所有 Node 环境中适用于 Node.js 版本 22.5.0 及以上。

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  content: {
    experimental: { sqliteConnector: 'native' },
  },
});
```

### `experimental.nativeSqlite` (已废弃，使用 `sqliteConnector` 替代)

从 Node.js v22.5.0 开始，Node.js 原生支持 `node:sqlite` 模块。
这允许 Nuxt Content 在不依赖外部包的情况下使用 SQLite 作为数据库。

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  content: {
    experimental: { nativeSqlite: true },
  },
});
```

  :::prose-note
  此功能仅在 Node.js v22.5.0 及以上版本可用。在较旧版本启用此选项不会生效。
  :::
::


# 迁移

Nuxt Content v3 已经从头重建，带来了一个具有增强功能的新库。虽然我们设计了与 Content v2 类似的概念和组件，但破坏性变更是不可避免的。

别担心，你不需要修改你的内容文件。我们确保 Content v3 以与 Content v2 相同的方式处理内容。

## 变更

### Vue 工具

- `queryContent()` API 被新的 `queryCollection()` 替代

::prose-tip
新 API 基于 SQL，内容查询发生在特定的集合中。
::

- `fetchContentNavigation()` API 被新的 `queryCollectionNavigation()` 替代
- Surroundings （周边）现在有自己的独立 API：`queryCollectionItemSurroundings()`
- 放弃了文档驱动模式：`Markdown` 文件将不再自动转换为 Nuxt 页面，你需要自己创建页面，[查看此部分了解如何创建](https://nuxt-content.zhcndoc.com/docs/components/content-renderer#example-usage)。
- 移除 `useContent()` 组合函数
- `searchContent()` 被新的 `queryCollectionSearchSections` API 取代
- 可以方便地使用 `queryCollectionSearchSections` API 实现全文搜索，[查看此部分了解如何使用](https://nuxt-content.zhcndoc.com/docs/advanced/fulltext-search)

### 组件

- 所有内容应使用 `<ContentRenderer>` 组件渲染。`<ContentDoc>`、`<ContentList>`、`<ContentNavigation>` 和 `<ContentQuery>` 组件在 v3 中被移除。
- `<ContentSlot>` 和 `<MDCSlot>` 组件在 v3 中不再支持。组件可以直接使用 Vue 原生的 `<slot>` 组件。

::prose-note
`<ContentSlot>`

 和 

`<MDCSlot>`

 最初用于在渲染前操作内容并移除 slot 内容的包裹段落。此取消包裹行为现在通过 

`<slot>`

 组件上的 

`mdc-unwrap`

 属性支持。例如：

`<slot mdc-unwrap="p" />`
::

- 放置在 `components/content` 目录下的组件不再自动注册为全局组件。如果你使用[动态渲染](https://vuejs.org/guide/essentials/component-basics.html#dynamic-components){rel="&#x22;nofollow&#x22;"}来渲染这些组件（即在 markdown 文件外部渲染），你必须在 Nuxt 应用中手动注册它们。详细操作请查看 [Nuxt - 自定义组件目录](https://nuxt.com/docs/guide/directory-structure/components#custom-directories){rel="&#x22;nofollow&#x22;"}文档。

### 类型

- `import type { NavItem } from '@nuxt/content/dist/runtime/types'` 替换为 `import type { ContentNavigationItem } from '@nuxt/content'`

### 通用

- `_dir.yml` 文件被重命名为 `.navigation.yml`
- 模块选项中不再有 source 选项，取而代之的是你可以在 `content.config.ts` 中为你的集合定义[多个源](https://nuxt-content.zhcndoc.com/docs/collections/sources)
- 文档的 `._path` 字段现在被重命名为 `.path`，同样所有以下划线 `_` 开头的内部字段都被删除或重命名
- `useContentHelpers()` 已被移除
- 模块默认不忽略点文件，你可以通过在集合源的 `exclude` 选项中添加 `ignore: ['**/.*']` 来忽略点文件
- 由于 SQL 的限制，排序规则现在改为字母顺序而非数字顺序。更多信息请查看 [排序文件](https://nuxt-content.zhcndoc.com/docs/collections/types#ordering-files) 部分。
- 模块选项从 v2 起发生了变化，详情请参阅[配置页面](https://nuxt-content.zhcndoc.com/docs/getting-started/configuration)

## 在 v3 实现文档驱动模式

在 Content v3 中实现文档驱动模式非常简单。你只需在 Nuxt 中创建一个通配页面，并基于路由路径获取内容。

```vue [pages/[...slug\\].vue]
<script lang="ts" setup>
const route = useRoute()
const { data: page } = await useAsyncData(route.path, () => {
  return queryCollection('content').path(route.path).first()
})
</script>

<template>
  <div>
    <header><!-- ... --></header>

    <ContentRenderer v-if="page" :value="page" />

    <footer><!-- ... --></footer>
  </div>
</template>
```

## 将 `queryContent` 转换为 `queryCollections`

如上所述，`queryContent` 被基于新的集合的 `queryCollection` 取代。两者主要有两个区别：

1. `queryCollection` 构建的是 SQL 数据库的查询。
2. `queryCollection` 只在指定的集合内搜索。你需要知道集合的名称（配置中的键名）。

```ts [根据路径查找内容]
// Content v2
const v2Query = await queryContent(route.path).findOne()
// Content v3 - 不要忘记在 `content.config.ts` 中创建 `content` 集合
const v3Query = await queryCollection('content').path(route.path).first()
```

```ts [使用自定义过滤器查找内容]
// Content v2
const v2Query = await queryContent()
  .where({ path: /^\/hello\/.*/ })
  .find()
// Content v3 - 不要忘记在 `content.config.ts` 中创建 `content` 集合
const v3Query = await queryCollection('content')
  .where('path', 'LIKE', '/hello%')
  .first()
```

::prose-note{to="https://nuxt-content.zhcndoc.com/docs/collections/define"}
查看专门关于集合的章节以获取更多信息
::

## 转换 `queryContent().findSurround()`

Surround 现在有了自己独立的 API。

```ts
const targetPath = '/docs'

// Content v2
const v2Surround = await queryContent(targetPath)
  .only(['title', 'description', 'navigation'])
  .findSurround(withoutTrailingSlash(route.path))

// Content v3 - 不要忘记在 `content.config.ts` 中创建 `content` 集合
const v3Surround = await queryCollectionItemSurroundings(
  'content',
  targetPath,
  {
    fields: ['title', 'description', 'navigation']
  }
)
```

::prose-note
查看专门章节以获取更多关于 Surround 的信息
::

## 合并 `ProsePre`、`ProseCode` 和 `ProseCodeInline` 组件

许多 `ProsePre` 组件是 `ProseCode` 组件的轻量包装。我们将这三个组件整合成两个组件。现在 `ProsePre` 与多行代码块没有区别。

1. MDC 现在会将单个反引号 `` ` `` 映射并解析为 `ProseCode`，而非 `ProseCodeInline`。
2. MDC 现在会将以三个反引号 ` ``` ` 开始的代码块映射并解析为 `ProsePre` 组件。

**建议更改：**

1. 将现有的 `ProseCode` 逻辑迁移到 `ProsePre`
2. 将你的 `ProseCodeInline` 组件重命名为 `ProseCode`

## `_dir.yml` 文件重命名为 `.navigation.yml`

在 Content v3 中，我们将 `_dir.yml` 重命名为 `.navigation.yml`，该新名称更好地反映了这些文件的作用。 :br
模块使用这些文件收集目录信息以生成导航。

注意，为了使模块能够访问这些文件，你应该在定义集合源时确保包含这些文件。例如，`source: '**'` 和 `source: '**/*.{md,yml}'` 会将这些文件包含在集合内，但 `source: '**/*.md'` 不会包含它们。

## 忽略点文件

默认情况下，Content v3 不忽略点文件。如果你想忽略它们，可以在集合源的 `exclude` 选项中添加 `ignore: ['**/.*']`。

```ts
defineCollection({
  source: {
    include: '**',
    exclude: ['**/.*']
  }
})
```

注意，上述模式也会从集合中排除 `.navigation.yml` 文件。如果你使用 `.navigation.yml` 并希望保留它们，可以使用 `**/.(!(navigation.yml))` 模式来排除所有点文件但保留 `.navigation.yml`。

```ts
defineCollection({
  source: {
    include: '**',
    exclude: ['**/.!(navigation.yml)']
  }
})
```


# 定义内容集合

Nuxt Content 模块会自动解析位于 Nuxt 应用根目录下 `content/` 文件夹中的所有内容文件。此设置允许你自由地组织文件夹结构，以满足项目需求。

为了更好地组织内容，你可以使用内容集合 (Content Collections)，它们帮助你更有效地分类和管理内容。这些集合在 `content.config.ts` 文件中定义。

::warning
如果没有 

`content.config.ts`

 文件，内容文件夹中的所有文件都会被默认解析和导入。但一旦添加了配置文件，只有符合集合中指定路径模式的文件才会被导入。
::

## 什么是内容集合？

内容集合是 Nuxt Content 项目中组织相关内容的方式。它们提供了一种结构化方法来管理内容，使查询、展示和维护网站数据更加便捷。

关键特性包括：

- **逻辑分组**：将相似内容归为一类，如博客文章、产品页面或文档
- **共享配置**：对集合内所有条目应用通用设置和验证
- **优化查询**：高效获取和筛选相关内容项
- **自动类型推断**：在开发环境中获得类型安全和自动补全
- **灵活结构**：按内容类型、类别或任何适合你的逻辑分组组织集合

## 定义集合

在项目根目录创建一个 `content.config.ts` 文件。这个特殊文件用于配置你的集合数据库、工具类型和内容处理。

以下是一个基础示例：

```ts [content.config.ts]
import { defineCollection, defineContentConfig } from '@nuxt/content'

export default defineContentConfig({
  collections: {
    docs: defineCollection({
      // 指定此集合内内容的类型
      type: 'page',
      // 加载 `content` 目录下的所有文件
      source: '**',
    })
  }
})
```

::warning
目前，一个文档设计为仅归属一个集合。如果同一文件被多个集合引用，实时重新加载功能将无法正常工作。为避免此问题，建议使用 `exclude` 属性，通过合适的正则表达式显式排除文档在其他集合中出现。

该话题仍在此 issue 中讨论中：[nuxt/content#2966](https://github.com/nuxt/content/issues/2966){rel=""nofollow""}。
::

### 集合模式 (Schema)

模式用于强制集合内数据的一致性，并作为 TypeScript 类型的唯一来源。

除内置字段外，你还可以通过为集合添加 `schema` 属性，利用 [`zod`](https://zod.dev){rel="&#x22;nofollow&#x22;"} 模式定义自定义模式：

```ts [content.config.ts]
import { defineCollection, defineContentConfig } from '@nuxt/content'
import { z } from 'zod'

export default defineContentConfig({
  collections: {
    blog: defineCollection({
      type: 'page',
      source: 'blog/*.md',
      // 为 docs 集合定义自定义模式
      schema: z.object({
        tags: z.array(z.string()),
        image: z.string(),
        date: z.date()
      })
    })
  }
})
```

::note
`@nuxt/content`

 暴露了一个 

`z`

 对象，包含一组用于常见数据类型的 Zod 模式。完整文档请查看 

[Zod 的 README](https://github.com/colinhacks/zod){rel=""nofollow""}

，了解它的工作原理及可用特性。
::

::tip
你可以定义任意数量的集合，以组织不同类型的内容。
::

### 数据库索引

通过在集合字段上定义索引来优化查询性能。索引对于用于过滤、排序或查找的字段尤其有用。

```ts [content.config.ts]
import { defineCollection, defineContentConfig } from '@nuxt/content'
import { z } from 'zod'

export default defineContentConfig({
  collections: {
    products: defineCollection({
      type: 'data',
      source: 'products/*.json',
      schema: z.object({
        sku: z.string(),
        price: z.number(),
        category: z.string(),
        inStock: z.boolean(),
      }),
      indexes: [
        // 单字段索引
        { columns: ['category'] },
        { columns: ['price'] },

        // 复合索引用于 category + price 筛选
        { columns: ['category', 'price'] },

        // 唯一索引用于确保 SKU 唯一性
        { columns: ['sku'], unique: true },

        // 自定义索引名称（可选）
        { columns: ['inStock', 'category'], name: 'idx_stock_category' },
      ],
    }),
  },
})
```

::note
索引会在数据库模式生成时自动创建。它们适用于所有支持的数据库：SQLite、Cloudflare D1、PostgreSQL、LibSQL 和 PGlite。
::

::tip{icon="i-ph-lightbulb"}
**Cloudflare D1 成本优化**

：使用索引时，对索引列上的 

`WHERE`

 子句，当只有单条匹配记录时，仅计为读取 1 行。没有索引时，D1 会计数表中扫描的所有行，显著增加读取成本。索引能大幅降低你的 D1 计费。
::

**索引配置选项：**

- **`columns`**（必填）：索引包含的列名数组
- **`unique`**（可选）：是否为唯一索引，默认为 `false`
- **`name`**（可选）：自定义索引名称，省略时自动生成，如 `idx_{collection}_{column1}_{column2}`

**性能建议：**

- 对使用在 `where()` 查询中的列建立索引以加快过滤速度
- 对排序用的列建立索引以优化排序性能
- 对多列组合进行复合索引，适用于多条件筛选或排序
- 唯一索引自动执行数据唯一性约束

## 查询集合

使用 [`queryCollection`](https://nuxt-content.zhcndoc.com/docs/utils/query-collection) 工具从集合中获取一个或所有内容项：

```vue [pages/blog.vue]
<script setup lang="ts">
const { data: posts } = await useAsyncData('blog', () => queryCollection('blog').all())
</script>

<template>
  <div>
    <h1>博客</h1>
    <ul>
      <li v-for="post in posts" :key="post.id">
        <NuxtLink :to="post.path">{{ post.title }}</NuxtLink>
      </li>
    </ul>
  </div>
</template>
```

::note{to="https://nuxt-content.zhcndoc.com/docs/utils/query-collection"}
了解更多关于可用查询选项的信息，请查阅我们的 

`queryCollections`

 API 文档。
::

## defineCollection()

`defineCollection` 函数用于在内容配置中定义一个集合。它的 TypeScript 签名如下：

```ts
function defineCollection(collection: Collection): DefinedCollection

type Collection = {
  // 决定内容如何处理
  type: 'page' | 'data'
  // 指定内容位置
  source?: string | CollectionSource
  // 用于内容验证和类型定义的 Zod 模式
  schema?: ZodObject<T>
  // 数据库索引，用于查询优化
  indexes?: CollectionIndex[]
}

type CollectionIndex = {
  // 需要包含在索引中的列名
  columns: string[]
  // 自定义索引名称（可选）
  name?: string
  // 是否为唯一索引（默认: false）
  unique?: boolean
}
```

::note{to="https://nuxt-content.zhcndoc.com/docs/collections/types"}
了解更多关于集合类型的内容。
::

```ts
type CollectionSource = {
  // 匹配内容的 glob 模式
  include: string
  // 路径前缀（仅适用于 'page' 类型）
  prefix?: string
  // 排除内容的 glob 模式数组
  exclude?: string[]
  // 匹配内容的根目录
  cwd?: string
  // 远程 git 仓库地址（例如：https://github.com/nuxt/content）
  repository?: string
  // 私有仓库的认证令牌（例如 GitHub 个人访问令牌）
  authToken?: string
}
```

::note{to="https://nuxt-content.zhcndoc.com/docs/collections/sources"}
了解更多关于集合资源的信息。
::

该函数返回已定义的集合对象。


# 集合类型

在 Nuxt Content 中，你可以根据集合文件的预期用途为每个集合指定一个类型。集合可以定义为 &#x2A;*page（页面）** 或 &#x2A;*data（数据）** 类型。

对于这两种类型，都会生成内置字段。每个集合都包含以下默认字段：

- `id`: 唯一内容标识符
- `stem`: 不带扩展名的文件路径（用于排序和定位）
- `extension`: 文件扩展名
- `meta`: 不在集合模式中定义的自定义字段

## 页面类型

```ts
defineCollection({
  source: '**/*.md',
  type: 'page'
})
```

::tip
如果内容文件与网站页面之间是一对一关系，请使用 

**page**

 类型。
::

### 路径生成

Nuxt Content 会自动为集合中的每个文件生成路径，方便创建 URL 映射。

以下是基于文件结构生成的路径示例：

| 文件                               | 路径                    |
| -------------------------------- | --------------------- |
| `content/index.md`               | `/`                   |
| `content/about.md`               | `/about`              |
| `content/blog/index.md`          | `/blog`               |
| `content/blog/hello.md`          | `/blog/hello`         |
| `content/1.guide/2.installation` | `/guide/installation` |

::note
你可以使用辅助函数 

[`queryCollection('COLLECTION').path('PATH')`](https://nuxt-content.zhcndoc.com/docs/utils/query-collection)

 按特定路径检索内容。
::

### 模式重写

当你使用 **page** 类型时，Nuxt Content 会生成几个常用于网页的标准字段。这些字段提供结构性，并且 **会自动** 应用于集合的模式：

- `path`: 生成的路由路径
- `title`: 页面标题
- `description`: 页面描述
- `seo`: SEO 元数据（与 Nuxt 的 `useSeoMeta` 组合函数配合使用）
- `body`: 解析为 AST 的页面内容
- `navigation`: 页面导航配置（用于 [queryCollectionNavigation](https://nuxt-content.zhcndoc.com/docs/utils/query-collection-navigation)）

对应应用的模式如下：

```ts
  path: z.string(),
  title: z.string(),
  description: z.string(),
  seo: z.intersection(
    z.object({
      title: z.string().optional(),
      description: z.string().optional(),
      meta: z.array(z.record(z.string(), z.any())).optional(),
      link: z.array(z.record(z.string(), z.any())).optional(),
    }),
    z.record(z.string(), z.any()),
  ).optional().default({}),
  body: z.object({
    type: z.string(),
    children: z.any(),
    toc: z.any(),
  }),
  navigation: z.union([
    z.boolean(),
    z.object({
      title: z.string(),
      description: z.string(),
      icon: z.string(),
    }),
  ]).default(true),
```

::note
你可以通过在集合模式中定义这些字段来覆盖它们。
::

## 数据类型

```ts
defineCollection({
  source: 'authors/**.yml',
  type: 'data'
})
```

数据类型适用于那些不直接对应网页，而是表示你可能想在应用中查询和展示的结构化数据的内容。

对于数据集合，你可以完全控制模式，自定义结构。

::note
集合类型和文件扩展名之间没有严格的对应关系。例如，

**page**

 集合可以使用 

[Markdown](https://nuxt-content.zhcndoc.com/docs/files/markdown)

、

[YAML](https://nuxt-content.zhcndoc.com/docs/files/yaml)

 或 

[JSON](https://nuxt-content.zhcndoc.com/docs/files/json)

 文件，

**data**

 集合也可以使用这些格式中的任何一种。
::

## 文件排序

对于这两种类型，你可能希望控制列表中的显示顺序。通过在文件和目录名称中使用数字前缀来指定顺序。Nuxt Content 会使用这些数字对内容列表进行排序。

::note
Nuxt Content 使用字母顺序进行排序，因此如果需要使用数字顺序，单数字前请加 

`0`

 前缀。例如，不加 

`0`

 前缀时，

`10.foo.md`

 会排在 

`2.bar.md`

 前面。
::

```text [目录结构]
content/
  1.frameworks/
    1.vue.md
    2.nuxt.md
    ...
  2.examples/
    01.nuxthub.md
    02.vercel.md
    03.netlify.md
    04.heroku.md
    ...
    10.cloudflare.md
    index.md
```

::warning
数字和文件名之间请使用 

`.`

 字符分隔。使用其他分隔符将无效。
::


# 集合来源

Nuxt Content 提供了多种方式将内容文件导入到您的集合中。您可以在 `defineCollection` 中通过 `source` 属性配置源：

```ts [content.config.ts]
import { defineCollection, defineContentConfig } from '@nuxt/content'

export default defineContentConfig({
  collections: {
    docs: defineCollection({
      source: '**',
      type: 'page'
    })
  }
})
```

## `source`

`source` 属性可以定义为字符串（遵循 glob 模式）或对象，便于更详细地配置目标目录以及内容文件夹内的文件。

**示例：**

- `source: '**'` 包括内容目录及其子目录中的所有文件。
- `source: '**/*.md'` 包括内容目录及其子目录中的所有 `Markdown` 文件。
- `source: 'docs/**/*.yml'` 包括 `content/docs` 目录及其子目录中的所有 `YML` 文件。
- `source: '**/*.{json,yml}'` 包括内容目录及所有子目录中的 `JSON` 或 `YML` 文件。
- `source: '*.json'` 仅包括内容目录中直接包含的 `JSON` 文件，不包括子目录。

### `include`（必填）

目标仓库及内容文件夹中文件的 glob 模式。

### `exclude`

用于排除导入内容的 glob 模式。

### `prefix`

此配置仅针对 **page** 类型，且内容文件与页面为一对一关系时生效。

它表示网站中对应页面的路径前缀（基础 URL）。

::prose-warning
`prefix`

 必须以 

`/`

 开头。
::

默认情况下，模块会提取 `source`（或 `source.include`）的静态前缀，并将其用作内容路径的前缀。例如，如果你定义了 `/en/**` 作为源，模块会自动将 `prefix` 填充为 `/en`。你也可以手动提供一个前缀来覆盖此行为。通过将集合源中的 `prefix` 设置为 `'/'` 可以移除前缀。

```ts
defineCollection({
  type: "page",
  source: {
    include: "en/**",
    exclude: ["en/index.md"],
    prefix: '/'
  }
})
```

### `cwd`

匹配内容的根目录。

**示例：**

如果想要包含内容目录以外文件夹中的文件，可将该文件夹的绝对路径赋值给 `cwd` 属性。

```ts
source: {
  cwd: path.resolve('packages/my-pkg/docs'),
  include: '**/*.md',
}
```

### `repository`

定义外部源时必须同时定义 `include` 选项。`include` 模式对于模块识别集合需要使用的文件至关重要。

```js
import { defineCollection, defineContentConfig } from '@nuxt/content'

export default defineContentConfig({
  collections: {
    docs: defineCollection({
      type: 'page',
      source: {
        repository: 'https://github.com/nuxt/content',
        include: 'docs/content/**',
      },
    })
  }
})
```

#### `branch` / `tag`

此选项允许通过 Git 仓库的标签或分支克隆仓库。

**示例：**

如果你想要通过标签克隆，将 `repository` 属性设置为一个对象，包含仓库的 `url` 和 `tag` 属性。

```js
import { defineCollection, defineContentConfig } from '@nuxt/content'

export default defineContentConfig({
  collections: {
    docs: defineCollection({
      type: 'page',
      source: {
        repository: {
          url: 'https://github.com/nuxt/content',
          tag: 'v1'
        },
        include: 'docs/content/**',
      },
    })
  }
})
```

**示例：**

如果你想要通过远程分支克隆，将 `repository` 属性设置为一个对象，包含仓库的 `url` 和 `branch` 属性。

```js
import { defineCollection, defineContentConfig } from '@nuxt/content'

export default defineContentConfig({
  collections: {
    docs: defineCollection({
      type: 'page',
      source: {
        repository: {
          url: 'https://github.com/nuxt/content',
          branch: 'dev'
        },
        include: 'docs/content/**',
      },
    })
  }
})
```

#### `auth`

此选项允许对 Git 仓库进行基础认证和基于令牌的认证。

::warning{icon="i-lucide-shield-alert"}
切勿将认证令牌或凭据直接提交到代码库。请使用环境变量或其他安全方式在运行时提供这些值。
::

**示例：**

如果你想使用基础认证（例如，用于 Bitbucket 仓库），可以这样配置：

```ts
defineCollection({
  type: 'page',
  source: {
    repository: {
      url: 'https://bitbucket.org/username/repo',
      auth: {
        username: 'username',
        password: 'password',
      },
    },
  },
})
```

**示例：**

如果你需要使用认证令牌（例如，用于 Github、Gitlab 或某些 Forgejo 提供商），可以这样配置：

```ts
defineCollection({
  type: 'page',
  source: {
    repository: {
      url: 'https://github.com/username/repo',
      auth: {
        username: 'username',
        token: 'password',
      },
    },
  },
})
```


# 模式验证器

Nuxt Content 支持使用多种验证器定义集合模式。开箱即用的支持包括流行库如 **Zod v3 / v4** 和 **Valibot**（示例见下文）。该系统具有可扩展性，也可以通过 JSON Schema 适配器支持其他验证器。模式用于强制数据一致性，并驱动生成的类型和 Studio 表单。

## 使用 Zod v3

### 安装

```bash
pnpm add -D zod zod-to-json-schema
# 或者
npm i -D zod zod-to-json-schema
```

建议直接从 `zod` 导入 `z`。

```ts [content.config.ts]
import { defineContentConfig, defineCollection, property } from '@nuxt/content'
import { z } from 'zod' // 如果你的环境暴露了此子路径，也可以用 'zod/v3'

export default defineContentConfig({
  collections: {
    blog: defineCollection({
      type: 'page',
      source: 'blog/*.md',
      schema: z.object({
        title: z.string(),
        description: z.string().optional(),
        date: z.date(),
        draft: z.boolean().default(false),
        tags: z.array(z.string()).optional(),
        image: z.object({
          src: property(z.string()).editor({ input: 'media' }),
          alt: z.string()
        })
      })
    })
  }
})
```

::note
日期在内部以 ISO 字符串格式序列化（JSON Schema 中 

`format: date-time`

）。
::

::warning
`@nuxt/content`

 重新导出的 

`z`

 已废弃，将在未来版本中移除。请改为从 

`zod`

（或 

`zod/v3`

）导入 

`z`

。
::

## 使用 Zod v4

Zod v4 提供原生的 JSON Schema 导出，无需依赖 `zod-to-json-schema`。

### 安装

```bash
pnpm add -D zod
# 或者
npm i -D zod
```

```ts [content.config.ts]
import { defineContentConfig, defineCollection, property } from '@nuxt/content'
import { z } from 'zod/v4'

export default defineContentConfig({
  collections: {
    docs: defineCollection({
      type: 'page',
      source: 'docs/**/*.md',
      schema: z.object({
        title: z.string(),
        description: z.string().optional(),
        updatedAt: z.date(),
        draft: z.boolean().optional(),
        tags: z.array(z.string()).optional(),
        hero: z.object({
          image: property(z.string()).editor({ input: 'media' }),
          caption: z.string().optional()
        })
      })
    })
  }
})
```

## 使用 Valibot

使用 Valibot 原语定义你的模式。

### 安装

```bash
pnpm add -D valibot @valibot/to-json-schema
# 或者
npm i -D valibot @valibot/to-json-schema
```

```ts [content.config.ts]
import { defineContentConfig, defineCollection, property } from '@nuxt/content'
import { object, string, boolean, array, date, optional } from 'valibot'

export default defineContentConfig({
  collections: {
    docs: defineCollection({
      type: 'page',
      source: 'docs/**/*.md',
      schema: object({
        title: string(),
        description: optional(string()),
        updatedAt: date(),
        draft: optional(boolean()),
        tags: optional(array(string())),
        hero: object({
          image: property(string()).editor({ input: 'media' }),
          caption: optional(string())
        })
      })
    })
  }
})
```

## 如何选择验证器

- **Zod v3**：经过实战考验，生态丰富；通过重新导出的 `z` 提供优秀的开发体验。
- **Valibot**：轻量且性能优异；需自行从 `valibot` 导入。

只需安装并使用你需要的验证器。Nuxt Content 会自动检测已安装的支持的验证器。

## 对其他验证器的支持

Nuxt Content 内部将集合模式转换为 JSON Schema Draft-07。如果你喜欢的验证器可以转换为 Draft-07（或有兼容的适配器），则可以支持。目前自动检测支持 Zod（v3 和 v4）和 Valibot。如果你希望得到对其他验证器的一级支持，可以考虑在 [Nuxt Content 仓库](https://github.com/nuxt/content){rel="&#x22;nofollow&#x22;"} 提交 issue 或 PR。

## 编辑器元数据（可选）

你可以通过两个验证器的 `property(...).editor({ ... })` 来丰富 Studio 字段。映射详情请参阅 Studio 文档。

::tip{to="https://nuxt-content.zhcndoc.com/docs/studio/content"}
了解编辑器元数据如何映射到 Studio 中的表单输入。
::


# 从 Vue 组件继承 Schema

你可以将 Vue 组件的 props 复用为集合 Schema 的一部分。这有助于保持内容模型与界面的一致，减少重复，并防止偏差。

## 工作原理

Nuxt Content 提供了一个 `property()` 辅助函数，用于增强你的验证器并添加以下功能：

- **inherit(path)**：用位于 `path` 的 Vue 组件推断出的 props JSON Schema 替换当前的对象 Schema

底层机制是，Nuxt Content 通过 `nuxt-component-meta` 读取组件的 props，并将其转换为 JSON Schema，然后合并到你的集合 Schema 中。

## 示例

```ts [content.config.ts]
import { defineContentConfig, defineCollection, property } from '@nuxt/content'
import { z } from 'zod'

export default defineContentConfig({
  collections: {
    pages: defineCollection({
      type: 'page',
      source: '**/*.md',
      schema: z.object({
        // 复用本地组件的 props
        hero: property(z.object({})).inherit('app/components/HeroSection.vue'),

        // 复用依赖包中的组件 props（路径像导入一样解析）
        button: property(z.object({})).inherit('@nuxt/ui/components/Button.vue')
      })
    })
  }
})
```

## 说明

- `inherit()` 的参数会像模块路径一样解析。你可以传入相对于项目根目录的相对路径或包路径。
- `inherit()` 期望用在对象字段上（例如 `property(z.object({}))`）。
- 支持嵌套使用：你可以将继承的对象放在其他对象或数组中；Nuxt Content 会递归替换 `$content.inherit` 标记。
- 如果组件无法解析，Schema 会回退到原始的对象定义。

::tip
如果你需要在组件 props 基础上自定义输入框，可以将 

`inherit()`

 和 

`editor(...)`

 配合使用，从而获得更好的 Studio 表单体验。
::


# Markdown

## 用法

### 定义集合

```ts [content.config.ts]
import { defineCollection, defineContentConfig } from '@nuxt/content'
import { z } from 'zod'

export default defineContentConfig({
  collections: {
    blog: defineCollection({
      type: 'page',
      source: 'blog/*.md',
      schema: z.object({
        date: z.string()
      })
    })
  }
})
```

::note{to="https://nuxt-content.zhcndoc.com/docs/collections/types#page-type"}
了解更多关于 

`page`

 集合类型。
::

### 创建 `.md` 文件

在 `content/blog/` 目录中创建博客文章。

::code-group
```md [foo.md]
---
date: 2020-11-11
---

# Foo

这是 Foo 博客文章。
```

```md [bar.md]
---
date: 2024-12-12
---
Hello
我是 bar。很高兴认识你。
```
::

### 查询 Markdown 文件

现在我们可以查询博客文章：

```ts
// 获取 foo 文章
const fooPost = await queryCollection('blog').path('/blog/foo').first()

// 查找所有文章
const allPosts = await queryCollection('blog').order('date', 'DESC').all()
```

### 显示 Markdown

要显示 Markdown 文件的内容，可以使用 [`<ContentRenderer>`](https://nuxt-content.zhcndoc.com/docs/components/content-renderer) 组件。

```vue [blog/[slug\\].vue]
<script setup>
const slug = useRoute().params.slug
const { data: post } = await useAsyncData(`blog-${slug}`, () => {
  return queryCollection('blog').path(`/blog/${slug}`).first()
})
</script>

<template>
  <!-- 以 Prose 和 Vue 组件渲染博客文章 -->
  <ContentRenderer :value="post" />
</template>
```

::note
阅读更多关于 

[`<ContentRenderer>`](https://nuxt-content.zhcndoc.com/docs/components/content-renderer)

 组件和 

[`Prose 组件`](https://nuxt-content.zhcndoc.com/docs/components/prose)

。
::

## Frontmatter

Frontmatter 是基于 Markdown 的 CMS 约定，用于为页面提供元数据，如描述或标题。在 Nuxt Content 中，frontmatter 使用 YAML 语法，采用 `key: value` 键值对形式。

这些数据在渲染内容时可用，可以存储你需要的任何信息。

### 语法

你可以在 `content/` 目录的 Markdown 文件顶部，用 `---` 标识符声明 frontmatter 块。

```md [content/index.md]
---
title: '页面标题'
description: '页面的元描述'
---

<!-- 页面内容 -->
```

```ts [example.ts]
const home = await queryCollection('content').path('/').first()

console.log(home.title)
// => '页面标题'
console.log(home.description)
// => '页面的元描述'
console.log(home.body)
// => 页面内容的 AST 对象
```

### 原生参数

|               |           |              |                                                                                                                         |
| ------------- | --------- | ------------ | ----------------------------------------------------------------------------------------------------------------------- |
| 键             | 类型        | 默认值          | 描述                                                                                                                      |
| `title`       | `string`  | 页面第一个 `<h1>` | 页面标题，也会被注入到元信息 (metas) 中                                                                                                |
| `description` | `string`  | 页面第一个 `<p>`  | 页面描述，将显示在标题下方并注入到元信息 (metas)                                                                                            |
| `navigation`  | `boolean` | `true`       | 定义页面是否包含在 [`queryCollectionNavigation`](https://nuxt-content.zhcndoc.com/docs/utils/query-collection-navigation) 的返回值中。 |

::warning
frontmatter 块中定义的额外参数需要在你的 schema 中定义（参见本页顶部示例中的 date 参数），才能用于查询。
::

## MDC 语法

我们创建了 MDC 语法来增强 Markdown，赋予你在 Markdown 中集成带有插槽和属性的 Vue 组件的能力。

::info{to="https://remark-mdc.nuxt.space/#syntax"}
探索完整的 MDC 文档。
::

::callout
---
icon: i-simple-icons-visualstudiocode
to: https://marketplace.visualstudio.com/items?itemName=Nuxt.mdc
---
安装 

**MDC VS Code 扩展**

，以获得 MDC 语法的正确语法高亮。
::

### Vue 组件

你可以在 Markdown 文件中使用任意 Vue 组件。

我们有一种特殊语法，使在 Markdown 文件中使用组件更方便。

```mdc [content/index.md]
::component-name
默认插槽内容
::
```

::warning
Components that are used in Markdown have to be marked as 

`global`

 in your Nuxt app if you don't use the 

`components/content/`

 directory. 访问 

[Nuxt 3 文档](https://nuxt.com/docs/guide/directory-structure/components){rel=""nofollow""}

 了解更多。
::

#### 块级组件

块级组件是接受 Markdown 内容或其他组件作为插槽的组件。

组件必须至少包含一个 `<slot />` 组件来接收格式化文本。

在 markdown 文件中，使用 `::` 标识符调用组件。

::code-group
```mdc [index.md]
::card
卡片的内容
::
```

```html [Card.vue]
<!-- components/content/Card.vue -->
<template>
  <div class="p-2 border bg-white dark:bg-black dark:border-gray-700 rounded">
    <slot />
  </div>
</template>
```

  :::code-preview{icon="i-lucide-eye" label="预览"}
    ::::example-card
    卡片的内容
    ::::
  :::
::

#### 插槽

组件的插槽可以接受内容或其他组件。

- **默认插槽** 在块级组件内渲染顶级内容或通过 `#default`。
- **具名插槽** 使用 `#` 标识符来渲染对应内容。

::code-group
```mdc [index.md]
::hero
我的页面标题

#description
这部分将在 `description` 插槽内渲染。
::
```

```html [Hero.vue]
<template>
  <section>
    <h1 class="text-4xl">
      <slot mdc-unwrap="p" />
    </h1>
    <slot name="description" />
  </section>
</template>
```

  :::code-preview{icon="i-lucide-eye" label="预览"}
    ::::example-hero
    我的页面标题

    #description
    这部分将在 `description` 插槽内渲染。
    ::::
  :::
::

::note
阅读更多关于 

[`<slot />`](https://nuxt-content.zhcndoc.com/docs/components/slot)

 组件。
::

::tip
你可以在组件插槽内使用 Markdown：

  :::code-group
  ```mdc [index.md]
  ::my-title
  一个由组件 **渲染** 的 [富文本](/)。
  ::
  ```

  ```html [MyTitle.vue]
  <template>
    <h1 class="text-4xl">
      <slot mdc-unwrap="p" />
    </h1>
  </template>
  ```

    ::::code-preview{icon="i-lucide-eye" label="预览"}
      :::::example-title
      一个由组件 

      **渲染**

       的 

      [富文本](https://nuxt-content.zhcndoc.com)

      。
      :::::
    ::::
  :::
::

#### Props 属性

使用 MDC 传递 props 给组件，有两种方式。

##### **行内方式**

`{}` 标识符使用简洁的 `key=value` 语法向组件传递属性。

::code-group
```mdc [index.md]
::alert{type="warning"}
这是一个 **警告** 组件。
::
```

```vue [Alert.vue]
<script setup>
const props = defineProps({ type: { type: String } })

const alertClass = computed(() => {
  return {
    warning: 'bg-orange-100 border-orange-200 dark:bg-orange-900 dark:border-orange-800',
    info: 'bg-blue-100 border-blue-200 dark:bg-blue-900 dark:border-blue-800',
    success: 'bg-green-100 border-green-200 dark:bg-green-900 dark:border-green-800',
  }[props.type]
})
</script>

<template>
  <div
    class="text-black p-2 border dark:text-white rounded"
    :class="alertClass"
  >
    <slot mdc-unwrap="p" />
  </div>
</template>
```

  :::code-preview{icon="i-lucide-eye" label="预览"}
    ::::example-alert{type="warning"}
    这是一个 

    **警告**

     组件。
    ::::
  :::
::

多个属性用空格分隔：

```mdc
::alert{type="warning" icon="exclamation-circle"}
出错了！
::
```

`v-bind` 简写 `:` 也可用来绑定 frontmatter 中的属性值：

```mdc
---
type: "warning"
---

::alert{:type="type"}
你的警告
::
```

如果要传递数组或对象作为属性给组件，可以将它们作为 JSON 字符串，属性键名前加冒号以自动解码 JSON 字符串。注意，这种情况下应使用单引号包裹字符串值，以便使用双引号传递有效的 JSON 字符串：

::code-group
```mdc [array.md]
::dropdown{:items='["Nuxt", "Vue", "React"]'}
::
```

```mdc [number-array.md]
::dropdown{:items='[1,2,3.5]'}
::
```

```mdc [object.md]
::chart{:options='{"responsive": true, "scales": {"y": {"beginAtZero": true}}}'}
::
```
::

##### **YAML 方式**

YAML 方式用 `---` 标识符声明逐行一个 prop，便于可读性。

::code-group
```mdc [index.md]
::icon-card
---
icon: IconNuxt
description: 发挥 Nuxt 及其生态系统的全部力量。
title: Nuxt 架构。
---
::
```

```html [IconCard.vue]
<script setup>
defineProps({
  title: {
    type: String,
    default: '默认标题'
  },
  description: {
    type: String,
    default: '默认描述'
  },
  icon: {
    type: String,
    default: 'IconMarkdown'
  }
})
</script>

<template>
  <div class="p-6 border bg-white dark:bg-black dark:border-gray-700 rounded">
    <component :is="icon" class="w-20 h-20" />
    <h2 class="text-3xl font-semibold mb-2">
      {{ title }}
    </h2>
    <p>{{ description }}</p>
  </div>
</template>
```

  :::code-preview{icon="i-lucide-eye" label="预览"}
  :example-icon-card{description="发挥 Nuxt 及其生态系统的全部力量。" icon="i-simple-icons-nuxtdotjs" title="Nuxt 架构。"}
  :::
::

### 属性 (Attributes)

属性对于高亮和修改段落部分内容很有用。语法与行内组件和 Markdown 链接语法非常相似。

可能的值包括所有命名属性、以 `.class-name` 形式的类名，以及以 `#id-name` 形式的 ID。

::code-group
```mdc [index.md]
Hello [World]{style="color: green;" .custom-class #custom-id}!
```

  :::code-preview{icon="i-lucide-eye" label="预览"}
  Hello [World]{#custom-id .custom-class style="color: green;"} !
  :::
::

除了 mdc 组件和 `span`，属性语法还适用于图像、链接、内联 `code`、\**粗体*\* 和 \_斜体\_ 文本。

::code-group
```md [index.md]
属性适用于：

- [链接](#attributes){style="background-color: green;"}, `代码`{style="color: cyan;"},
- _斜体_{style="background-color: yellow; color:black;"} 和 **加粗**{style="background-color: lightgreen;"} 文本。
```

  :::code-preview{prose label="预览" prose=""}
  属性适用于：

  - [链接](https://nuxt-content.zhcndoc.com/#attributes){style="background-color: green;"}, `代码`,
  - *斜体* 和 **加粗** 文本。
  :::
::

### 绑定数据

你可以使用 `{{ $doc.variable || 'defaultValue' }}` 语法在 Markdown 文档中绑定数据。这些值可以在文档顶部的 YAML frontmatter 中定义，在每个 MDC 组件内定义，或通过 `<ContentRenderer>` 组件的 `data` 属性注入。

#### 在 YAML 中定义

```mdc
---
title: '页面标题'
description: '页面元描述'
customVariable: '自定义值'
---

# 标题是 {{ $doc.title }} ，customVariable 是 {{ $doc.customVariable || 'defaultValue' }}

```

#### 在外部定义 `<ContentRenderer>`

```html [test.vue]
<template>
  <div>
    <ContentRenderer :value="data" :data="mdcVars"/>
    <button type="button" v-on:click="mdcVars.name = 'Hugo'">更改名称</button>
  </div>
</template>

<script setup lang="ts">
const { data } = await useAsyncData(() => queryCollection('content').path('/test').first());
const mdcVars = ref({ name: 'Maxime'});
</script>
```

```mdc [test.md]
# 你好 {{ $doc.name || '世界' }}

```

## Prose 组件

在 Nuxt Content 中，prose 表示由 Markdown 语法生成的 HTML 标签，如标题和链接。

每个 HTML 标签对应一个 Vue 组件，你可以根据需求覆盖它们，例如 `<p>` 对应 `<ProseP>`。

如果想定制 Prose 组件，建议的步骤如下：

- 查看原始的 [组件源码](https://github.com/nuxt-modules/mdc/blob/main/src/runtime/components/prose){rel="&#x22;nofollow&#x22;"}。
- 使用完全相同的 props。
- 在你的 `components/content/` 目录下，命名相同文件。
- 根据需要定制 🚀。

::note{to="https://nuxt-content.zhcndoc.com/docs/components/prose"}
请阅读 Prose 组件章节，获取完整的 Prose 参考。
::

## 代码高亮

Nuxt Content 使用 [Shiki](https://github.com/shikijs/shiki){rel="&#x22;nofollow&#x22;"} 实现代码高亮，主题与 VSCode 一致。

代码高亮同时适用于 [`ProsePre`](https://nuxt-content.zhcndoc.com/docs/components/prose#prosepre) 和 [`ProseCode`](https://nuxt-content.zhcndoc.com/docs/components/prose#prosecodeinline)。

代码块的每一行数字存储在 `line` 属性中，便于单行标注与样式定制。

::callout
[阅读 API 参考，了解如何配置或完全禁用语法高亮。](https://nuxt-content.zhcndoc.com/docs/getting-started/configuration)
::

## 图片

你可以将图片添加到你的 `public` 目录：

```bash [目录结构]
content/
  index.md
public/
  image.png
nuxt.config.ts
package.json
```

然后在 `content` 目录的 markdown 文件中这样使用：

```md [content/index.md]
![我的图片](/image.png)
```

## 摘要

内容摘要或概要可以通过使用 `<!--more-->` 作为分隔符从内容中提取。

```md [content/index.md]
---
title: 介绍
---

学习如何使用 `@nuxt/content`。

<!--more-->

更多分割线后的完整内容。
```

描述字段 (description) 会包含摘要内容，除非 frontmatter 中已定义。

如果文本中没有 `<!--more-->` 分隔符，则摘要字段为未定义。

::tip
如果想使用摘要功能，应在集合 schema 中定义 `excerpt` 字段。

```ts [content.config.ts]
const content = defineCollection({
  type: 'page',
  source: '**',
  schema: z.object({
    excerpt: z.object({
      type: z.string(),
      children: z.any(),
    }),
  }),
})
```

阅读关于 [集合 schema](https://nuxt-content.zhcndoc.com/docs/collections/define#collection-schema) 的更多内容。
::

示例变量会注入到文档中：

```json
{
  "excerpt": Object,
  "body": Object,
  // ... 其他键
}
```


# YAML

## 定义集合

```ts [content.config.ts]
import { defineCollection, defineContentConfig } from '@nuxt/content'
import { z } from 'zod'

export default defineContentConfig({
  collections: {
    authors: defineCollection({
      type: 'data',
      source: 'authors/**.yml',
      schema: z.object({
        name: z.string(),
        avatar: z.string(),
        url: z.string()
      })
    })
  }
})

```

## 创建 `.yml` 文件

在 `content/authors/` 目录下创建作者文件。

::code-group
```yaml [farnabaz.yml]
name: Ahad Birang
avatar: https://avatars.githubusercontent.com/u/2047945?v=4
url: https://github.com/farnabaz
```

```yaml [larbish.yml]
name: Baptiste Leproux
avatar: https://avatars.githubusercontent.com/u/7290030?v=4
url: https://github.com/larbish
```
::

## 查询数据

现在我们可以查询作者数据了：

```vue
<script lang="ts" setup>
// 查找单个作者
const { data: author } = await useAsyncData('larbish', () => {
  return queryCollection('authors')
    .where('stem', '=', 'larbish')
    .first()
})

// 获取所有作者
const { data: authors } = await useAsyncData('authors', () => {
  return queryCollection('authors')
    .order('name', 'DESC')
    .all()
})
</script>
```


# JSON

## 定义集合

```ts [content.config.ts]
import { defineCollection, defineContentConfig } from '@nuxt/content'
import { z } from 'zod'

export default defineContentConfig({
  collections: {
    authors: defineCollection({
      type: 'data',
      source: 'authors/**.json',
      schema: z.object({
        name: z.string(),
        avatar: z.string(),
        url: z.string()
      })
    })
  }
})

```

## 创建 `.json` 文件

在 `content/authors/` 目录下创建作者文件。

::code-group
```json [farnabaz.json]
{
  "name": "Ahad Birang",
  "avatar": "https://avatars.githubusercontent.com/u/2047945?v=4",
  "url": "https://github.com/farnabaz"
}
```

```json [larbish.json]
{
  "name": "Baptiste Leproux",
  "avatar": "https://avatars.githubusercontent.com/u/7290030?v=4",
  "url": "https://github.com/larbish"
}
```
::

::warning
`data`

 集合中的每个文件应仅包含一个对象，因此在 JSON 文件中使用顶层数组会导致查询时结果无效。
::

## 查询数据

现在我们可以查询作者：

```vue
<script lang="ts" setup>
// 查找单个作者
const { data: author } = await useAsyncData('larbish', () => {
  return queryCollection('authors')
    .where('stem', '=', 'larbish')
    .first()
})

// 获取所有作者
const { data: authors } = await useAsyncData('authors', () => {
  return queryCollection('authors')
    .order('name', 'DESC')
    .all()
})
</script>
```


# CSV

## 单文件源

当你将集合指向单个 CSV 文件（而不是通配符）时，Nuxt Content **将每一数据行作为集合中的一个独立项目处理**。

- **定义集合**：将 `source` 设置为单个 `.csv` 文件的路径。
- **项目生成**：每一数据行成为一个项目，行字段位于顶层（没有 `body` 数组）。
- **ID**：项目的 ID 后缀为 `#<rowNumber>`，其中 `#1` 是表头之后的第一行数据。

```ts [content.config.ts]
import { defineCollection, defineContentConfig } from '@nuxt/content'
import { z } from 'zod'

export default defineContentConfig({
  collections: {
    people: defineCollection({
      type: 'data',
      source: 'org/people.csv',
      schema: z.object({
        name: z.string(),
        email: z.string().email()
      })
    })
  }
})
```

```csv [content/org/people.csv]
name,email
Alice,alice@example.com
Bob,bob@example.com
```

每一行都会生成一个独立项目。例如，第一行数据项目 ID 以 `#1` 结尾，第二行以 `#2` 结尾。你可以按任意列查询：

```ts
const { data: alice } = await useAsyncData('alice', () =>
  queryCollection('people')
    .where('email', '=', 'alice@example.com')
    .first()
)

const { data: allPeople } = await useAsyncData('all-people', () =>
  queryCollection('people')
    .order('name', 'ASC')
    .all()
)
```

::note
- 表头行为必需，不会转换为项目。
- 单文件源中，项目字段位于顶层（无 `body`）。
- 若想将每个 CSV 文件视作单个项目，且所有行在 `body` 中，请使用通配符路径如 `org/**.csv`。
  \:::

## 多文件源

如果你在配置中使用类似 `*/**.csv`，Nuxt Content 会有不同处理： :br**每个文件（非每行）将视为一个项目**，各行数据解析为项目对象中 `body` 字段的数组。

```ts [content.config.ts]
import { defineCollection, defineContentConfig } from '@nuxt/content'
import { z } from 'zod'

export default defineContentConfig({
  collections: {
    charts: defineCollection({
      type: 'data',
      source: 'charts/**.csv',
      schema: z.object({
        // CSV 文件中 body 字段非常重要，无此字段无法访问数据数组
        body: z.array(z.object({
          label: z.string(),
          value: z.number()
        }))
      })
    })
  }
})

```

创建图表文件于 `content/charts/` 目录。

  :::code-group
  ```csv [content/charts/chart1.csv]
  label,value
  A,100
  B,200
  C,300
  ```

  ```csv [content/charts/chart2.csv]
  label,value
  Foo,123
  Bar,456
  Baz,789
  ```
  :::

  :::warning
  每个 CSV 文件应含有定义列名的表头行，解析时用作对象键名。
  :::

现在我们可以查询图表数据了：

```vue
<script lang="ts" setup>
// 查询单个图表
const { data: chart1 } = await useAsyncData('chart1', () => {
  return queryCollection('charts')
    .where('id', '=', 'charts/charts/chart1.csv')
    .first()
})

// 获取所有图表
const { data: charts } = await useAsyncData('charts', () => {
  return queryCollection('charts')
    .order('id', 'ASC')
    .all()
})
</script>

<template>
  <ul>
    <li v-for="chart in charts" :key="chart.id">
      <!-- CSV 数据位于 chart.body 数组中 -->
      <p v-for="data in chart.body" :key="data.label">
        {{ data.label }} - {{ data.value }}
      </p>
    </li>
  </ul>
</template>
```

## 配置

你可以在 `nuxt.config.ts` 中配置 CSV 文件的解析方式：

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  content: {
    build: {
      csv: {
        // 将 CSV 数据转换为 JSON 对象
        json: true,
        // 指定分隔符（默认为 ','）
        delimiter: ','
      }
    }
  }
})
```

启用 `json: true` 后，每行会转成一个 JavaScript 对象，表头作为键名：

```json
[
  {
    "id": "1",
    "name": "John Doe",
    "email": "john@example.com"
  },
  {
    "id": "2",
    "name": "Jane Smith",
    "email": "jane@example.com"
  }
]
```

## 自定义分隔符

如果你的 CSV 使用不同分隔符，可在配置中指定：

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  content: {
    build: {
      csv: {
        delimiter: ';' // 使用分号作为分隔符
      }
    }
  }
})
```

这样会解析如下格式的 CSV 文件：

```csv [semicolon-data.csv]
id;name;email
1;John Doe;john@example.com
2;Jane Smith;jane@example.com
```

  :::note
  如果不需要 CSV 支持，可通过设置 

  `csv: false`

   禁用 CSV 解析器。
  :::
::


# queryCollection

## 用法

使用自动导入的 `queryCollection` 来查找集合中的内容。这里假设你已在 `content.config.ts` 中定义了 `docs` 集合。

如果你还未定义任何集合，请查看 [如何定义集合](https://nuxt-content.zhcndoc.com/docs/collections/define#defining-collections)。

```vue [pages/[...slug.vue]
<script setup>
const route = useRoute()
const { data: page } = await useAsyncData(route.path, () => {
  return queryCollection('docs').path(route.path).first()
})
</script>
```

::tip
`queryCollection`

 工具可在 Vue 和 Nitro 中使用。更多关于如何在服务器端使用的信息，请查看 

[服务器端用法](https://nuxt-content.zhcndoc.com/#server-usage)

。
::

## API

### 类型

```ts
function queryCollection<T extends keyof Collections>(collection: T): CollectionQueryBuilder<Collections[T]>

interface CollectionQueryBuilder<T> {
  where(field: keyof T | string, operator: SQLOperator, value?: unknown): CollectionQueryBuilder<T>
  andWhere(groupFactory: QueryGroupFunction<T>): CollectionQueryBuilder<T>
  orWhere(groupFactory: QueryGroupFunction<T>): CollectionQueryBuilder<T>
  order(field: keyof T, direction: 'ASC' | 'DESC'): CollectionQueryBuilder<T>
  // ... 其他方法
}
```

### `queryCollection(collection: CollectionName)`

创建用于查询指定集合的查询构建器。

- 参数：
  - `collection`：在 `content.config.ts` 中定义集合的键名。

### `path(path: string)`

搜索具有特定 `path` 的内容。（`path` 是 `page` 集合中的特殊字段，基于文件系统路径生成，可作为渲染内容的路由）

- 参数：
  - `path`：匹配的路径字符串。

```ts
const route = useRoute()
const { data } = await useAsyncData(route.path, () => {
  return queryCollection('docs').path(route.path).first()
})
```

### `select(...fields: keyof Collection)`

从集合中选择特定字段返回查询结果。

- 参数：
  - `...fields`：要从集合中选择的字段名称列表。

```ts
const route = useRoute()
const { data } = await useAsyncData(route.path, () => {
  return queryCollection('docs')
    .select('path', 'title', 'description')
    .first()
})
```

### `where(field: keyof Collection | string, operator: SqlOperator, value?: unknown)`

向查询添加条件，根据特定字段筛选结果。

- 参数：
  - `field`：要筛选的字段。
  - `operator`：用于比较的 SQL 运算符。可能的值包括：
    - `'='`：等于
    - `'>'`：大于
    - `'<'`：小于
    - `'<>'`：不等于
    - `'IN'`：在列表中
    - `'BETWEEN'`：在两个值之间
    - `'NOT BETWEEN'`：不在两个值之间
    - `'IS NULL'`：为 NULL
    - `'IS NOT NULL'`：不为 NULL
    - `'LIKE'`：匹配模式
    - `'NOT LIKE'`：不匹配模式
  - `value`：用于比较的值。类型依所用运算符不同而不同。

```ts
const route = useRoute()
const { data } = await useAsyncData(route.path, () => {
  return queryCollection('docs')
    .where('date', '<', '2024-04-04')
    .where('category', '=', 'news')
    .all()
})

// Generated SQL
// SELECT * FROM docs WHERE date < '2024-04-04' AND category = 'news'
```

### `andWhere(groupFactory: QueryGroupFunction<Collection>)`

向查询添加一个 AND 条件组，允许构建更复杂的查询条件。

- 参数：
  - `groupFactory`：一个接收查询构建器的函数，可添加多个条件，这些条件将用 AND 连接组合在一起。

```ts
const { data } = await useAsyncData('recent-docs', () => {
  return queryCollection('docs')
    .where('published', '=', true)
    .andWhere(query => query.where('date', '>', '2024-01-01').where('category', '=', 'news'))
    .all()
})

// Generated SQL
// SELECT * FROM docs WHERE published = true AND (date > '2024-01-01' AND category = 'news')
```

### `orWhere(groupFactory: QueryGroupFunction<Collection>)`

向查询添加一个 OR 条件组，允许构建替代的条件。

- 参数：
  - `groupFactory`：一个接收查询构建器的函数，可添加多个条件，这些条件用 OR 连接组合在一起。

```ts
const { data } = await useAsyncData('featured-docs', () => {
  return queryCollection('docs')
    .where('published', '=', true)
    .orWhere(query => query.where('featured', '=', true).where('priority', '>', 5))
    .all()
})

// Generated SQL
// SELECT * FROM docs WHERE published = true AND (featured = true OR priority > 5)
```

### `order(field: keyof Collection, direction: 'ASC' | 'DESC')`

根据特定字段对查询结果进行排序。

- 参数：
  - `field`：排序字段。
  - `direction`：排序方向，'ASC' 表示升序，'DESC' 表示降序。

```ts
const route = useRoute()
const { data } = await useAsyncData(route.path, () => {
  return queryCollection('docs')
    .order('date', 'DESC')
    .all()
})
```

### `limit(limit: number)`

限制查询返回结果的数量。

- 参数：
  - `limit`：返回结果的最大数量。

```ts
const route = useRoute()
const { data } = await useAsyncData(route.path, () => {
  return queryCollection('docs')
    .limit(10)
    .all()
})
```

### `skip(skip: number)`

查询时跳过指定数量的结果。

- 参数：
  - `skip`：跳过的结果数量。

```ts
const route = useRoute()
const { data } = await useAsyncData(route.path, () => {
  return queryCollection('docs')
    // 跳过前 5 条
    .skip(5)
    .all()
})
```

### `all()`

执行查询并返回所有匹配结果。

- 返回值：返回一个 Promise，解析为所有匹配的文档数组。

```ts
const route = useRoute()
const { data } = await useAsyncData(route.path, () => {
  return queryCollection('docs').all()
})
```

### `first()`

执行查询并返回第一个匹配结果。

- 返回值：返回一个 Promise，解析为第一个匹配的文档，若无匹配则为 `null`。

```ts
const route = useRoute()
const { data } = await useAsyncData(route.path, () => {
  return queryCollection('docs').first()
})
```

### `count()`

统计基于查询条件匹配的集合条目数量。

```ts
const route = useRoute()
const { data } = await useAsyncData(route.path, () => {
  return queryCollection('docs')
    // 计数匹配条目
    .count()
})

// 返回
5 // 匹配数量
```

你也可以将 `count()` 与上述其他方法（如 `where()`）结合使用，以对集合查询应用更多条件。

```ts
const route = useRoute()
const { data } = await useAsyncData(route.path, () => {
  return queryCollection('docs')
    .where('date', '<', '2024-04-04')
    // 计数匹配条目
    .count()
})

// 返回
3 // 满足条件的匹配数量
```

## 示例

下面是一个完整示例，展示如何获取 `docs` 集合中的文档列表。

```vue [index.vue]
<script setup lang="ts">
const { data: docs } = await useAsyncData('documents-list', () => {
  return queryCollection('docs')
    .order('date', 'DESC')
    .select('title', 'path', 'description')
    .all()
})
</script>

<template>
  <NuxtLink v-for="doc in docs" :key="doc.path" :to="doc.path">
    <h2>{{ doc.title }}</h2>
    <p>{{ doc.description }}</p>
  </NuxtLink>
</template>
```

## 服务器端用法

Nuxt Content 提供了类似的工具用于在服务器端查询集合。唯一区别是你需要将 `event` 作为第一个参数传给 `queryCollection` 函数。

```ts [server/api/[slug\\].ts]
export default eventHandler(async (event) => {
  const { slug } = getRouterParams(event)
  const page = await queryCollection(event, 'docs').path(slug).first()
  return page
})
```

::note
确保创建 `server/tsconfig.json` 文件，并包含以下内容以避免类型错误：

```json
{
  "extends": "../.nuxt/tsconfig.server.json"
}
```
::


# queryCollectionNavigation

## 类型

```ts
function queryCollectionNavigation<T extends keyof PageCollections>(
  collection: T,
  fields?: Array<keyof PageCollections[T]>
): ChainablePromise<T, ContentNavigationItem[]>

interface ChainablePromise<T extends keyof PageCollections, R> extends Promise<R> {
  where(field: keyof PageCollections[T] | string, operator: SQLOperator, value?: unknown): ChainablePromise<T, R>
  andWhere(groupFactory: QueryGroupFunction<PageCollections[T]>): ChainablePromise<T, R>
  orWhere(groupFactory: QueryGroupFunction<PageCollections[T]>): ChainablePromise<T, R>
  order(field: keyof PageCollections[T], direction: 'ASC' | 'DESC'): ChainablePromise<T, R>
}
```

## 用法

使用自动导入的 `queryCollectionNavigation` 为特定集合生成导航树。这对于基于你的内容结构创建动态导航菜单或侧边栏非常有用。

该函数返回一个可链式调用的 Promise，允许你添加额外的查询条件：

```vue [pages/[...slug\\].vue]
<script setup lang="ts">
const { data } = await useAsyncData('navigation', () => {
  return queryCollectionNavigation('docs')
    .where('published', '=', true)
    .order('date', 'DESC')
})
</script>
```

::tip
`queryCollectionNavigation`

 工具同时适用于 Vue 和 Nitro。详细了解在服务器端如何使用，请参阅 

[服务器端使用](https://nuxt-content.zhcndoc.com/#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E4%BD%BF%E7%94%A8)

。
::

### 使用 `.navigation.yml` 添加导航元数据

你可以通过 `.navigation.yml` 文件为目录添加元数据。

```yml [.navigation.yml]
title: 入门指南
icon: i-lucide-square-play
```

## Type

```ts
function queryCollectionNavigation<T extends keyof PageCollections>(
  collection: T,
  fields?: Array<keyof PageCollections[T]>
): ChainablePromise<T, ContentNavigationItem[]>

interface ChainablePromise<T extends keyof PageCollections, R> extends Promise<R> {
  where(field: keyof PageCollections[T] | string, operator: SQLOperator, value?: unknown): ChainablePromise<T, R>
  andWhere(groupFactory: QueryGroupFunction<PageCollections[T]>): ChainablePromise<T, R>
  orWhere(groupFactory: QueryGroupFunction<PageCollections[T]>): ChainablePromise<T, R>
  order(field: keyof PageCollections[T], direction: 'ASC' | 'DESC'): ChainablePromise<T, R>
}
```

## API

### `queryCollectionNavigation(collection: CollectionName, extraField: keyof Collection)`

为指定集合生成导航树。

- 参数：
  - `collection`：在 `content.config.ts` 中定义集合的键名。
  - `extraFields`：（可选）一个数组，包含要在导航项中额外包含的字段。（默认导航项中包含 `title` 和 `path`。）
- 返回值：一个可链式调用的 Promise，解析为导航树结构。该 Promise 支持添加查询条件的方法：
  - `where(field, operator, value)`：添加 WHERE 条件
  - `andWhere(groupFactory)`：添加分组的 AND 条件
  - `orWhere(groupFactory)`：添加分组的 OR 条件
  - `order(field, direction)`：添加 ORDER BY 子句

导航树基于目录结构生成，排序基于文件的[排序规则](https://nuxt-content.zhcndoc.com/docs/collections/types#ordering-files)

## 示例

基础用法，无需额外查询条件：

```vue [pages/[...slug\\].vue]
<script setup lang="ts">
const { data } = await useAsyncData('navigation', () => {
  return queryCollectionNavigation('docs')
})
</script>

<template>
  <nav>
    <ul v-if="data">
      <li v-for="item in data" :key="item.path">
        <NuxtLink :to="item.path">{{ item.title }}</NuxtLink>
      </li>
    </ul>
  </nav>
</template>
```

带额外查询条件和额外字段的示例：

```vue [pages/[...slug\\].vue]
<script setup lang="ts">
const { data } = await useAsyncData('navigation', () => {
  return queryCollectionNavigation('docs', ['description', 'badge'])
    .where('draft', '=', false)
    .where('partial', '=', false)
    .order('title', 'ASC')
})
</script>

<template>
  <nav>
    <ul v-if="data">
      <li v-for="item in data" :key="item.path">
        <NuxtLink :to="item.path">
          {{ item.title }}
          <span v-if="item.badge" class="badge">{{ item.badge }}</span>
        </NuxtLink>
        <p v-if="item.description">{{ item.description }}</p>
      </li>
    </ul>
  </nav>
</template>
```

## 服务器端使用

Nuxt Content 在服务器端提供了类似的查询集合工具。唯一不同的是你需要把 `event` 作为第一个参数传递给 `queryCollectionNavigation` 函数。

```ts [server/api/navigation.ts]
export default eventHandler(async (event) => {
  const navigation = await queryCollectionNavigation(event, 'docs')
  return navigation
})
```

::note
请确保创建 `server/tsconfig.json` 文件，内容如下，以避免类型错误。

```json
{
  "extends": "../.nuxt/tsconfig.server.json"
}
```
::

---

## 与导航相关的额外工具

Content 模块提供了一些额外的工具，以简化构建面包屑导航等常见用例。

### `findPageHeadline(navigation, path, options?)`

返回导航树中给定路径的标题（父文件夹的名称）。对于显示章节标题或上下文导航标题非常有用。

- `navigation`: 导航树（ContentNavigationItem 数组）。
- `path`: 当前页面路径。
- `options`（可选）：
  - `indexAsChild`: 是否把索引页视为子节点。

**示例：**

```ts
import { findPageHeadline } from '@nuxt/content/utils'

const headline = findPageHeadline(navigation, '/docs/guide/getting-started')
// 标题是一个包含父文件夹名称的字符串。
```

### `findPageBreadcrumb(navigation, path, options?)`

返回给定路径在导航树中的面包屑路径（导航项数组）。适合用于构建面包屑导航组件。

- `navigation`：导航树（ContentNavigationItem 数组）。
- `path`：当前页面路径。
- `options`（可选）：
  - `current`：是否包含当前页面。
  - `indexAsChild`：是否把索引页视为子节点。

**示例：**

```ts
import { findPageBreadcrumb } from '@nuxt/content/utils'

const breadcrumb = findPageBreadcrumb(navigation, '/docs/guide/getting-started')
// breadcrumb 是通向当前页面的导航项数组
```

### `findPageChildren(navigation, path, options?)`

查找并返回导航树中给定路径的直接子项。

- `navigation`：导航树（ContentNavigationItem 数组）。
- `path`：要查找子项的父路径。
- `options`（可选）：
  - `indexAsChild`：是否把索引页视为子节点。

**示例：**

```ts
import { findPageChildren } from '@nuxt/content/utils'

const children = findPageChildren(navigation, '/docs/guide')
// children 是 '/docs/guide' 下的导航项数组
```

### `findPageSiblings(navigation, path, options?)`

返回给定路径的兄弟导航项（即具有相同父级的其他项）。

- `navigation`：导航树（ContentNavigationItem 数组）。
- `path`：当前页面路径。
- `options`（可选）：
  - `indexAsChild`：是否把索引页视为子节点。

**示例：**

```ts
import { findPageSiblings } from '@nuxt/content/utils'

const siblings = findPageSiblings(navigation, '/docs/guide/getting-started')
// siblings 是与当前页面具有相同父级的导航项数组
```


# queryCollectionItemSurroundings

## 类型

```ts
function queryCollectionItemSurroundings<T extends keyof PageCollections>(
  collection: T,
  path: string,
  opts?: SurroundOptions<keyof PageCollections[T]>
): ChainablePromise<T, ContentNavigationItem[]>

interface ChainablePromise<T extends keyof PageCollections, R> extends Promise<R> {
  where(field: keyof PageCollections[T] | string, operator: SQLOperator, value?: unknown): ChainablePromise<T, R>
  andWhere(groupFactory: QueryGroupFunction<PageCollections[T]>): ChainablePromise<T, R>
  orWhere(groupFactory: QueryGroupFunction<PageCollections[T]>): ChainablePromise<T, R>
  order(field: keyof PageCollections[T], direction: 'ASC' | 'DESC'): ChainablePromise<T, R>
}
```

## 用法

使用自动导入的 `queryCollectionItemSurroundings` 可以查找集合中特定内容项的前后兄弟项目。这对于创建相关内容页面间的导航非常有用。

该函数返回一个可链式调用的 Promise，允许你添加额外的查询条件：

```vue [pages/[...slug\\].vue]
<script setup lang="ts">
const { data } = await useAsyncData('surround', () => {
  return queryCollectionItemSurroundings('docs', '/foo')
    .where('published', '=', true)
    .order('date', 'DESC')
})
</script>
```

::tip
`queryCollectionItemSurroundings`

 工具可以在 Vue 和 Nitro 中使用。详情请查看 

[服务器端使用](https://nuxt-content.zhcndoc.com/#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E4%BD%BF%E7%94%A8)

 章节，了解如何在服务器端使用。
::

## Type

```ts
function queryCollectionItemSurroundings<T extends keyof PageCollections>(
  collection: T,
  path: string,
  opts?: SurroundOptions<keyof PageCollections[T]>
): ChainablePromise<T, ContentNavigationItem[]>

interface ChainablePromise<T extends keyof PageCollections, R> extends Promise<R> {
  where(field: keyof PageCollections[T] | string, operator: SQLOperator, value?: unknown): ChainablePromise<T, R>
  andWhere(groupFactory: QueryGroupFunction<PageCollections[T]>): ChainablePromise<T, R>
  orWhere(groupFactory: QueryGroupFunction<PageCollections[T]>): ChainablePromise<T, R>
  order(field: keyof PageCollections[T], direction: 'ASC' | 'DESC'): ChainablePromise<T, R>
}
```

## API

### `queryCollectionItemSurroundings(collection: CollectionName, path: string, opts?: SurroundOptions)`

查找集合中特定内容项的相邻项（前一项和后一项）。

- 参数：
  - `collection`：在 `content.config.ts` 中定义的集合的键名。
  - `path`：当前内容项的路径。
  - `opts`：（可选）包含以下属性的对象：
    - `before`：（可选）当前项之前要获取的项目数，默认值为 1。
    - `after`：（可选）当前项之后要获取的项目数，默认值为 1。
    - `fields`：（可选）附加要包含在相邻项中的字段数组。
- 返回值：一个可链式调用的 Promise，解析为包含相邻项目的数组。该 Promise 包含用于添加查询条件的方法：
  - `where(field, operator, value)`：添加 WHERE 条件
  - `andWhere(groupFactory)`：添加分组的 AND 条件
  - `orWhere(groupFactory)`：添加分组的 OR 条件
  - `order(field, direction)`：添加 ORDER BY 子句

最终结果将是一个数组，结构如下：

- 使用默认选项时为 `[previousItem, nextItem]`
- 使用自定义 `before` 和 `after` 值时为 `[...previousItems, ...nextItems]`

数组中的每个项均为 `ContentNavigationItem` 类型，若该位置无项目则为 `null`。

## 示例

基础用法，无额外查询条件：

```vue [pages/[...slug\\].vue]
<script setup lang="ts">
const { data } = await useAsyncData('surround', () => {
  return queryCollectionItemSurroundings('docs', '/foo')
})
</script>

<template>
  <div class="flex justify-between">
    <NuxtLink v-if="data?.[0]" :to="data[0].path">
      ← {{ data[0].title }}
    </NuxtLink>
    <NuxtLink v-if="data?.[1]" :to="data[1].path">
      {{ data[1].title }} →
    </NuxtLink>
  </div>
</template>
```

带有额外查询条件的示例：

```vue [pages/[...slug\\].vue]
<script setup lang="ts">
const { data } = await useAsyncData('surround', () => {
  return queryCollectionItemSurroundings('docs', '/foo', {
    before: 1,
    after: 1,
    fields: ['badge', 'description']
  })
    .where('_draft', '=', false)
    .where('_partial', '=', false)
    .order('date', 'DESC')
})
</script>
```

## 服务器端使用

Nuxt Content 提供了类似的工具用于服务器端查询集合。唯一不同的是你需要将 `event` 作为第一个参数传递给 `queryCollectionItemSurroundings` 函数。

```ts [server/api/surroundings.ts]
export default eventHandler(async (event) => {
  const surroundings = await queryCollectionItemSurroundings(event, 'docs', '/foo')
  return surroundings
})
```

::note
请确保创建 `server/tsconfig.json` 文件，内容如下，以避免类型错误。

```json
{
  "extends": "../.nuxt/tsconfig.server.json"
}
```
::


# queryCollectionSearchSections

## 类型

```ts
function queryCollectionSearchSections(collection: keyof Collections, opts?: { ignoredTags: string[] }): ChainablePromise<T, Section[]>

interface ChainablePromise<T extends keyof PageCollections, R> extends Promise<R> {
  where(field: keyof PageCollections[T] | string, operator: SQLOperator, value?: unknown): ChainablePromise<T, R>
  andWhere(groupFactory: QueryGroupFunction<PageCollections[T]>): ChainablePromise<T, R>
  orWhere(groupFactory: QueryGroupFunction<PageCollections[T]>): ChainablePromise<T, R>
  order(field: keyof PageCollections[T], direction: 'ASC' | 'DESC'): ChainablePromise<T, R>
}
```

## 使用方法

使用自动导入的 `queryCollectionSearchSections` 函数从指定集合生成可搜索的区块。这对于在应用中创建高级搜索功能或内容发现功能非常有用。

```vue [app.vue]
<script>
const { data: sections } = await useAsyncData('search-sections', () => {
  return queryCollectionSearchSections('docs')
})
</script>
```

::tip
`queryCollectionSearchSections`

 工具同时支持 Vue 和 Nitro。更多关于如何在服务器端使用的详细信息，请查看 

[Server Usage](https://nuxt-content.zhcndoc.com/#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E4%BD%BF%E7%94%A8)

。
::

## Type

```ts
function queryCollectionSearchSections(collection: keyof Collections, opts?: { ignoredTags?: string[], minHeading?: string, maxHeading?: string }): ChainablePromise<T, Section[]>

interface ChainablePromise<T extends keyof PageCollections, R> extends Promise<R> {
  where(field: keyof PageCollections[T] | string, operator: SQLOperator, value?: unknown): ChainablePromise<T, R>
  andWhere(groupFactory: QueryGroupFunction<PageCollections[T]>): ChainablePromise<T, R>
  orWhere(groupFactory: QueryGroupFunction<PageCollections[T]>): ChainablePromise<T, R>
  order(field: keyof PageCollections[T], direction: 'ASC' | 'DESC'): ChainablePromise<T, R>
}
```

## API

### `queryCollectionSearchSections(collection: CollectionName, options?: SearchSectionsOptions)`

从指定集合生成可搜索的区块。

- 参数：
  - `collection`：在 `content.config.ts` 中定义的集合键名。
  - `options`：（可选）一个包含以下属性的对象：
    - `ignoredTags`：一个要在生成区块时忽略的标签名称数组。默认是空数组。
    - `minHeading`：分割区块的最小标题级别（例如：`'h2'`），默认是 `'h1'`。
    - `maxHeading`：分割区块的最大标题级别（例如：`'h3'`），默认是 `'h6'`。
- 返回值：返回一个 Promise，解析为包含可搜索区块的数组。每个区块是一个对象，包含以下属性：
  - `id`：区块的唯一标识符。
  - `title`：区块标题（通常是标题文本）。
  - `titles`：父级区块标题组成的数组，表示层级结构。
  - `content`：区块的文本内容。
  - `level`：区块的标题层级（1-6），1 表示最高层级。

## 示例

下面示例演示如何使用 `queryCollectionSearchSections` 从 'docs' 集合创建可搜索的区块：

```vue [pages/[...slug\\].vue]
<script>
const { data: surround } = await useAsyncData('foo-surround', () => {
  return queryCollectionSearchSections('docs', {
    ignoredTags: ['code'],
    minHeading: 'h2',
    maxHeading: 'h3',
  })
})
</script>
```

## 服务器端使用

Nuxt Content 提供了类似的工具来在服务器端查询集合。唯一的区别是你需要将 `event` 作为 `queryCollectionSearchSections` 函数的第一个参数传入。

```ts [server/api/search-sections.ts]
export default eventHandler(async (event) => {
  const sections = await queryCollectionSearchSections(event, 'docs')
  return sections
})
```

::note
请确保创建 `server/tsconfig.json` 文件，并填写以下内容以避免类型错误。

```json
{
  "extends": "../.nuxt/tsconfig.server.json"
}
```
::


# 内容渲染器

`<ContentRenderer>` 组件用于渲染通过 [`queryCollection()`](https://nuxt-content.zhcndoc.com/docs/utils/query-collection) 查询获得的文档。

::note
此组件 

**仅支持**

 

`Markdown`

 文件。
::

## 属性

| 属性           | 默认值         | 类型                   | 描述                                           |
| ------------ | ----------- | -------------------- | -------------------------------------------- |
| `value`      | `{}`        | `ParsedContent`      | 要渲染的文档。                                      |
| `tag`        | `'div'`     | `string`             | 渲染器元素使用的标签名（如果有使用）。                          |
| `excerpt`    | `false`     | `boolean`            | 是否仅渲染摘要而不渲染其余内容。                             |
| `components` | `{}`        | `object`             | 用于渲染的自定义组件映射。此属性将传递给 Markdown 渲染器，不影响其他文件类型。 |
| `data`       | `{}`        | `object` （必需）        | 将注入到 Markdown 内容中的变量映射，用于后续绑定变量。             |
| `prose`      | `undefined` | `boolean`            | 是否渲染 Prose 组件而非 HTML 标签。                     |
| `class`      | `undefined` | `string` 或 `object`  | 用于渲染的根标签的类名。                                 |
| `unwrap`     | `false`     | `boolean` 或 `string` | 需要去除包装的标签，多个标签用空格分隔。例如：`'ul li'`。            |

## 例子

```vue [pages/[...slug\\].vue]
<script lang="ts" setup>
const route = useRoute()
const { data: page } = await useAsyncData(route.path, () => {
  return queryCollection('docs').path(route.path).first()
})
</script>

<template>
  <ContentRenderer v-if="page" :value="page" />
</template>
```

## 处理缺失页面

如果查询的内容**缺失**，您可以显示**自定义的备用提示信息**。

```vue [pages/[...slug\\].vue]
<script lang="ts" setup>
const route = useRoute()
const { data: page } = await useAsyncData(route.path, () => {
  return queryCollection('docs').path(route.path).first()
})
</script>

<template>
  <template v-if="page">
    <ContentRenderer :value="page" />
  </template>
  <template v-else>
    <div class="empty-page">
      <h1>页面未找到</h1>
      <p>抱歉！您查找的内容不存在。</p>
      <NuxtLink to="/">返回首页</NuxtLink>
    </div>
  </template>
</template>
```

## 处理空页面

如果查询的内容**为空**，您可以显示**自定义的备用提示信息**。


# 插槽

当你在组件内使用 MDC 语法编写内容和段落时，可以使用 Vue 的 `<slot>` 组件来渲染内容。

## 用法

如果你不想修改渲染的内容，只需使用 Vue 的 `<slot>` 组件。

```vue [components/content/Callout.vue]
<template>
  <div class="callout">
    <slot />
  </div>
</template>
```

现在我们在 Markdown 中使用它：

```mdc [content/index.md]
::callout
这是一个呼出框。
::
```

渲染后的 HTML 将会是：

```html
<div class="callout">
  <p>这是一个呼出框。</p>
</div>
```

这种用法类似于使用原生的 `<slot>` 组件。

### 解除包裹

`mdc-unwrap` 属性允许你从渲染的内容中移除一个或多个包裹元素。当你想提取嵌套在原生 Markdown 语法中的内容时，这非常有用。指定的每个标签都会从 AST 中被移除。

让我们从上面的示例中解除 `<p>` 元素的包裹：

```vue [components/content/Callout.vue]
<template>
  <div class="callout">
    <slot mdc-unwrap="p" />
  </div>
</template>
```

现在渲染的 HTML 将会是：

```html
<div class="callout">
  这是一个呼出框。
</div>
```

### 命名插槽

`name` 属性允许你通过名称绑定一个插槽。当你想渲染非默认插槽时，这非常有用。

让我们改进 `Callout` 组件，增加一个 `title` 插槽：

```vue [components/content/Callout.vue]
<template>
  <div class="callout">
    <h2 v-if="$slots.title">
      <slot name="title" mdc-unwrap="p" />
    </h2>
    <slot />
  </div>
</template>
```

现在我们在 Markdown 中使用它：

```mdc [content/index.md]
::callout
#title
请小心！
#default
使用 MDC & Vue 组件会上瘾。
::
```

这将生成：

```html
<div class="callout">
  <h2>请小心！</h2>
  <p>使用 MDC & Vue 组件会上瘾。</p>
</div>
```

当不使用 `title` 插槽时，`h2` 元素将不会被渲染。

## 属性

- `mdc-unwrap`：是否解除内容的包裹。当你想提取嵌套在原生 Markdown 语法中的内容时，这非常有用。指定的每个标签都会从 AST 中被移除。
  - **类型：** `boolean` 或 `string`
  - **默认值：** `false`
  - **示例：** `'p'` 或 `'ul li'`


# 文章组件

文章组件是 HTML 排版标签的替代品。文章组件提供了一种简便的方式来自定义内容界面。

要覆盖文章组件，请在项目的 `components/content/` 目录下创建同名组件（例如：`components/content/ProseA.vue`）。

::note
文章组件最初是 

[`@nuxtjs/mdc`](https://github.com/nuxt-modules/mdc){rel=""nofollow""}

 的一部分。
::

## `ProseA`

::code-group
```md [代码]
[文章组件](/docs/components/prose)
```

  :::code-preview{icon="i-lucide-eye" label="预览"}
  [文章组件](https://nuxt-content.zhcndoc.com/docs/components/prose)
  :::
::

## `ProseBlockquote`

::code-group
```md [代码]
> 块引用
```

  :::code-preview{icon="i-lucide-eye" label="预览"}
  > 块引用
  :::
::

## `ProsePre`

::code-group
````md [代码]
  ```js [file.js]{2} meta-info=val
  export default () => {
    console.log('代码块')
  }
  ```
````

  :::code-preview{icon="i-lucide-eye" label="预览"}
  ```js [file.js]
  export default () => {
    console.log('代码块')
  }
  ```
  :::
::

组件属性示例如下：

```json
{
  code: "export default () => {\n    console.log('代码块')\n}"
  language: "js"
  filename: "file.js"
  highlights: [2]
  meta: "meta-info=val"
}
```

有关语法高亮的更多内容，请查看[高亮选项](https://nuxt-content.zhcndoc.com/docs/getting-started/configuration#highlight)。

::callout{type="warning"}
如果你想在文件名中使用 

`]`

，需要用两个反斜杠进行转义：

`\\]`

。这是必须的，因为 JS 会自动转义字符串中的反斜杠，导致 

`\]`

 变成 

`]`

，从而破坏正则表达式。
::

## `ProseCode`

::code-group
```md [代码]
`code`

`const code: string = 'highlighted code inline'`{lang="ts"}
```

  :::code-preview{icon="i-lucide-eye" label="预览"}
  `code`

  `const code: string = 'highlighted code inline'`{.shiki,shiki-themes,material-theme-lighter,material-theme,material-theme-palenight lang="ts"}
  :::
::

## `ProseH1`

::code-group
```md [代码]
# H1 标题
```

  :::code-preview{.pt-4 label="预览"}
  # H1 标题
  :::
::

## `ProseH2`

::code-group
```md [代码]
## H2 标题
```

  :::code-preview{icon="i-lucide-eye" label="预览"}
  ## H2 标题
  :::
::

## `ProseH3`

::code-group
```md [代码]
### H3 标题
```

  :::code-preview{icon="i-lucide-eye" label="预览"}
  ### H3 标题
  :::
::

## `ProseH4`

::code-group
```md [代码]
#### H4 标题
```

  :::code-preview{icon="i-lucide-eye" label="预览"}
  #### H4 标题
  :::
::

## `ProseH5`

::code-group
```md [代码]
##### H5 标题
```

  :::code-preview{icon="i-lucide-eye" label="预览"}
  ##### H5 标题
  :::
::

## `ProseH6`

::code-group
```md [代码]
###### H6 标题
```

  :::code-preview{icon="i-lucide-eye" label="预览"}
  ###### H6 标题
  :::
::

## `ProseHr`

::code-group
```md [代码]
下方分隔线。

---

上方分隔线。
```

  :::code-preview{icon="i-lucide-eye" label="预览"}
  下方分隔线。

  ---

  上方分隔线。
  :::
::

## `ProseImg`

::code-group
```md [代码]
![酷炫图片](https://nuxt.com/assets/design-kit/icon-green.png)
```

  :::code-preview{icon="i-lucide-eye" label="预览"}
  ![酷炫图片](https://nuxt.com/assets/design-kit/icon-green.png)
  :::
::

## `ProseUl`

::code-group
```md [代码]
- 只是
- 一个
- 无序
- 列表
```

  :::code-preview{icon="i-lucide-eye" label="预览"}
  - 只是
  - 一个
  - 无序
  - 列表
  :::
::

## `ProseLi`

::code-group
```md [代码]
- 列表项
```

  :::code-preview{icon="i-lucide-eye" label="预览"}
  - 列表项
  :::
::

## `ProseOl`

::code-group
```md [代码]
1. Foo
2. Bar
3. Baz
```

  :::code-preview{icon="i-lucide-eye" label="预览"}
  1. Foo
  2. Bar
  3. Baz
  :::
::

## `ProseP`

::code-group
```md [代码]
仅仅是一段文字。
```

  :::code-preview{icon="i-lucide-eye" label="预览"}
  仅仅是一段文字。
  :::
::

## `ProseStrong`

::code-group
```md [代码]
**仅仅是一段加粗文字。**
```

  :::code-preview{icon="i-lucide-eye" label="预览"}
  **仅仅是一段加粗文字。**
  :::
::

## `ProseEm`

::code-group
```md [代码]
_仅仅是一段斜体文字。_
```

  :::code-preview{icon="i-lucide-eye" label="预览"}
  *仅仅是一段斜体文字。*
  :::
::

## `ProseTable`

::code-group
```md [代码]
| 键  | 类型      | 描述       |
| --- | --------- | --------- |
| 1   | 极好      | 表格       |
| 2   | 极好      | 数据       |
| 3   | 极好      | 网站       |
```

  :::code-preview{icon="i-lucide-eye" label="预览"}
  | 键 | 类型 | 描述 |
  | - | -- | -- |
  | 1 | 极好 | 表格 |
  | 2 | 极好 | 数据 |
  | 3 | 极好 | 网站 |
  :::
::

## `ProseTbody`

包含在 **ProseTable** 示例中。

## `ProseTd`

包含在 **ProseTable** 示例中。

## `ProseTh`

包含在 **ProseTable** 示例中。

## `ProseThead`

包含在 **ProseTable** 示例中。

## `ProseTr`

包含在 **ProseTable** 示例中。

::callout
---
icon: i-simple-icons-github
to: https://github.com/nuxt-modules/mdc/tree/main/src/runtime/components/prose
---
查看这些组件的源代码请访问 GitHub。
::


# 服务器托管

## 什么是 Node.js 预设？

Node 预设是 Nuxt 的默认预设，构建项目时，Nuxt 会输出一个 Node.js 服务器，你可以通过 `node .output/server/index.mjs` 来运行它。

## 环境要求

如果你使用默认的 `better-sqlite3` 模块来操作 sqlite 数据库，则必须部署在 Glibc 版本高于 2.29 的操作系统上，例如 Debian 11、Ubuntu 20.04。

::note
你可以使用 

`ldd --version`

 检查 Glibc 版本。更多信息请参见 

[issue #3248](https://github.com/nuxt/content/issues/3248){rel=""nofollow""}

。
::

## 使用 Node.js 预设构建

使用 Nuxt 构建命令构建项目：

```bash [Terminal]
nuxi build
```

使用 Node 服务器预设运行 `nuxi build` 后，结果将是一个启动可运行 Node 服务器的入口点。

```bash [Terminal]
$ node .output/server/index.mjs
Listening on http://localhost:3000
```

::note
SQLite 数据库将在服务器启动时在服务器端加载，同时在浏览器中用于客户端导航或操作。
::


# 静态托管

## 什么是静态托管？

静态托管是一种托管类型，您的网站被构建并作为静态文件（HTML、CSS、JS）进行服务，任何静态文件服务器都可以提供这些文件。

Nuxt Content 可以使用 Nuxt 预渲染部署到静态托管。

## 使用 SSG 构建

要使用静态站点生成构建您的应用，请运行以下命令：

```bash
npx nuxi generate
```

::tip{icon="i-lucide-check"}
此命令将创建一个包含您的静态站点的 

`dist/`

 目录。您可以将其上传到任何静态托管服务。
::

Nuxt 将使用内部爬虫自动预渲染所有页面，您可以通过 `nitro.prerender` 选项自定义其行为。

::note{to="https://nuxt.com/docs/getting-started/prerendering"}
了解更多关于 Nuxt 预渲染的信息。
::

## 数据库怎么办？

Nuxt Content 将使用 [WASM SQLite](https://nuxt-content.zhcndoc.com/docs/advanced/database#wasm-sqlite-in-browser) 在浏览器中加载数据库，这样，内容查询发生在客户端导航或操作时时，会在浏览器中运行。


# 无服务器托管

## 什么是无服务器托管？

无服务器托管让你无需直接管理服务器即可运行代码和应用 —— 你只需上传代码，云服务提供商会自动处理所有基础设施、扩展和维护，只按你实际使用的计算资源收费。

**在无服务器环境中，每个用户请求都会触发一个新的 Nuxt 服务器实例，这意味着每次都是从头开始启动。** 这种“无状态”特性意味着你不能将数据存储在服务器内存中，也不能使用基于文件的数据库如 SQLite。因此，我们需要使用外部数据库服务（如 D1、Turso 或 PostgreSQL）来持久化数据，独立于你的服务器实例。

## 使用无服务器部署

该模块内置支持多个知名无服务器平台，你可以轻松将项目部署到它们上。查看各个平台的指南：

- [Cloudflare Pages](https://nuxt-content.zhcndoc.com/docs/deploy/cloudflare-pages)
- [Vercel](https://nuxt-content.zhcndoc.com/docs/deploy/vercel)

如果你想部署到其他平台，可以按照下面的步骤进行。

### 1. 选择数据库服务

在部署项目之前，你需要选择一个数据库服务：

::code-group
```ts [PostgreSQL]
// 1. 创建一个 PostgreSQL 数据库
// 2. 将 `POSTGRES_URL` 添加到环境变量中
export default defineNuxtConfig({
  content: {
    database: {
      type: 'postgresql',
      url: process.env.POSTGRES_URL
    }
  }
})
```

```ts [Cloudflare D1]
// 1. 在你的 Cloudflare 账户中创建一个 D1 数据库
// 2. 使用相同的绑定名将其链接到你的项目
export default defineNuxtConfig({
  content: {
    database: {
      type: 'd1',
      bindingName: '<YOUR_BINDING_NAME>'
    }
  }
})
```

```ts [LibSQL]
// 1. 在 Turso.tech 上创建一个 LibSQL 数据库
// 2. 并添加 `TURSO_DATABASE_URL` 和 `TURSO_AUTH_TOKEN` 环境变量
export default defineNuxtConfig({
  modules: ['@nuxt/content'],
  content: {
    database: {
      type: 'libsql',
      url: process.env.TURSO_DATABASE_URL,
      authToken: process.env.TURSO_AUTH_TOKEN,
    }
  }
})
```

```ts [NuxtHub]
// 安装 NuxtHub 模块（参见 hub.nuxt.com）
export default defineNuxtConfig({
  modules: ['@nuxt/content', '@nuxthub/core'],
  content: {
    database: {
      type: 'd1',
      binding: 'DB'
    }
  },
  hub: {
    database: true
  }
})
```
::

### 2. 部署你的项目

Nuxt Content 使用 Nuxt 部署预设来调整不同托管平台的构建流程。

以下无服务器平台支持零配置：

- [Cloudflare](https://nuxt.com/deploy/cloudflare){rel="&#x22;nofollow&#x22;"}
- [NuxtHub](https://nuxt.com/deploy/nuxthub){rel="&#x22;nofollow&#x22;"}
- [Vercel](https://nuxt.com/deploy/vercel){rel="&#x22;nofollow&#x22;"}
- [Netlify](https://nuxt.com/deploy/netlify){rel="&#x22;nofollow&#x22;"}

你只需将构建命令设置为：

```bash [Terminal]
nuxi build
```

生成的输出将兼容所选平台。

::note
链接的数据库将在服务器启动时于服务器端加载。浏览器端将加载一个 

[WASM SQLite](https://nuxt-content.zhcndoc.com/docs/advanced/database#wasm-sqlite-in-browser)

 数据库，用于客户端导航和操作。
::

::tip
如果你想部署到 AWS Lambda 或 Azure Static Web Apps，你需要确保你的 sqlite 文件在 `/tmp` 目录下，因为这是唯一可写的文件夹。

```ts
export default defineNuxtConfig({
  modules: ['@nuxt/content'],
  content: {
    database: {
      type: 'sqlite',
      filename: '/tmp/contents.sqlite'
    }
  }
})
```
::

### 3. 通过预渲染优化

由于每个请求都会触发一个新的 Nuxt 服务器实例，如果不预渲染部分页面，将影响你的无服务器应用性能。

为了优化你的无服务器应用，你可以使用 `routeRules` 选项预渲染页面：

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  routeRules: {
    '/': { prerender: true }
  }
})
```

::tip{to="https://hub.nuxt.com/docs/recipes/pre-rendering"}
我们推荐查看 

**NuxtHub 的预渲染指南**

，了解更多优化无服务器应用的不同策略，该指南适用于所有无服务器平台。
::


# NuxtHub

Nuxt Content 模块内置了与 [NuxtHub](https://hub.nuxt.com){rel="&#x22;nofollow&#x22;"} 的集成，用于部署您的内容。

要启用 NuxtHub 集成，您需要安装 `@nuxthub/core` 模块并在 `nuxt.config.ts` 中注册。更高效的做法是使用 `nuxi module` 命令一次完成这两个操作。

```bash [Terminal]
npx nuxi module add hub
```

仅此而已 🎉

::callout
Nuxt Content 模块会自动读取 NuxtHub 数据库选项，以便共用同一个数据库存储 Nuxt Content 数据。
::

请查看 [NuxtHub 文档](https://hub.nuxt.com){rel="&#x22;nofollow&#x22;"} 了解更多信息。


# Cloudflare Pages

::card
快速设置

1. 使用 `nuxi build --preset=cloudflare_pages` 构建您的应用
2. 在 Cloudflare 控制面板中创建 D1 数据库并连接到项目，绑定名称为 `DB`
3. 部署/重新部署您的应用
::

---

Nuxt Content 模块内置与 [Cloudflare Pages](https://pages.cloudflare.com){rel="&#x22;nofollow&#x22;"} 的集成以部署您的内容。

模块将自动检测构建目标并准备 Cloudflare Pages 所需的配置。

您可以在 `nuxi build` 命令中使用 `--preset=cloudflare_pages` 选项，或者在 `nuxt.config.ts` 中配置该预设。

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  nitro: {
    preset: 'cloudflare_pages',
  },
});
```

## D1 数据库

Nuxt Content 模块的正常工作**需要*&#x2A;连接一个 D1 数据库。默认情况下模块使用绑定名称 &#x2A;*`DB`**。您可以通过在 `nuxt.config.ts` 中提供您的自定义数据库配置来覆盖该设置，详情见 [数据库配置](https://nuxt-content.zhcndoc.com/docs/getting-started/configuration#d1)。

创建新的 Cloudflare Pages 项目后，您需要新建一个 D1 数据库并将其连接到项目。请确保使用与模块相同的绑定名称。

### 本地预览

虽然 `nuxi dev` 和 `nuxi build` 不需要额外配置，但使用 `nuxi preview` 进行本地构建测试时，需要配置 Cloudflare 的 Wrangler，以提供一个临时的本地数据库供 Nuxt Content 绑定。此配置可以通过 `wrangler.jsonc` 或 `wrangler.toml` 文件实现。因为 Wrangler 会创建本地数据库，`database_name` 和 `database_id` 可以安全地与生产环境中的值不同，但也可以相同。

```jsonc [wrangler.jsonc]
{
  "d1_databases": [
    {
      "binding": "DB",
      "database_name": "example-db",
      "database_id": "example-db-id"
    }
  ]
}
```

请查看：

- [Nuxt 部署文档](https://nuxt.com/deploy/cloudflare){rel="&#x22;nofollow&#x22;"}
- [Cloudflare D1 文档](https://developers.cloudflare.com/d1/){rel="&#x22;nofollow&#x22;"}
- [Create and bind a D1 database](https://developers.cloudflare.com/d1/get-started/){rel="&#x22;nofollow&#x22;"}
- [Cloudflare Pages 文档](https://developers.cloudflare.com/pages/){rel="&#x22;nofollow&#x22;"}


# Cloudflare Workers

::card
快速设置

1. 使用 `cloudflare_module` 预设和 `2024-09-19` 或更晚的兼容日期。
2. 在 Cloudflare 控制面板中创建一个 D1 数据库，并在项目中以 `DB` 绑定名称连接该数据库，同时在 `nuxt.config.ts` 文件中配置数据库。
3. 构建并部署您的应用
::

---

Nuxt Content 模块内置对 [Cloudflare Workers](https://workers.cloudflare.com){rel="&#x22;nofollow&#x22;"} 的集成，用于部署您的内容。

该模块会自动检测构建目标，并为 Cloudflare Workers 准备所需的配置。

您只需创建一个 Cloudflare D1 数据库并连接到您的项目即可。创建 D1 数据库后，应该在 `nuxt.config.ts` 文件中通过 `nitro.cloudflare.wrangler.d1_databases` 选项定义数据库配置。

默认情况下，模块会使用 `DB` 绑定名称。您可以通过在 `nuxt.config.ts` 中提供自定义的数据库配置来覆盖默认配置。

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  compatibilityDate: "2025-05-15",
  nitro: {
    preset: 'cloudflare_module',
    cloudflare: {
      deployConfig: true,
      wrangler: {
        d1_databases: [
          {
            binding: 'DB',
            database_name: 'database-name',
            database_id: '*********-***-****-****-*********'
          }
        ]
      },
    },
  }
})
```

::note
如果您想使用不同的绑定名称，可以通过在 

`nuxt.config.ts`

 中提供自定义数据库配置进行覆盖。详见 

[数据库配置](https://nuxt-content.zhcndoc.com/docs/getting-started/configuration#d1)
::

::note
要将 Nuxt 项目部署到 Cloudflare Workers，您需要使用 

`2024-09-19`

 或更晚的兼容日期。
::

使用 `nuxi build` 命令构建项目，然后可以用 `wrangler deploy` 命令部署项目。

```bash
npx wrangler deploy
```

完成！ 🎉

查看：

- [Nuxt 部署文档](https://nuxt.com/deploy/cloudflare){rel="&#x22;nofollow&#x22;"}
- [Cloudflare D1 文档](https://developers.cloudflare.com/d1/){rel="&#x22;nofollow&#x22;"}
- [Cloudflare Workers 文档](https://developers.cloudflare.com/workers/){rel="&#x22;nofollow&#x22;"}


# Vercel

::card
快速设置

- 执行 `npx vercel deploy` 命令，或前往 Vercel 仪表盘并使用 Git 仓库创建一个新项目。
::

---

Nuxt Content 项目可以零配置部署到 Vercel。该模块会自动检测 Vercel 环境，并准备部署所需的配置。

您只需执行 `npx vercel deploy` 命令，或前往 Vercel 仪表盘并使用 Git 仓库创建新项目。

就是这么简单 🎉

::note
默认情况下，模块将在 Vercel 的 `/tmp` 目录使用 SQLite 数据库。您可以通过提供自己的数据库配置来覆盖默认配置。

:br

Vercel 支持多种数据库服务商。您可以通过在 `nuxt.config.ts` 中提供正确的连接字符串来使用其中任何一个。
::

参考链接：

- [Nuxt 部署文档](https://nuxt.com/deploy/vercel){rel="&#x22;nofollow&#x22;"}
- [Vercel 文档](https://vercel.com/docs/deployments/deployment-methods){rel="&#x22;nofollow&#x22;"}


# Netlify

::card
快速设置

- 进入 Netlify 仪表盘，使用 git 仓库创建一个新项目。
- 在 `依赖管理` 下的 `站点配置` 中，将 Node 版本更改为 `20.x` 或更高。
- 进入 `部署`，重试上一次部署。
::

---

Nuxt Content 项目可以无需配置即可部署到 Netlify。该模块会自动检测 Netlify 环境并为 Netlify 准备所需的配置。

您只需进入 Netlify 仪表盘，使用 git 仓库创建一个新项目即可。

::note
默认情况下，Netlify 使用 Node.js 18.x 版本，但该版本不受模块支持。您需要在 

`依赖管理`

 下的 

`站点配置`

 中更改 Node.js 版本。
::

就是这么简单 🎉

参考资料：

- [Nuxt 部署文档](https://nuxt.com/deploy/netlify){rel="&#x22;nofollow&#x22;"}
- [Netlify 文档](https://www.netlify.com/blog/2016/09/29/a-step-by-step-guide-deploying-on-netlify/){rel="&#x22;nofollow&#x22;"}


# AWS Amplify

::card
快速设置

- 准备 Sqlite 连接器
  - 选项 A（推荐用于 Node.js 22+）：使用原生的 `node:sqlite`
  - 选项 B（传统方式）：在项目中安装 `sqlite3` 包。
- 访问 AWS Amplify 控制台，使用 Git 仓库创建一个新项目并部署应用。
::

---

Nuxt Content 项目可以零配置部署到 AWS Amplify。 :br
该模块会自动检测 AWS Amplify 环境，并准备好部署所需的配置。

## 选项 A：使用原生 `node:sqlite`

为了使用原生的 `node:sqlite` 包，您需要将 Node 版本切换到 22 及以上。这可以通过 Amplify 控制台的 `Build Settings` > `Live Package Updates` > `Package (Node.js version) = 22` 来轻松实现。

也可以通过在 `amplify.yml` 的 `preBuild` 阶段进行配置：

```yml
frontend:
  phases:
    preBuild:
      commands:
        - nvm install 22
        - nvm use 22
        - node -v
        - npm ci
```

## 选项 B：使用 `sqlite3`

您只需在项目中安装 `sqlite3` 包，然后访问 AWS Amplify 控制台，使用 Git 仓库创建一个新项目即可。

就是这么简单 🎉

::note
默认情况下，模块会使用位于 

`/tmp`

 目录下的 SQLite 数据库。您也可以通过提供自定义数据库配置来覆盖默认配置。
::

参考链接：

- [Nuxt 部署文档](https://nuxt.com/deploy/aws-amplify){rel="&#x22;nofollow&#x22;"}


# Docker

Docker 是一个流行的容器化平台，它允许您将应用程序及其所有依赖项打包到一个单独的容器中。这样可以轻松地在任何支持 Docker 的平台上部署您的内容应用。

## 使用 Node.js 镜像

使用 Docker 的 Node.js 镜像，您可以部署您的内容应用。您只需要创建一个 Dockerfile 并构建镜像。以下是一个示例 Dockerfile：

```docker [Dockerfile]
# 构建阶段 1

FROM node:22-alpine AS build
WORKDIR /app

RUN corepack enable

# 复制 package.json 和您的锁文件，这里添加 pnpm-lock.yaml 作为示例
COPY package.json pnpm-lock.yaml .npmrc ./

# 安装依赖
RUN pnpm i

# 复制整个项目
COPY . ./

# 构建项目
RUN pnpm run build

# 构建阶段 2

FROM node:22-alpine
WORKDIR /app

# 只需要从构建阶段复制 `.output` 文件夹
COPY --from=build /app/.output/ ./

# 修改端口和主机
ENV PORT=80
ENV HOST=0.0.0.0

EXPOSE 80

CMD ["node", "/app/server/index.mjs"]
```

## 使用 Bun 镜像

如果您喜欢使用 Bun，可以使用官方的 Bun 镜像。以下是一个示例 Dockerfile：

```docker [Dockerfile]
# 使用官方 Bun 镜像
# 所有版本见 https://hub.docker.com/r/oven/bun/tags
FROM oven/bun:1 AS build
WORKDIR /app

COPY package.json bun.lock* ./

# 使用 ignore-scripts 以避免构建像 better-sqlite3 这样的 node 模块
RUN bun install --frozen-lockfile --ignore-scripts

# 复制整个项目
COPY . .

RUN bun --bun run build

# 将生产依赖和源码复制到最终镜像
FROM oven/bun:1 AS production
WORKDIR /app

# 只需要从构建阶段复制 `.output` 文件夹
COPY --from=build /app/.output /app

# 运行应用
EXPOSE 3000/tcp
ENTRYPOINT [ "bun", "--bun", "run", "/app/server/index.mjs" ]
```


# I18n module

Nuxt Content integrates with [`@nuxtjs/i18n`](https://i18n.nuxtjs.org/){rel="&#x22;nofollow&#x22;"} to create multi-language websites. When both modules are configured together, you can organize content by language and automatically serve the correct content based on the user's locale.

## Setup

::prose-steps
### Install the required module

```bash [terminal]
npm install @nuxtjs/i18n
```

### Configure your `nuxt.config.ts`

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  modules: ['@nuxt/content', '@nuxtjs/i18n'],
  i18n: {
    locales: [
      { code: 'en', name: 'English', language: 'en-US', dir: 'ltr' },
      { code: 'fr', name: 'French', language: 'fr-FR' },
      { code: 'fa', name: 'Farsi', language: 'fa-IR', dir: 'rtl' },
    ],
    strategy: 'prefix_except_default',
    defaultLocale: 'en',
  }
})
```

### Define collections for each language

Create separate collections for each language in your `content.config.ts`:

```ts [content.config.ts]
const commonSchema = ...;

export default defineContentConfig({
  collections: {
    // English content collection
    content_en: defineCollection({
      type: 'page',
      source: {
        include: 'en/**',
        prefix: '',
      },
      schema: commonSchema,
    }),
    // French content collection
    content_fr: defineCollection({
      type: 'page',
      source: {
        include: 'fr/**',
        prefix: '',
      },
      schema: commonSchema,
    }),
    // Farsi content collection
    content_fa: defineCollection({
      type: 'page',
      source: {
        include: 'fa/**',
        prefix: '',
      },
      schema: commonSchema,
    }),
  },
})
```

### Create dynamic pages

Create a catch-all page that fetches content based on the current locale:

```vue [pages/[...slug\\].vue]
<script setup lang="ts">
import { withLeadingSlash } from 'ufo'
import type { Collections } from '@nuxt/content'

const route = useRoute()
const { locale } = useI18n()
const slug = computed(() => withLeadingSlash(String(route.params.slug)))

const { data: page } = await useAsyncData('page-' + slug.value, async () => {
  // Build collection name based on current locale
  const collection = ('content_' + locale.value) as keyof Collections
  const content = await queryCollection(collection).path(slug.value).first()

  // Optional: fallback to default locale if content is missing
  if (!content && locale.value !== 'en') {
    return await queryCollection('content_en').path(slug.value).first()
  }

  return content
}, {
  watch: [locale], // Refetch when locale changes
})
</script>

<template>
  <ContentRenderer v-if="page" :value="page" />
  <div v-else>
    <h1>Page not found</h1>
    <p>This page doesn't exist in {{ locale }} language.</p>
  </div>
</template>
```
::

That's it! 🚀 Your multi-language content site is ready.

## Content Structure

Organize your content files in language-specific folders to match your collections:

```text
content/
  en/
    index.md
    about.md
    blog/
      post-1.md
  fr/
    index.md
    about.md
    blog/
      post-1.md
  fa/
    index.md
    about.md
```

Each language folder should contain the same structure to ensure content parity across locales.

## Fallback Strategy

You can implement a fallback strategy to show content from the default locale when content is missing in the current locale:

```ts [pages/[...slug\\].vue]
const { data: page } = await useAsyncData('page-' + slug.value, async () => {
  const collection = ('content_' + locale.value) as keyof Collections
  let content = await queryCollection(collection).path(slug.value).first()

  // Fallback to default locale if content is missing
  if (!content && locale.value !== 'en') {
    content = await queryCollection('content_en').path(slug.value).first()
  }

  return content
})
```

::prose-warning
Make sure to handle missing content gracefully and provide clear feedback to users when content is not available in their preferred language.
::

## Complete Examples

You can see a complete working example:

- **Source**: <https://github.com/nuxt/content/tree/main/examples/i18n>{rel="&#x22;nofollow&#x22;"}
- **Live Demo**: <https://content3-i18n.nuxt.dev/>{rel="&#x22;nofollow&#x22;"}


# LLMs 模块

Nuxt Content 模块集成了 [`nuxt-llms`](https://github.com/nuxtlabs/nuxt-llms){rel="&#x22;nofollow&#x22;"}，用于为大型语言模型 (LLMs) 准备内容。当检测到 `nuxt-llms` 时，Content 模块会自动扩展 LLMs 模块，并将类型为 [page](https://content.nuxt.com/docs/collections/types#page-type){rel="&#x22;nofollow&#x22;"} 的集合注入到 LLMs 模块中。🚀

## 设置

::prose-steps
### 安装所需模块

```bash [terminal]
npm install nuxt-llms
```

### 配置你的 `nuxt.config.ts`

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  modules: ['@nuxt/content', 'nuxt-llms'],
  llms: {
    domain: 'https://your-site.com',
    title: '你的站点名称',
    description: '你站点的简要描述',
  },
})
```
::

就是这么简单 🚀 `/llms.txt` 文件会被自动生成并预渲染。

## 分区

在生成内容时，你可以创建自定义分区，将内容处理为适合 LLM 使用的格式。

你可以向 `llms.sections` 数组中添加自定义分区，并为每个分区定义 `contentCollection` 和 `contentFilters` 选项。

::prose-warning
如果在 

`contentCollection`

 选项中未定义分区，模块将仅把 

[page](https://content.nuxt.com/docs/collections/types#page-type){rel=""nofollow""}

 集合添加到 LLMs 模块。
::

### `contentCollection`

此选项指定要使用哪个内容集合作为来源。

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  llms: {
    sections: [
      {
        title: '文档',
        description: '技术文档和指南',
        contentCollection: 'docs',
       },
    ],
  },
})
```

### `contentFilters`

此选项定义用于选择集合中特定内容的过滤器。

你可以精确控制包含哪些内容。每个过滤器包含：

- `field`：要检查的内容属性
- `operator`：比较运算符（`=`、`<>`、`>`、`<`、`LIKE`、`IN`、`NOT IN`、`IS NULL`、`IS NOT NULL` 等）
- `value`：比较的值

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  llms: {
    sections: [
      {
        title: '文档',
        description: '技术文档和指南',
        contentCollection: 'docs',
        contentFilters: [
            // 只包含 Markdown 文件
            { field: 'extension', operator: '=', value: 'md' },
            // 只包含已发布的内容
            { field: 'draft', operator: '<>', value: true },
            // 按目录过滤
            { field: 'path', operator: 'LIKE', value: '/guide%' },
        ]
      },
    ],
  },
})
```

::tip{to="https://github.com/nuxtlabs/nuxt-llms"}
查看 nuxt-llms 文档以获取有关该模块的更多信息。
::


# 全文搜索

Content 模块提供了一个便捷的工具 [`queryCollectionSearchSections`](https://nuxt-content.zhcndoc.com/docs/utils/query-collection-search-sections)，用于将内容文件拆分成可搜索的章节。这对于在网站中实现全文搜索非常有用。你可以将该工具的结果与 [Nuxt UI Content Search](https://ui.nuxt.com/pro/components/content-search){rel="&#x22;nofollow&#x22;"} 或其他搜索库如 [Fuse.js](https://fusejs.io/){rel="&#x22;nofollow&#x22;"}、[minisearch](https://lucaong.github.io/minisearch){rel="&#x22;nofollow&#x22;"} 等结合使用。

## Nuxt UI

Nuxt UI 提供了一个现成的全文搜索组件。你可以将 `queryCollectionSearchSections` 的结果传递给该组件的 `files` 属性来使用。

详细阅读 [Nuxt UI Content Search](https://ui.nuxt.com/pro/components/content-search){rel="&#x22;nofollow&#x22;"}。

::code-group
```vue [UContentSearchExample.vue]
<script setup lang="ts">
const { data: navigation } = await useAsyncData('navigation', () => queryCollectionNavigation('docs'))
const { data: files } = await useAsyncData('search', () => queryCollectionSearchSections('docs'))

const searchTerm = ref('')
</script>

<template>
  <UContentSearch
    v-model:search-term="searchTerm"
    :files="files"
    :navigation="navigation"
    :fuse="{ resultLimit: 42 }"
  />
</template>
```

  :::code-preview{icon="i-lucide-eye" label="实时预览"}
  :example-fulltext-content-search
  :::
::

## MiniSearch 示例

详细阅读 [minisearch](https://lucaong.github.io/minisearch){rel="&#x22;nofollow&#x22;"}。

::code-group
```vue [MiniSearchExample.vue]
<script setup lang="ts">
import MiniSearch from 'minisearch'

const query = ref('')
const { data } = await useAsyncData('search', () => queryCollectionSearchSections('docs'))

const miniSearch = new MiniSearch({
  fields: ['title', 'content'],
  storeFields: ['title', 'content'],
  searchOptions: {
    prefix: true,
    fuzzy: 0.2,
  },
})

// 将数据添加到 MiniSearch 实例中
miniSearch.addAll(toValue(data.value))
const result = computed(() => miniSearch.search(toValue(query)))
</script>

<template>
  <UContainer class="p-4">
    <UCard>
      <UInput v-model="query" placeholder="搜索..." />
      <ul>
        <li v-for="link of result" :key="link.id" class="mt-2">
          <NuxtLink :to="link.id">{{ link.title }}</NuxtLink>
          <p class="text-gray-500 text-xs">{{ link.content }}</p>
        </li>
      </ul>
    </UCard>
  </UContainer>
</template>
```

  :::code-preview{icon="i-lucide-eye" label="实时预览"}
  :example-fulltext-mini-search
  :::
::

## Fuse.js 示例

详细阅读 [Fuse.js](https://fusejs.io){rel="&#x22;nofollow&#x22;"}。

::code-group
```vue [FusejsExample.vue]
<script setup lang="ts">
import Fuse from 'fuse.js'

const query = ref('')
const { data } = await useAsyncData('search-data', () => queryCollectionSearchSections('docs'))

const fuse = new Fuse(data.value, {
  keys: ['title', 'description']
})

const result = computed(() => fuse.search(toValue(query)).slice(0, 10))
</script>

<template>
  <UContainer class="p-4">
    <UCard>
      <UInput v-model="query" placeholder="搜索..." class="w-full" />
      <ul>
        <li v-for="link of result" :key="link.item.id" class="mt-2">
          <UButton variant="ghost" class="w-full" :to="link.item.id">
            {{ link.item.title }}
            <span class="text-gray-500 text-xs">
              {{ link.item.content?.slice(0, 100) }}...
            </span>
          </UButton>
        </li>
      </ul>
    </UCard>
  </UContainer>
</template>
```

  :::code-preview{icon="i-lucide-eye" label="实时预览"}
  :example-fulltext-fusejs
  :::
::


# 原始内容

在内容版本 2 中，有很多关于在生产环境访问内容原始数据的请求。在内容版本 3 中，可以将内容原始数据传递到生产环境。

为了将原始内容传递到生产环境，您需要在集合的 schema 中定义 `rawbody` 字段。就是这么简单。

Nuxt Content 会检测到 schema 中这个神奇的字段，并用原始内容填充它。

```ts [content.config.ts]

import { defineCollection, defineContentConfig } from '@nuxt/content'
import { z } from 'zod'

export default defineContentConfig({
  collections: {
    docs: defineCollection({
      source: '**',
      type: 'page',
      schema: z.object({
        rawbody: z.string()
      })
    })
  }
})
```

您可以使用 `queryCollection()` 来获取原始内容。

```vue [pages/index.vue]
<script setup lang="ts">
const route = useRoute()
const { data } = useAsyncData('page-' + route.path, () => queryCollection('docs').path(route.path).first())
</script>

<template>
  <pre>{{ data.rawbody }}</pre>
</template>
```

如果您不想传递某个文件的原始内容，可以在该文件的 frontmatter 中添加 `rawbody: ''`。`rawbody` 的自动填充值就像一个默认值，当您在 frontmatter 中定义了 `rawbody` 时，会覆盖自动填写的值。

```md [content.md]
---
title: 我的页面
rawbody: ''
---

```

::callout
重要的是要确保 frontmatter 字段的数据类型与集合 schema 中定义的类型相同。在本例中，

`rawbody`

 是字符串类型，您应考虑传递空字符串。请勿使用布尔值或其他类型的值。
::


# 数据库

在 Content v3 中，我们引入了基于 SQLite 的强大存储层，提供了一种强大且高效的内容管理方法。这相比之前基于文件的存储系统是一个显著的提升，后者在性能和可扩展性方面存在局限。

> 在 Content v2 中，系统在 Nitro 运行时读取并解析内容，为每个内容文件创建缓存文件以存储解析数据。这种方法给网站运行时带来了相当大的开销。
>
> - 生产环境中的 I/O 时间较长，因为模块必须加载所有缓存文件来搜索内容。
> - 此外，由于内容缺乏优化和压缩，导致包体积较大，特别在边缘环境中表现尤为明显。

Content v3 的内容管理包含三个关键步骤，旨在简化流程并提升性能。

## 生成数据库转储文件

对于项目中的每个集合，模块从定义的源读取内容并解析成抽象语法树（AST）。基于集合的模式为每个集合创建特定的表。然后将解析后的内容插入对应的表中，确保数据结构与定义的模式一致，以实现最佳查询效果。所有内容最终保存到转储文件中。

## 冷启动时还原转储文件

在运行时，当应用执行首次内容查询时，模块会读取前一步生成的转储文件，并将其还原到目标数据库中。该过程快速且针对不同部署模式和平台进行了优化。

模块采用了特殊的完整性检查机制，确保数据库内容更新到最新状态。该完整性检查机制还能防止重复导入，保持数据存储的完整性和准确性。

## 浏览器中的 WASM SQLite

针对客户端导航，模块采用类似的方法。当应用执行首次内容查询时，会从服务器下载生成的转储文件，并在浏览器中初始化本地 SQLite 数据库。从此之后，所有查询均在本地执行，无需调用服务器，大大提升了应用响应速度并提供无缝用户体验。

这一架构不仅提升了性能，还支持离线功能，使用户即使在无网络连接时也能访问内容。服务器端与客户端的结合确保 Nuxt Content v3 功能强大且灵活，适用于广泛的用例和环境。


# 工具

Nuxt Content 使用 &#x2A;*SQLite 数据库 (`contents.sqlite`)** 来高效地存储和查询内容。如果你遇到 **内容丢失、查询缓慢或数据库问题**，调试你的 SQLite 数据库将会有帮助！

::callout
---
icon: i-simple-icons-visualstudiocode
to: https://marketplace.visualstudio.com/items?itemName=alexcvzz.vscode-sqlite
---
一个简单的检查方法？

**使用 SQLite VS Code 扩展！**
::

## 安装 SQLite VS Code 扩展

1. 打开 **Visual Studio Code**。
2. 进入 **扩展** 面板（Windows/Linux：`Ctrl+Shift+X`，Mac：`Cmd+Shift+X`）。
3. 搜索 &#x2A;*"SQLite"**（由 `alexcvzz` 发布）并安装。
4. 打开你的 Nuxt Content 数据库 (`.data/content/contents.sqlite`)。

::tip{icon="i-lucide-lightbulb"}
如果你看不到 `contents.sqlite`，请先启动你的 Nuxt 应用：

```bash [终端]
npx nuxi dev
```
::

## 找到你的 SQLite 数据库

Nuxt Content 将数据库存储在：

```bash
.data/content/contents.sqlite
```

::note{to="https://nuxt.com/docs/getting-started/prerendering"}
该文件会在你启动 Nuxt 应用时自动生成。无需手动创建！
::

## 打开并浏览数据库

1. 在 VS Code 中 **右键点击** `contents.sqlite`。
2. 选择 &#x2A;*“打开数据库”**。
3. 展开 **数据库资源管理器** 面板查看表和数据。

![VS Code 中的 SQLite 资源管理器](https://github.com/user-attachments/assets/c9f22c4c-7a95-43e8-ab03-aa76f2e49c8e)

## 解决常见问题

### 内容没有显示？

1. **检查数据库是否存在**（`.data/content/contents.sqlite`）。
2. **执行清理并重启 Nuxt**：
   ```bash \[终端]
   npx nuxi cleanup && npx nuxi dev
   ```
3. **检查数据库内是否有内容**（执行 SQL 查询）。

### 手动重置数据库

如果问题非常严重，可以尝试重置数据库：

1. **删除数据库文件**：
   ```bash \[终端]
   rm -rf .data/content/contents.sqlite
   ```
2. **运行清理以移除旧缓存**：
   ```bash \[终端]
   npx nuxi cleanup
   ```
3. **重启 Nuxt**以生成全新的数据库：
   ```bash \[终端]
   npx nuxi dev
   ```

::note{icon="i-lucide-triangle-alert"}
清理操作会删除缓存数据，别担心——它会自动重新生成！
::

## 更多调试工具

如果 VS Code 不够用，可以尝试：

- 🖥️ [**DB Browser for SQLite**](https://sqlitebrowser.org/){rel="&#x22;nofollow&#x22;"} – 一个用于检查和修改数据库的可视化工具。
- 🛠️ **SQLite 命令行** – 在终端使用 `sqlite3 contents.sqlite` 执行 SQL 查询。


# Hooks

## `content:file:beforeParse`{.shiki,shiki-themes,material-theme-lighter,material-theme,material-theme-palenight lang="ts"}

此钩子在内容解析之前调用。

它可用于修改来自 `file` 的原始内容，或修改转换选项。

```ts
export default defineNuxtConfig({
  hooks: {
    'content:file:beforeParse'(ctx) {
      // ...
    }
  }
})
```

## `content:file:afterParse`{.shiki,shiki-themes,material-theme-lighter,material-theme,material-theme-palenight lang="ts"}

此钩子在内容解析之后且保存到数据库之前调用。

```ts
export default defineNuxtConfig({
  hooks: {
    'content:file:afterParse'(ctx) {
      // ...
    }
  }
})
```

## 示例用法

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  // ...
  hooks: {
    'content:file:beforeParse'(ctx) {
      const { file } = ctx;

      if (file.id.endsWith(".md")) {
        file.body = file.body.replace(/react/gi, "Vue");
      }
    },
    'content:file:afterParse'(ctx) {
      const { file, content } = ctx;

      const wordsPerMinute = 180;
      const text = typeof file.body === 'string' ? file.body : '';
      const wordCount = text.split(/\s+/).length;

      content.readingTime = Math.ceil(wordCount / wordsPerMinute);
    }
  }
})
```

::note{icon="i-lucide-info"}
在 `content:file:afterParse` 钩子中，我们向内容对象添加了一个自定义属性。为了能在页面中通过 [`queryCollection()`](https://nuxt-content.zhcndoc.com/docs/utils/query-collection) 访问该属性，我们首先需要在内容模式中定义它。

```ts [content.config.ts]
export default defineContentConfig({
  collections: {
    content: defineCollection({
      type: 'page',
      source: '**/*.md',
      schema: z.object({
        readingTime: z.number().optional()
      })
    })
  }
});
```
::


# 自定义来源

默认情况下，Nuxt Content 提供了一些内置的来源，例如本地文件来源和远程 Github 来源。但是，对于某些情况来说，这些还不够，例如，你想从远程 API 获取数据。这种情况下，你可以定义一个自定义来源来获取数据并在你的集合中使用它。

使用 `defineCollectionSource`，你可以定义一个自定义来源。

```ts
import { defineCollectionSource } from '@nuxt/content'

const hackernewsSource = defineCollectionSource({
  getKeys: () => {
    return fetch('https://hacker-news.firebaseio.com/v0/topstories.json')
      .then(res => res.json())
      .then(data => data.map((key: string) => `${key}.json`))
  },
  getItem: (key: string) => {
    const id = key.split('.')[0]
    return fetch(`https://hacker-news.firebaseio.com/v0/item/${id}.json`)
      .then(res => res.json())
  },
})
```

然后你可以在你的集合中使用这个来源。

```ts [content.config.ts]
import { defineContentConfig, defineCollectionSource, defineCollection } from '@nuxt/content'
import { z } from 'zod'

const hackernewsSource = defineCollectionSource({
  getKeys: () => {
    return fetch('https://hacker-news.firebaseio.com/v0/topstories.json')
      .then(res => res.json())
      .then(data => data.map((key: string) => `${key}.json`))
  },
  getItem: (key: string) => {
    const id = key.split('.')[0]
    return fetch(`https://hacker-news.firebaseio.com/v0/item/${id}.json`)
      .then(res => res.json())
  },
})

const hackernews = defineCollection({
  type: 'data',
  source: hackernewsSource,
  schema: z.object({
    title: z.string(),
    date: z.date(),
    type: z.string(),
    score: z.number(),
    url: z.string(),
    by: z.string(),
  }),
})

export default defineContentConfig({
  collections: {
    hackernews,
  },
})
```


# 转换器

Nuxt Content 中的 Transformers 允许你在内容文件处理过程中以编程方式解析、修改或分析你的内容文件。它们特别适用于：

- 添加或修改字段（例如，给标题追加内容、生成 slug）
- 提取元数据（例如，列出使用的组件）
- 用计算数据丰富内容
- 支持新的内容类型

## 定义 Transformer

你可以使用来自 `@nuxt/content` 的 `defineTransformer` 辅助函数定义一个 transformer：

```ts [~~/transformers/title-suffix.ts]
import { defineTransformer } from '@nuxt/content'

export default defineTransformer({
  name: 'title-suffix',
  extensions: ['.md'], // 要应用此 transformer 的文件扩展名
  transform(file) {
    // 根据需要修改文件对象
    return {
      ...file,
      title: file.title + ' (suffix)',
    }
  },
})
```

### Transformer 选项

- `name`（字符串）：你的 transformer 的唯一名称。
- `extensions`（字符串数组）：此 transformer 应应用的文件扩展名（例如 `['.md']`）。
- `transform`（函数）：接收文件对象并返回修改后文件的函数。

## 注册 Transformers

在你的 `nuxt.config.ts` 中注册 transformers：

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  content: {
    build: {
      transformers: [
        '~~/transformers/title-suffix',
        '~~/transformers/my-custom-transformer',
      ],
    },
  },
})
```

## 示例：添加元数据

Transformers 可以向文件添加一个 `__metadata` 字段。该字段不会存储到数据库中，但可用于运行时逻辑。

```ts [~~/transformers/component-metadata.ts]
import { defineTransformer } from '@nuxt/content'

export default defineTransformer({
  name: 'component-metadata',
  extensions: ['.md'],
  transform(file) {
    // 示例：检测是否使用了自定义组件
    const usesMyComponent = file.body?.includes('<MyCustomComponent>')
    return {
      ...file,
      __metadata: {
        components: usesMyComponent ? ['MyCustomComponent'] : [],
      },
    }
  },
})
```

**注意：** `__metadata` 字段仅在运行时可用，不会持久化到内容数据库中。

## API 参考

```ts
interface Transformer {
  name: string
  extensions: string[]
  transform: (file: ContentFile) => ContentFile
}
```

- `ContentFile` 是表示已解析内容文件的对象，包括 frontmatter、主体及其他字段。

## 使用 Transformers 支持新的文件格式

Transformers 不仅限于修改现有内容——它们还可以用于为 Nuxt Content 添加对新文件格式的支持。通过定义带有自定义 `parse` 方法的 transformer，你可以指示 Nuxt Content 如何读取和处理带有新扩展名的文件，如 YAML。

### 示例：YAML 文件支持

假设你想在内容目录中支持 `.yml` 和 `.yaml` 文件。你可以创建一个 transformer，解析 YAML frontmatter 和正文，并为这些扩展名注册它：

```ts [~~/transformers/yaml.ts]
import { defineTransformer } from '@nuxt/content'

export default defineTransformer({
  name: 'Yaml',
  extensions: ['.yml', '.yaml'],
  parse: (file) => {
    const { id, body } = file
    
    // 使用你喜欢的 YAML 解析器解析正文
    const parsed = parseYaml(body)

    return {
      ...parsed,
      id,
    }
  },
})
```

像注册其他 transformer 一样在 Nuxt 配置中注册你的 YAML transformer：

```ts
export default defineNuxtConfig({
  content: {
    build: {
      transformers: [
        '~~/transformers/yaml',
        // ...其他 transformers
      ],
    },
  },
})
```

此方法允许你扩展 Nuxt Content，以处理你需要的任意自定义文件格式。


# 介绍

## 新的 Nuxt Studio 模块

当 NuxtLabs 加入 Vercel 时，团队承诺会发布一个免费的开源、可自托管的 Nuxt 项目模块 [nuxt.studio](https://nuxt.studio){rel="&#x22;nofollow&#x22;"}。

::u-button
---
color: neutral
icon: i-simple-icons-github
target: _blank
to: https://github.com/nuxt-content/studio
variant: subtle
---
在 GitHub 上发现 Nuxt Studio 模块。
::

这个承诺现已兑现。感谢 Vercel 的支持，首个版本的 **Nuxt Studio 模块** 已发布。

您现在可以 **直接在生产环境中启用内容编辑**，实现实时预览和 GitHub 集成，所有操作均在您自己的 Nuxt 应用内完成。

::u-button
---
external: ""
color: neutral
icon: i-lucide-mouse-pointer-click
to: https://nuxt-content.zhcndoc.com/admin?redirect=/docs/studio/introduction
---
试试编辑此页面
::

## 它与独立平台有何不同？

Studio 最初作为托管平台提供，地址为 [nuxt.studio](https://nuxt.studio){rel="&#x22;nofollow&#x22;"}，现已发展为一个开源 Nuxt 模块，您可以将其部署在 Nuxt Content 网站旁。

这意味着内容编辑者可以直接在生产环境中管理和更新内容，无需本地开发工具或 Git 知识。

### 主要区别

- ✅ **自托管** — 完全运行在您自己的基础设施上
- ✅ **无外部依赖** — 不需要 API 或第三方服务
- ✅ **免费且开源** — 采用 MIT 许可发布
- ✅ **内置集成** — 直接在您的 Nuxt 应用中运行

::warning
新的 Nuxt Studio 模块需要服务端路由来进行身份验证。
尽管仍支持静态生成，但您的站点必须 

**部署在支持服务端渲染（SSR）的平台**

 上。
::


# 设置 Nuxt Studio

::note{to="https://nuxt.studio/docs/setup"}
本说明文档仅涵盖全新的开源 Nuxt Studio 模块。 :br
点击此处查看传统独立平台的文档。
::

## 安装

将 Nuxt Studio 模块添加到您的项目中：

::code-group
```bash [pnpm]
pnpm add nuxt-studio@alpha
```

```bash [npm]
npm install nuxt-studio@alpha
```

```bash [yarn]
yarn add nuxt-studio@alpha
```

```bash [bun]
bun add nuxt-studio@alpha
```
::

或者，使用 Nuxt CLI 自动添加模块：

```bash [Terminal]
npx nuxt module add nuxt-studio@beta
```

::tip{icon="i-lucide-rocket"}
启动您的开发服务器，开始编辑您的 Nuxt Content 网站。
::

## 开发模式

前面的步骤即可让您编辑内容。只需点击页面左下角的浮动按钮。

本地运行时，**任何文件更改都会与本地文件系统实时同步**。

::note
发布系统仅在生产模式下可用。请继续使用您当前的工作流程（git 命令、IDE、GitHub Desktop……）提交更改。
::

## 生产模式

Studio 的主要优势是可以直接从生产网站发布内容更改。此功能需要两个配置：

::steps
### Git 提供商

配置您的内容存储位置及提交变更的仓库：

  :::tip{to="https://nuxt-content.zhcndoc.com/docs/studio/git-providers"}
  了解更多关于 GitHub 和 GitLab 提供商的信息。
  :::

### 认证提供商

配置用户认证方式以访问 Studio。可选择 GitHub、GitLab、Google OAuth，或自定义认证：

  :::tip{to="https://nuxt-content.zhcndoc.com/docs/studio/auth-providers"}
  请按照您的认证提供商的完整安装指南操作。
  :::

### 部署

Nuxt Studio 需要服务器端路由来处理身份验证。

虽然通过 [Nuxt 混合渲染](https://nuxt.com/docs/4.x/guide/concepts/rendering#hybrid-rendering){rel=""nofollow""} 支持静态生成，但您的站点必须 **部署在支持服务器端渲染（SSR）** 的平台上，并使用 `nuxt build` 命令。

如果您想预渲染所有页面，可以使用如下配置：

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  nitro: {
    prerender: {
      // 预渲染首页
      routes: ['/'],
      // 然后爬取页面上的所有链接
      crawlLinks: true
    }
  }
})
```

## 配置

将模块添加到您的 `nuxt.config.ts` 并配置 GitHub 仓库：

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  studio: {
    // Studio 后台管理路由（默认：'/_studio'）
    route: '/_studio',
    
    // GitHub 仓库配置（必须指定 owner 和 repo）
    repository: {
      provider: 'github', // 目前仅支持 GitHub
      owner: 'your-username', // 您的 GitHub 用户名或组织
      repo: 'your-repo', // 您的仓库名称
      branch: 'main', // 提交的分支（默认：main）
      rootDir: '' // 可选：如果您的 Nuxt 应用在子目录（默认：''）
    }
  }
})
```

  :::callout
  如果您的 Nuxt Content 应用位于 monorepo 或子目录中，请指定 

  `rootDir`

   选项以指向正确的位置。
  :::

## GitHub OAuth 应用

Nuxt Studio 使用 GitHub OAuth 进行身份认证。

  :::prose-steps
  ### 访问 GitHub 开发者设置

  前往 [GitHub 开发者设置](https://github.com/settings/developers){rel=""nofollow""}，点击 **New OAuth App**（创建新的 OAuth 应用）

  ### 配置 OAuth 应用

  填写必填字段：

  - **Application name**（应用名称）：您的应用名称
  - **Homepage URL**（主页 URL）：`https://yourdomain.com`
  - **Authorization callback URL**（授权回调 URL）：`https://yourdomain.com`

    ::::note
    如果您想在本地试用 Studio，请将回调 URL 设置为本地地址 

    `http://localhost:3000`
    ::::

  ### 复制您的凭据

  创建 OAuth 应用后，您将获得：

  - **Client ID**（客户端 ID，立即可见）
  - **Client Secret**（客户端密钥，点击 **Generate a new client secret** 生成）

  ### 设置环境变量

  将 GitHub OAuth 凭据添加到您的部署平台的环境变量，或在本地的 `.env` 文件中添加：

  ```bash [.env]
  # Example with GitHub OAuth
  STUDIO_GITHUB_CLIENT_ID=<your_client_id>
  STUDIO_GITHUB_CLIENT_SECRET=<your_client_secret>
  ```

  ## 使用预发布/预览分支

  默认情况下，Studio 会将更改提交到配置指定的分支（通常是 `main`）。但是，您可以配置 Studio 使用预发布或预览分支。

  这对于您在合并到生产环境之前，在预览环境中审核更改非常有用。目前可以手动在 GitHub 上处理拉取请求，自动创建 PR 功能已经在规划中，将在未来版本中实现。

    ::::prose-steps
    ### 配置

    更新您的 `nuxt.config.ts`，指定使用预发布分支。

    ```ts [nuxt.config.ts]
    export default defineNuxtConfig({
      studio: {
        repository: {
          owner: 'your-username',
          repo: 'your-repo',
          branch: PROCESS.ENV.STUDIO_GITHUB_BRANCH_NAME, // 使用预发布分支代替 main
        }
      }
    })
    ```

      :::::tip
      您可以使用环境变量来管理不同环境的多个分支。
      :::::

    ### 部署

    配置您的托管平台将预发布分支部署到预览 URL（例如 `staging.yourdomain.com`）。

    ### 创建单独的 GitHub OAuth 应用

    专门为预发布环境创建一个新的 OAuth 应用：

    - **Application name**：您的应用名称（Staging）
    - **Homepage URL**：`https://staging.yourdomain.com`
    - **Authorization callback URL**：`https://staging.yourdomain.com`

    ### 设置环境变量

    为预发布部署配置预发布 OAuth 凭据及分支名称：

    ```bash [.env.staging]
    STUDIO_GITHUB_CLIENT_ID=<your_staging_github_client_id>
    STUDIO_GITHUB_CLIENT_SECRET=<your_staging_github_client_secret>
    STUDIO_GITHUB_BRANCH_NAME=<your_staging_branch_name>
    ```

    ### 访问预发布环境的 Studio

    访问 `https://staging.yourdomain.com/_studio` 进行内容编辑。所有提交将推送到您配置的预发布分支。

    ### 合并到生产

    当您对预发布分支上的更改满意后，创建来自预发布分支到主分支的拉取请求（PR），以部署到生产环境。

      :::::note
      **拉取请求自动化功能即将上线**

      :br

      未来版本计划实现 Studio 自动创建拉取请求功能。目前，您需要在 GitHub 手动创建 PR，将预发布更改合并到主分支。
      :::::

      :::::steps
      ### 访问 Studio

      部署完成后，通过访问配置的路由（默认：`/_studio`）打开 Studio 界面：

      1. 点击 **用 GitHub 登录**，如果未直接重定向到 OAuth 应用授权页面
      2. 授权 OAuth 应用
      3. 系统会重定向回 Studio，您即可开始编辑内容
      :::::
    ::::
  :::

  :::note
  基于 OAuth 的安全登录（包括 

  **Google**

   登录）将在 Beta 版本中快速推出。
  :::

  :::tip
  您还可以使用快捷键 :kbd{value="meta"} + :kbd{value="."} 快速跳转到 Studio 路由。
  :::

## 开发模式

Nuxt Studio 包含一个 **实验性** 的开发模式，支持实时文件系统同步：

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  studio: {
    development: {
      sync: true // 启用开发模式
    }
  }
})
```

启用后，Nuxt Studio 会：

- ✅ 直接写入您本地的 `content/` 目录中的更改
- ✅ 写入媒体文件更改到本地的 `public/` 目录
- ❌ 监听文件系统变化并更新编辑器
- ❌ 提交更改至您的仓库（请继续使用传统工作流程提交）

#### 目录根路径 `默认值: ''`

如果您的 Nuxt Content 应用位于 monorepo 或子目录中，请指定 `rootDir` 选项以指向正确的位置：

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  studio: {
    repository: {
      ...
      rootDir: 'docs'
    }
  }
})
```

#### 私有仓库访问 `默认值: true`

默认情况下，Studio 会请求访问公共和私有仓库。

若设置 `private: false`，则 OAuth 认证范围仅限公共仓库，这在处理公共仓库时出于安全或合规考虑可能更合适：

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  studio: {
    repository: {
      ...
      private: false
    }
  }
})
```

### 国际化

Nuxt Studio 内置多语言支持，当前可用语言包括：

- 🇬🇧 **英语**（默认）
- 🇸🇦 **阿拉伯语**
- 🇧🇬 **保加利亚语**
- 🇩🇪 **德语**
- 🇪🇸 **西班牙语**
- 🇮🇷 **波斯语**
- 🇫🇮 **芬兰语**
- 🇫🇷 **法语**
- 🇮🇩 **印尼语**
- 🇮🇹 **意大利语**
- 🇯🇵 **日语**
- 🇳🇱 **荷兰语**
- 🇵🇱 **波兰语**
- 🇧🇷 **巴西葡萄牙语**
- 🇺🇦 **乌克兰语**
- 🇨🇳 **中文**

通过在 `nuxt.config.ts` 中添加 `i18n` 选项来设置您偏好的语言：

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  studio: {
    i18n: {
      defaultLocale: 'fr' // 可选 'en'、'fr' 或 'de'
    }
  }
})
```

语言包将翻译：

- 所有界面元素和标签
- Monaco 编辑器的代码片段和自动完成
- 上下文消息和通知

  :::callout{icon="i-lucide-heart-handshake"}
  欢迎社区贡献新的语言翻译！如果您想新增支持的语言，请访问 

  [GitHub 仓库](https://github.com/nuxt-content/studio){rel=""nofollow""}

   并提交 Pull Request。
  :::

### 开发模式

如果想在本地测试生产环境配置，请禁用开发模式：

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  studio: {
    dev: false
  }
})
```

确保您配置的 OAuth 提供商的回调地址指向本地开发服务器（通常是 <http://localhost:3000>{rel=""nofollow""}）。
::


# Git 提供商

Git 提供商负责 Studio 与您的仓库之间的同步。当您从 Studio 发布时，它们负责**将内容更改（提交）推送**到您的 Git 仓库。

::prose-note{to="https://nuxt-content.zhcndoc.com/docs/studio/auth-providers"}
Git 提供商不同于

**认证提供商**

。Git 提供商决定您的仓库托管位置并允许您发布内容更改，而认证提供商控制用户如何认证并访问 Studio。
::

## 支持的提供商

Studio 支持两个用于仓库操作的 Git 提供商：GitHub 和 GitLab。

### GitHub

若要使用 GitHub 作为您的 Git 提供商，请在 `nuxt.config.ts` 中配置您的仓库设置：

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  studio: {
    repository: {
      provider: 'github',
      owner: 'your-username',
      repo: 'your-repo',
      branch: 'main' // 可选，默认值为 'main'
    }
  }
})
```

#### 创建 GitHub 个人访问令牌

::warning
如果您使用的

[认证提供商](https://nuxt-content.zhcndoc.com/docs/studio/auth-providers)

不提供 Git 访问权限（如 Google OAuth 或自定义认证），则需要创建个人访问令牌来发布您的更改。
::

::prose-steps{level="4"}
#### 进入 GitHub 令牌设置页面

访问 [GitHub 设置 → 个人访问令牌](https://github.com/settings/personal-access-tokens/new){rel=""nofollow""}，并创建新的**细粒度个人访问令牌**。

#### 配置 GitHub 令牌

填写以下必填项：

- **令牌名称**：您的应用名称
- **资源拥有者**：仓库所属的 GitHub 组织（或用户）
- **仓库访问**：选择**仅选择特定仓库**，然后选择您的仓库
- **权限**：点击**添加权限**，选择**内容（Contents）**，将访问权限更新为**读写**

#### 设置 GitHub 环境变量

将令牌添加到您的部署平台的环境变量中：

```bash [.env]
STUDIO_GITHUB_TOKEN=<your_github_personal_access_token>
```
::

### GitLab

若要使用 GitLab 作为您的 Git 提供商，请在 `nuxt.config.ts` 中配置您的仓库设置：

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  studio: {
    repository: {
      owner: 'your-username', // 或者群组名称
      repo: 'your-repo',
      branch: 'main' // 可选，默认值为 'main'
    }
  }
})
```

#### 创建 GitLab 个人访问令牌

::warning
如果您使用的

[认证提供商](https://nuxt-content.zhcndoc.com/docs/studio/auth-providers)

不提供 Git 访问权限（如 Google OAuth 或自定义认证），则需要创建个人访问令牌来发布您的更改。
::

::prose-steps{level="4"}
#### 进入 GitLab 令牌设置页面

访问 GitLab 的**用户设置 → 个人访问令牌**（或者您的群组/组织设置页面，如果适用）。

#### 配置 GitLab 令牌

填写以下必填项：

- **名称**：您的应用名称
- **过期日期**：根据您的安全策略设置（GitLab 默认 365 天，大多数实例不允许无过期令牌）。请参阅 [GitLab 关于过期限制的说明](https://docs.gitlab.com/user/profile/personal_access_tokens/){rel=""nofollow""}。
- **权限范围（Scopes）**：选择 `api`（用于读写仓库内容） :warning[请立即复制生成的令牌，生成后无法再次查看。]

#### 设置 GitLab 环境变量

将令牌添加到您的部署平台的环境变量中：

```bash [.env]
STUDIO_GITLAB_TOKEN=<your_gitlab_personal_access_token>
```
::

## 发布要求

要将内容更改发布到您的仓库，Studio 需要一个具有写权限的有效访问令牌。该令牌来源有两种情况：

### 基于 OAuth 的访问（自动）

当您使用 **GitHub OAuth** 或 **GitLab OAuth** 作为[认证提供商](https://nuxt-content.zhcndoc.com/docs/studio/auth-providers)时，认证过程中获取的 OAuth 令牌会被自动用于 Git 操作，无需额外配置。

```bash [.env]
# GitHub OAuth - 令牌在登录时自动获取
STUDIO_GITHUB_CLIENT_ID=<your_github_client_id>
STUDIO_GITHUB_CLIENT_SECRET=<your_github_client_secret>

# 或 GitLab OAuth - 令牌在登录时自动获取
STUDIO_GITLAB_APPLICATION_ID=<your_gitlab_application_id>
STUDIO_GITLAB_CLIENT_SECRET=<your_gitlab_secret>
```

### 个人访问令牌（手动）

当您使用 **Google OAuth** 或 **自定义认证** 作为认证提供商时，必须提供带有仓库写权限的个人访问令牌（PAT）：

```bash [.env]
# 针对 GitHub 仓库
STUDIO_GITHUB_TOKEN=<your_github_personal_access_token>

# 针对 GitLab 仓库
STUDIO_GITLAB_TOKEN=<your_gitlab_personal_access_token>
```

::warning
个人访问令牌必须具有仓库的写权限。否则，通过 Google OAuth 或自定义认证登录的用户将无法发布更改。
::

## 分支管理

默认情况下，Studio 会将更改提交到您配置文件中指定的分支（通常是 `main`）。但您也可以配置 Studio 使用预发布或预览分支。

这在您希望先在预览环境中审核更改，然后再合并到生产环境时非常有用。

::prose-steps
### 配置您的分支

更新 `nuxt.config.ts`，将分支指向您的预发布分支。

  :::tip
  您可以使用环境变量来管理不同环境的多个分支。
  :::

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  studio: {
    repository: {
      owner: 'your-username',
      repo: 'your-repo',
      branch: process.env.STUDIO_BRANCH_NAME || 'main'
    }
  }
})
```

### 部署您的预发布环境

配置您的托管平台，将预发布分支部署到预览 URL（例如 `staging.yourdomain.com`）。

### 配置预发布的认证提供商

专门为预发布环境创建一个 OAuth 应用，使用您的预发布 URL 作为回调地址。设置说明请参见[认证提供商](https://nuxt-content.zhcndoc.com/docs/studio/auth-providers)。

### 设置环境变量

根据您使用的 Git 和认证提供商，配置预发布环境的环境变量。

### 访问预发布环境中的 Studio

访问 `https://staging.yourdomain.com/_studio` 编辑内容。所有提交都会推送到您配置的预发布分支。

### 合并到生产环境

当您满意预发布分支上的更改后，创建从预发布分支到主分支的拉取请求（Pull Request），以部署到生产环境。

  :::note
  **拉取请求自动化功能即将上线**

  :br

  未来版本计划支持从 Studio 自动创建拉取请求。目前需要手动创建 PR 来将预发布更改合并到主分支。
  :::
::


# 认证提供者

认证提供者负责 **用户身份验证** 和 Studio 的访问控制。它们决定谁可以登录和编辑内容。

::prose-note
认证提供者不同于 

[Git 提供者](https://nuxt-content.zhcndoc.com/docs/studio/git-providers)

。认证提供者处理用户身份验证，而 Git 提供者处理仓库操作。
::

## 提供者对比

| 功能         | GitHub OAuth   | GitLab OAuth   | Google OAuth     | 自定义认证            |
| ---------- | -------------- | -------------- | ---------------- | ---------------- |
| **身份验证**   | ✅              | ✅              | ✅                | ✅                |
| **Git 操作** | ✅ 自动（OAuth 令牌） | ✅ 自动（OAuth 令牌） | ⚠️ 需要个人访问令牌（PAT） | ⚠️ 需要个人访问令牌（PAT） |
| **访问控制**   | ✅ OAuth 作用域    | ✅ OAuth 作用域    | ⚠️ 管理员白名单        | ⚠️ 自定义逻辑         |
| **安全认证流程** | ✅ 提供者管理        | ✅ 提供者管理        | ✅ 提供者管理          | ⚠️ 自行管理          |

::note
您可以同时使用多个提供者。例如，开发人员使用 GitHub OAuth，非技术内容编辑使用 Google OAuth。
::

## 内置提供者

### GitHub

GitHub OAuth 提供身份验证并自动实现 Git 访问。通过 GitHub 认证的用户可以立即推送更改到仓库。

::prose-steps{level="4"}
#### 进入 GitHub 开发者设置

访问 [GitHub 开发者设置](https://github.com/settings/developers){rel=""nofollow""}，点击 **New OAuth App**

#### 配置 GitHub OAuth 应用

填写必填字段：

- **应用名称**：您的应用名称
- **主页 URL**：`https://yourdomain.com`
- **授权回调 URL**：`https://yourdomain.com/__nuxt_studio/auth/github`

  :::note
  本地开发时添加：

  `http://localhost:3000/__nuxt_studio/auth/github`
  :::

#### 复制 GitHub 凭据

创建 OAuth 应用后，您将获得：

- **客户端 ID**（立即可见）
- **客户端密钥**（点击 **Generate a new client secret** 获取）

#### 配置 GitHub 环境变量

将 GitHub OAuth 凭据添加到您的部署平台环境变量或 `.env` 文件：

```bash [.env]
STUDIO_GITHUB_CLIENT_ID=<your_github_client_id>
STUDIO_GITHUB_CLIENT_SECRET=<your_github_client_secret>
# 可选：限制特定用户访问
# STUDIO_GITHUB_MODERATORS=admin@example.com,editor@example.com
```
::

### GitLab

GitLab OAuth 提供身份验证并自动实现 Git 访问。通过 GitLab 认证的用户可以立即推送更改到仓库。

::prose-steps{level="4"}
#### 进入 GitLab 应用页面

访问 GitLab 的 [用户设置 → 应用](https://gitlab.com/-/user_settings/applications){rel=""nofollow""}（或您的群组/组织设置），创建一个 **新建应用程序**。

#### 配置 GitLab OAuth 应用

填写必填字段：

- **应用名称**：您的应用名称
- **重定向 URI**：`https://yourdomain.com/__nuxt_studio/auth/gitlab`
- **作用域**：选择 `api`（发布必需）

  :::note
  本地开发时添加：

  `http://localhost:3000/__nuxt_studio/auth/gitlab`
  :::

#### 复制 GitLab 凭据

创建 OAuth 应用后，您将获得：

- **应用 ID**（立即可见）
- **密钥**（立即可见）

#### 配置 GitLab 环境变量

将 GitLab OAuth 凭据添加到您的部署平台环境变量或 `.env` 文件：

```bash [.env]
STUDIO_GITLAB_APPLICATION_ID=<your_gitlab_application_id>
STUDIO_GITLAB_CLIENT_SECRET=<your_gitlab_secret>
# 可选：限制特定用户访问
# STUDIO_GITLAB_MODERATORS=admin@example.com,editor@example.com
```
::

### Google

Google OAuth 适合没有 GitHub 或 GitLab 账号的非技术用户。

::prose-steps{level="4"}
#### 进入 Google Cloud 控制台

访问 [Google Cloud 控制台](https://console.cloud.google.com/){rel=""nofollow""}，选择或创建一个项目，导航至 **API 与服务 → 凭据**。

#### 创建 OAuth 应用

点击 **创建凭据**，选择 **OAuth 客户端 ID**，应用类型选择 **Web 应用**。

填写必填字段：

- **名称**：您的应用名称
- **授权重定向 URI**：`https://yourdomain.com/__nuxt_studio/auth/google`

  :::note
  本地开发时添加：

  `http://localhost:3000/__nuxt_studio/auth/google`
  :::

创建 OAuth 客户端后，您将获得：

- **客户端 ID**
- **客户端密钥**

  :::warning
  请立即保存这些凭据，可能无法再次查看。
  :::

#### 创建个人访问令牌

由于 Google 不支持 Git 访问，您还必须配置一个 [个人访问令牌](https://nuxt-content.zhcndoc.com/docs/studio/git-providers#creating-a-personal-access-token) 用于仓库操作。

#### 配置环境变量

添加 Google OAuth 凭据、个人访问令牌及管理员列表：

  :::tabs
    ::::tabs-item{icon="i-lucide-github" label="使用 GitHub 仓库"}
    ```bash [.env]
    STUDIO_GOOGLE_CLIENT_ID=<your_google_client_id>
    STUDIO_GOOGLE_CLIENT_SECRET=<your_google_client_secret>
    STUDIO_GITHUB_TOKEN=<your_github_personal_access_token>
    STUDIO_GOOGLE_MODERATORS=admin@example.com,editor@example.com
    ```
    ::::

    ::::tabs-item{icon="i-lucide-gitlab" label="使用 GitLab 仓库"}
    ```bash [.env]
    STUDIO_GOOGLE_CLIENT_ID=<your_google_client_id>
    STUDIO_GOOGLE_CLIENT_SECRET=<your_google_client_secret>
    STUDIO_GITLAB_TOKEN=<your_gitlab_personal_access_token>
    STUDIO_GOOGLE_MODERATORS=admin@example.com,editor@example.com
    ```
    ::::
  :::

  :::warning
  `STUDIO_GOOGLE_MODERATORS`

   环境变量对 Google OAuth 

  **必填**

  。只有列表中的邮箱用户能访问 Studio。
  :::
::

## 自定义认证

若需完全掌控身份认证，可使用 Studio 会话工具实现自己的认证逻辑（密码表单、SSO、LDAP 等）。

::warning{title="安全责任"}
使用自定义认证时，

**您需自行负责保护认证流程的安全**

。Studio 仅管理用户通过认证后的会话。
::

### 需要个人访问令牌

您必须基于所用 Git 提供者配置个人访问令牌以支持仓库操作。

```bash [.env]
# 针对 GitHub 仓库
STUDIO_GITHUB_TOKEN=<your_github_personal_access_token>

# 针对 GitLab 仓库
STUDIO_GITLAB_TOKEN=<your_gitlab_personal_access_token>
```

详细创建说明见 [Git 提供者](https://nuxt-content.zhcndoc.com/docs/studio/git-providers#creating-a-personal-access-token)。

### 实现流程

1. 在登录处理器中**验证用户**，可使用密码、SSO 等任意方法
2. 调用 `setStudioUserSession(event, user)`，传入 `StudioUserSession` 对象以**创建会话**
3. 调用 `clearStudioUserSession(event)` 处理登出，清除会话

### 必填会话字段

调用 `setStudioUserSession` 时，必须提供：

| 字段           | 类型       | 必填 | 描述          |
| ------------ | -------- | -- | ----------- |
| `name`       | `string` | ✅  | 用户显示名称      |
| `email`      | `string` | ✅  | 用户邮箱        |
| `providerId` | `string` | ❌  | 用户的唯一标识符    |
| `avatar`     | `string` | ❌  | 用户头像图片的 URL |

### 示例：基于密码的登录

```ts [server/api/studio/login.ts]
import { eventHandler, readBody, createError } from 'h3'
import { setStudioUserSession } from '#imports'

export default eventHandler(async (event) => {
  const { email, password } = await readBody<{ email?: string, password?: string }>(event)

  // ⚠️ 在此实现您自己的安全验证逻辑
  // 本示例简单示范，请使用安全的密码哈希和验证
  const user = await validateCredentials(email, password)

  if (!user) {
    throw createError({
      statusCode: 401,
      message: '无效的凭据'
    })
  }

  await setStudioUserSession(event, {
    providerId: user.id,
    name: user.name,
    email: user.email,
    avatar: user.avatar || ''
  })

  return { ok: true }
})
```

### 示例：登出处理

```ts [server/api/studio/logout.ts]
import { eventHandler } from 'h3'
import { clearStudioUserSession } from '#imports'

export default eventHandler(async (event) => {
  await clearStudioUserSession(event)
  return { ok: true }
})
```

### 登录后重定向

成功设置会话后，将用户重定向至应用根路径（`/`）。Studio 会自动检测会话并为该用户激活。

```ts [server/api/studio/login.ts]
// 调用 setStudioUserSession 后...
return sendRedirect(event, '/')
```

## 高级选项

### 通过管理员列表控制访问

您可以通过 `STUDIO_{PROVIDER}_MODERATORS` 环境变量定义授权用户白名单，限制 Studio 访问。

```bash [.env]
# GitHub OAuth 管理员
STUDIO_GITHUB_MODERATORS=admin@example.com,editor@example.com

# GitLab OAuth 管理员
STUDIO_GITLAB_MODERATORS=admin@example.com,editor@example.com

# Google OAuth 管理员（必填）
STUDIO_GOOGLE_MODERATORS=admin@example.com,editor@example.com
```

管理员列表为逗号分隔的邮箱地址。只有列表中的邮箱用户被允许访问。

#### 不同提供者行为

| 提供者          | 管理员列表  | 行为说明                    |
| ------------ | ------ | ----------------------- |
| GitHub OAuth | 可选     | 为空时，所有通过 OAuth 认证用户均可访问 |
| GitLab OAuth | 可选     | 为空时，所有通过 OAuth 认证用户均可访问 |
| Google OAuth | **必填** | 无管理员列表时，无人可访问 Studio    |
| 自定义认证        | 不适用    | 自行实现访问控制逻辑              |

::note
GitHub 和 GitLab OAuth 中，仓库写权限依然受 OAuth 作用域控制，即使用户可访问 Studio，也无法未经授权推送更改。
::

### 自定义重定向 URL

默认情况下，Studio 使用您的部署 URL 作为 OAuth 回调地址。如需自定义：

```bash [.env]
# GitHub OAuth
STUDIO_GITHUB_REDIRECT_URL=https://custom-domain.com/__nuxt_studio/auth/github

# GitLab OAuth
STUDIO_GITLAB_REDIRECT_URL=https://custom-domain.com/__nuxt_studio/auth/gitlab

# Google OAuth
STUDIO_GOOGLE_REDIRECT_URL=https://custom-domain.com/__nuxt_studio/auth/google
```

::note
当您需要通过特定端点处理 OAuth 回调（如反向代理或自定义域名路由）时，此配置非常有用。
::

---

::tip
完成凭据配置并部署后，Studio 将可通过您的生产实例访问。访问 

`/_studio`

（或您配置的路由）即可开始编辑和发布内容。
::


# 编辑您的内容

::note
**测试版发布 - 所有编辑器现已可用！**

:br

测试版现在包含 **TipTap 可视化编辑器**（默认）、**Monaco 代码编辑器** 以及针对 YAML/JSON 文件和 frontmatter 的新 **基于表单的编辑器**。您可以随时通过工具栏中的编辑器模式切换在它们之间切换。
::

Nuxt Studio 为开发者和内容编辑者提供一个多功能的工作空间，赋予他们在不同编辑器间选择的自由：

- 针对 `Markdown` 文件的 [类似 Notion 的编辑器](https://nuxt-content.zhcndoc.com/#notion-like-editor-markdown-files)
- 针对 `YAML` 和 `JSON` 文件的 [表单编辑器](https://nuxt-content.zhcndoc.com/#form-editor)
- 针对所有类型文件的 [代码编辑器](https://nuxt-content.zhcndoc.com/#code-editor)（仅限技术用户）

每种编辑器都有其用途。一些用户偏好可视化编辑，而另一些则偏好直接操作代码。最终，**Markdown 和 MDC 语法是两种编辑器的最终输出**，并支持可视化与代码模式之间的无缝转换。

## 编辑器模式切换

您可以随时点击文件标题栏（面包屑右侧）的 **操作下拉菜单**，在可视化编辑器和代码编辑器之间切换：

- **可视化模式** - 针对 Markdown 的类似 Notion 编辑体验，以及针对 YAML/JSON 文件的表单编辑器。
- **代码模式**（Monaco） - 直接编辑 Markdown/MDC 语法

您的偏好将被保存，且适用于所有文件。

## TipTap 可视化编辑器（`Markdown` 文件）

TipTap 可视化编辑器为 Markdown 内容提供了现代化的类似 Notion 的编辑体验，基于流行的 [TipTap](https://tiptap.zhcndoc.com/){rel="&#x22;nofollow&#x22;"} 编辑器，并由 [Nuxt UI Editor](https://ui.nuxt.com/pro/components/editor){rel="&#x22;nofollow&#x22;"} 集成。

### 主要特性

- **富文本编辑** - 支持标题、加粗、斜体、删除线、代码、链接等格式
- **MDC 组件支持** - 可在可视化编辑器中直接插入和编辑自定义 Vue 组件
- **媒体集成** - 通过媒体选择器浏览并插入库中的图片
- **表情集成** - 输入 `:` 后接表情名称插入表情，或使用斜杠命令 `/emoji`
- **斜杠命令** - 输入 `/` 可访问格式和组件菜单
- **拖拽功能** - 拖动内容块进行重排
- **链接编辑器** - 浮动弹出层支持外部链接编辑
- **工具栏** - 文本选中时显示气泡工具栏，快速访问格式选项
- **实时转换** - 实现可视化内容与 MDC/Markdown 语法之间的无缝转换

### 使用 Vue 组件

TipTap 可视化编辑器的突出功能之一，是其可以直接在编辑器界面中集成和编辑自定义 Vue 组件。

#### 创建并集成自定义组件

开发者可以创建视觉复杂的组件，编辑者无需技术知识即可使用它们。可视化编辑器能无缝处理组件集成。

::steps{level="4"}
#### 创建您的组件

Vue 组件需放置在 `/components/content` 文件夹内，才可在 Studio 中使用：

```vue [components/content/HomeFeature.vue]
<template>
  <div class="flex items-start gap-3">
    <div class="flex items-center justify-center border rounded-lg p-1.5">
      <UIcon :name="icon" />
    </div>
    <div class="flex flex-col">
      <h3 class="font-semibold">
        <slot name="title" />
      </h3>
      <span>
        <slot name="description" />
      </span>
    </div>
  </div>
</template>

<script setup lang="ts">
defineProps({
  icon: {
    type: String,
    default: 'i-lucide-cursor-click',
  },
})
</script>
```

#### 在 Markdown 中使用 MDC 语法集成组件

组件可通过 [MDC 语法](https://nuxt-content.zhcndoc.com/docs/files/markdown#mdc-syntax) 集成：

```mdc [content/index.md]
::home-feature
  ---
  icon: i-mdi-vuejs
  ---
  #title
  嵌入的 Vue 组件
  #description
  在可视化编辑器中编辑插槽和属性。
::
```

#### 在可视化编辑器中编辑

`/components/content` 文件夹中的所有组件会自动生效：

1. 在编辑时任何位置输入 `/`
2. 在列表中搜索您的组件
3. 直接在编辑器中插入并编辑组件插槽
4. 属性编辑的可视化界面将在测试版中推出
::

#### 集成外部库组件

默认情况下，来自外部库（如 Nuxt UI）的组件不会显示在 Studio 组件列表中。要让它们可用，请在 Nuxt 配置中设置为全局组件：

```ts
export default defineNuxtConfig({
  hooks: {
    'components:extend': (components) => {
      const globals = components.filter(c => ['UButton', 'UIcon'].includes(c.pascalName))

      globals.forEach(c => c.global = true)
    }
  },
})
```

### 调试模式

可从底部菜单开启 **调试模式**，查看以下格式的实时转换：

- TipTap JSON 格式
- MDC AST
- 最终 Markdown 输出

这对于理解内容如何转换及共享故障排查信息非常有用。

## 表单编辑器

表单编辑器适用于编辑：

- `Markdown` 文件中的 **Frontmatter**
- **YAML** 文件
- **JSON** 文件

无需直接操作复杂的文件语法，而是根据您的 [集合 schema](https://nuxt-content.zhcndoc.com/docs/collections/define) 定义自动生成表单。

### **使用** `zod` **Schema 定义您的表单**

::prose-note{to="https://nuxt-content.zhcndoc.com/docs/collections/define"}
在专门章节中了解更多关于 schema 集合定义。
::

一旦在您的集合中定义了 `schema` 属性，Studio 界面将自动生成对应表单。

::prose-code-group
```ts [content.config.ts]
export default defineContentConfig({
  collections: {
    posts: defineCollection({
      type: 'page',
      source: 'blog/*.md',
      schema: z.object({
        draft: z.boolean().default(false),
        category: z.enum(['Alps', 'Himalaya', 'Pyrenees']).optional(),
        date: z.date(),
        image: z.object({
          src: property(z.string()).editor({ input: 'media' }),
          alt: z.string(),
        }),
        slug: property(z.string()).editor({ hidden: true }),
        icon: property(z.string().optional()).editor({ input: 'icon' }),
        authors: z.array(z.object({
          slug: z.string(),
          username: z.string(),
          name: z.string(),
          to: z.string(),
          avatar: z.object({
            src: z.string(),
            alt: z.string(),
          }),
        })),
      }),
    }),
  },
})
```

  :::code-preview{icon="i-lucide-eye" label="生成的表单"}
  ![表单预览](https://nuxt-content.zhcndoc.com/docs/studio/preview-schema.png)
  :::
::

### **原生输入映射**

基础的 Zod 类型会自动映射为合适的表单输入：

- **String（字符串）** → 文本输入框
- **Date（日期）** → 日期选择器 :badge[敬请期待]
- **Number（数字）** → 数字输入框 :badge[敬请期待]
- **Boolean（布尔）** → 开关控件 :badge[敬请期待]
- **Enum（枚举）** → 下拉选择框 :badge[敬请期待]
- **字符串数组** → 徽章输入列表
- **对象数组** → 带嵌入表单的小折叠面板列表

:video{autoplay controls loop poster="https://res.cloudinary.com/nuxt/video/upload/v1740679550/arrayobjectandstring_r1jpvz.jpg" src="https://res.cloudinary.com/nuxt/video/upload/v1740679550/arrayobjectandstring_r1jpvz.mp4"}

### 自定义输入映射 :badge[敬请期待]

Studio 超越了基础类型，您可使用 `editor` 方法自定义表单字段，该方法为 Zod 类型扩展了元数据，增强编辑器界面功能。

这允许您定义自定义输入控件或隐藏字段。

#### 用法

```ts [content.config.ts]
// 图标
icon: property(z.string()).editor({ input: 'icon', iconLibraries: ['lucide', 'simple-icons'] })

// 媒体
image: property(z.string()).editor({ input: 'media' })
```

#### 选项

##### `input: 'media' | 'icon'`

设置编辑器输入类型。目前支持 `icon` 和 `media`。

##### `iconLibraries: Array<string>`

指定显示哪些 [Iconify](https://icones.js.org/){rel="&#x22;nofollow&#x22;"} 库。使用此选项可筛选并限制可用图标集。

`hidden: Boolean`

此选项可用于在 Studio 编辑器中隐藏某字段的显示。

::prose-tip
Studio 输入控件完全可扩展。我们可以根据用户需求创建任意多的输入控件。
::

## 代码编辑器

Monaco 代码编辑器让您全面掌控内容，允许您直接编写原始内容：

针对 `Markdown` 文件使用 MDC 语法；针对其他文件使用 `JSON` 或 `YAML` 语法。


# 在 Nuxt Content Studio CMS 中管理和整合媒体

## 浏览您的媒体

所有位于 `/public` 目录下的媒体都可以在 Studio 平台的 **媒体** 标签页中访问。

这是一个为非技术用户设计的直观界面，用于管理他们的 `/public` 目录。

用户可以轻松浏览文件夹，在任意层级上传新媒体，并通过拖放操作将媒体移动到其他文件夹，从而简化媒体的组织工作。

该界面旨在为非技术用户提供直观体验，可视为一种用户友好的集成开发环境（IDE）。

## 在类似 Notion 的编辑器中使用

TipTap 可视化编辑器提供无缝的媒体集成：

- **拖放操作** - 只需将图片直接拖放到编辑器中。上传模态窗口会打开，让您选择目标文件夹 :badge[即将推出]
- **斜杠命令** - 输入 `/` 并搜索 `Image`，即可快速插入媒体。一个模态窗口会打开，让您从媒体库中选择媒体
- **替代文本支持** - 在媒体模态窗口中，您可以设置用于 SEO 和无障碍访问的 [alt 属性](https://www.w3schools.com/tags/att_img_alt.asp){rel="&#x22;nofollow&#x22;"} :badge[即将推出]

## 支持的文件类型

媒体库支持广泛的文件类型：

- **图像**：JPEG、PNG、GIF、WebP、AVIF、SVG
- **视频**：MP4、WebM


# 路线图

此路线图概述了自托管 Nuxt Studio 模块的开发阶段。我们致力于构建一个强大的开源内容管理系统，专为 Nuxt Content 网站打造。

::prose-note
此路线图可能会根据社区反馈和优先级调整而变化。欢迎加入 

[GitHub 讨论区](https://github.com/nuxt-content/studio/discussions){rel=""nofollow""}

 或 

[加入 Discord](https://discord.gg/sBXDm6e8SP){rel=""nofollow""}

 一起助力 Nuxt Studio 的未来发展。
::

## 当前状态：Beta 发布

::badge
v1.0.0-beta - 当前版本
::

Beta 版本专注于核心功能和稳定性。Beta 现包含 TipTap 可视化编辑器（默认）、Monaco 代码编辑器以及用于 YAML/JSON 文件和 Frontmatter 的新表单编辑器，提供针对所有内容类型支持 MDC 组件的完整编辑体验。

## 发布阶段

### ✅ 第一阶段 - Alpha

**重点**：核心基础设施、文件操作和 GitHub 集成

::prose-steps{level="4"}
#### 内容编辑器

专业编辑体验，包含 TipTap 可视化编辑器（默认）、Monaco 代码编辑器和表单编辑器。

#### 表单编辑器

基于架构的表单，用于编辑 Markdown 文件中的 Frontmatter、YAML 和 JSON 文件。

#### 文件操作

对 `content/` 目录下的内容文件支持完整的增删查改操作。

#### 媒体管理

集中式媒体库，管理 `public/` 目录的资源，支持 AVIF 格式。

#### Git 集成

直接向 GitHub 提交，具备完整版本控制功能。

#### 实时预览

在生产网站上实时预览变更内容。

#### 国际化 (i18n)

支持 Studio 界面的多语言（16 种语言：阿拉伯语、保加利亚语、德语、英语、西班牙语、波斯语、芬兰语、法语、印尼语、意大利语、日语、荷兰语、波兰语、巴西葡萄牙语、乌克兰语、中文）。

#### GitLab 集成

支持 GitLab 作为 Git 提供商，除 GitHub 外的另一选择。

#### 开发模式

支持本地开发，无需身份验证。

#### Google OAuth 认证

为非 GitHub 用户提供另一认证方式。
::

### 🚧 第二阶段 - Beta :badge[当前]

**重点**：高级组件管理

Beta 阶段将引入增强的组件编辑能力。

::prose-steps{level="4"}
#### Vue 组件属性编辑器

用于编辑 Vue 组件属性的可视化界面。

**状态：** 🚧 开发中

#### 自定义 OAuth

提供工具供用户自行处理认证。

**状态：** 🚧 开发中
::

### 🔮 第三阶段 - 稳定版发布

**重点**：生产环境准备及高级功能

**目标发布时间**：2025 年底

稳定版将包括性能优化及适合生产环境的功能。

### 🌟 第四阶段 - 高级功能（未来）

**重点**：AI 集成、集合视图及社区功能

**目标发布时间**：2026 年

长期愿景为拓展 Studio 功能并整合 AI 驱动的内容推荐。


# 同步

本页介绍 Nuxt Studio 如何在浏览器（您的生产网站）和 GitHub 仓库之间保持内容同步。

::prose-note
本节为信息说明。同步在设置后自动进行，无需手动操作。
::

## 架构概述

自托管的 Nuxt Studio 模块使用三层存储系统：

### 生产数据库（SQLite WASM）

当应用在浏览器加载时，Nuxt Content v3 会从服务器下载 SQLite 数据库转储文件并初始化本地 WASM 数据库。\:br :br
该本地数据库包含您已部署分支中 `content/` 目录的所有内容。

::warning
只要您最近的一次部署构建成功且 CI/CD 管道无错误，此浏览器端数据库就会与 GitHub 保持同步。
::

### 草稿存储（IndexedDB）

Studio 使用 [unstorage](https://unstorage.unjs.io/){rel="&#x22;nofollow&#x22;"} 维护一个独立的**草稿层**，后端存储为 IndexedDB。\:br :br
当您编辑内容时，变更会被存储为该层中的*草稿*。\:br :br
每次 Studio 应用加载时，这些草稿会与 SQLite 数据库合并，以渲染您生产网站的*草稿版*。

::note
草稿只存储在您本地浏览器中，不会在编辑者或设备间共享。
::

### GitHub 仓库

发布时，Studio 通过 GitHub API 直接将您的草稿更改提交到 GitHub 仓库。\:br :br
随后您的 CI/CD 管道会自动重建并重新部署您的网站。

::warning
部署完成后，您需要等待构建成功完成，然后刷新网站，以使用最新内容更新浏览器数据库。
::

::tip
当检测到新部署时，Studio 模块会自动通知您。
::

## 同步工作原理

### 初始加载

::prose-steps{level="4"}
#### 数据库初始化

Nuxt Content 下载构建过程中生成的 SQLite 数据库转储文件。\:br :br
该文件包含您 `content/` 目录的所有解析内容。

#### 草稿恢复

Studio 检查 IndexedDB 是否存在之前会话的草稿，将其加载进 SQLite 数据库。

#### 预览

Studio 刷新网站预览，让您直接在生产网站上查看最新草稿和编辑内容。
::

### 编辑内容

当您在 Studio 中修改内容时：

::prose-steps{level="4"}
#### 草稿修改

变更会立即以状态为 `created`、`modified` 或 `deleted` 的草稿项目形式保存至 IndexedDB。

#### 数据库更新

本地 SQLite 数据库同步更新草稿内容，实现即时视觉预览。

#### 冲突检测

Studio 会将您的草稿内容与 GitHub 上的最新版本进行比较，以检测可能的冲突。

发生冲突的情况包括：

- 有人推送了修改相同文件的提交，且该版本正在构建中。
- 部署失败或尚未完成，导致生产数据库过期且与 GitHub 不同步。
::

### 发布更改

当您发布编辑内容时：

::prose-steps{level="4"}
#### 草稿收集

Studio 收集所有包含变更的草稿项目。

#### GitHub 提交

通过 GitHub API，Studio 创建包含所有更新文件的新提交。

#### 触发部署

您的 CI/CD 平台检测到提交，自动重建并重新部署网站。

#### 部署等待

发布后，Studio 清除本地草稿，并等待部署完成。\:br :br
此期间显示加载状态，直至生产 SQLite 数据库跟上您最新的提交。

  :::warning
  在提交部署前，Studio 会保持待定状态，此时生产数据库尚未更新。
  :::
::


# 画布

::template-core
Canvas 作品集是一个完全可定制的国际化作品集模板，使用 Nuxt 和 Nuxt UI 构建，旨在帮助您轻松展示作品、推荐语和关键信息。该模板集成了 Nuxt Studio，提供流畅的编辑体验，同时利用 Nuxt Content 进行内容管理。Canvas 作品集在性能、灵活性和响应式设计方面表现出色，为开发者和创意人员提供了坚实的基础。

- **现代组件与布局** – 包含内置组件。
- **Nuxt UI v3** – 使用预制的可定制 UI 组件。
- **NuxtHub 支持** - 几秒钟内部署到 NuxtHub。
- **Tailwind CSS** – 美观且响应式的设计系统。
- **可用的联系表单** – 集成 Resend，轻松处理邮件。
- **多语言支持** – 由 Nuxt i18n 驱动。
- **SEO 友好** – 支持 Open Graph 图片（Nuxt OG Image）和 Nuxt Robots，实现自动生成 robots.txt。
- **良好实践** – 自动生成网站地图，优化图片（Nuxt Image），以及 ESLint（Nuxt 配置采用 Flat 配置）。
- **完全响应式** – 兼容所有现代浏览器和设备。
- **极简且专业的设计** – 简洁、优雅且易于定制。

#right
  :::template-features
  ---
  features:
    - label: Nuxt 架构
      content: 充分利用 Nuxt 3 及其模块生态系统的强大功能。
    - label: 支持 Nuxt Studio
      content: 在 Nuxt Studio 中实时预览并编辑主题内容和外观。
    - label: Vue 组件
      content: 在内容中插入内置组件（或自己的组件）。
    - label: 书写 Markdown
      content: 享受 Markdown 的简便与轻松，探索 MDC 语法。
    - label: 随处部署
      content: 通过 Studio 一键部署，或在 Vercel、Netlify 零配置部署。可选择静态生成、按需渲染（Node），或 CloudFlare
        Workers 的边缘渲染。
    - label: 可扩展
      content: 自定义整体设计，或通过插槽添加组件——您可以打造属于自己的 Content-Wind。
  ---
  :::
::


# Content Wind

::template-core
一个轻量级的 Nuxt 主题，用于构建基于 Nuxt Content、TailwindCSS 和 Iconify 的 Markdown 驱动网站

- 在 Markdown 页面中使用布局
- 支持元标签自动生成
- 可配置的排版组件
- 从页面生成导航
- 支持明暗模式切换
- 访问来自 100+ 图标集的 100,000 个图标
- 使用 Shiki 高亮代码块

#right
  :::template-features
  ---
  features:
    - label: Nuxt 架构
      content: 充分利用 Nuxt 3 及其模块生态系统的强大功能。
    - label: Nuxt Studio 兼容
      content: 在 Nuxt Studio 中实时预览并编辑主题内容与外观。
    - label: Vue 组件
      content: 在内容中插入内置组件（或你自己的组件）。
    - label: 编写 Markdown
      content: 享受 Markdown 的简洁易用，并探索 MDC 语法。
    - label: 可部署在任意平台
      content: 通过 Studio 一键部署，或零配置部署到 Vercel 或 Netlify。支持静态生成、按需渲染（Node）或基于 CloudFlare
        Workers 的边缘渲染。
    - label: 可扩展
      content: 自定义整体设计，或通过插槽添加组件 —— 你可以让 Content-Wind 独一无二。
  ---
  :::
::


# 文档

::template-core
[Nuxt UI Pro](https://ui.nuxt.com/pro){rel=""nofollow""} 是一组高级组件，作为 [Nuxt UI](https://ui.nuxt.com){rel=""nofollow""} 的扩展，旨在帮助您在几分钟内创建漂亮且响应式的 Nuxt 应用。

Nuxt UI 团队致力于提供最佳的集成和定制体验，同时 Studio 团队提供与 Nuxt Studio 的完全兼容性。

- **完全可定制**：可通过您的应用配置更改任意组件的样式，或通过 ui 属性进行专门定制。
- **轻松编写 Markdown**：Nuxt UI Pro 重写了 Nuxt Content 的 prose 组件，使其更出色，还新增了 Callout、CodeGroup、Field 等组件。
- **精美的排版样式**：预配置了 Tailwind CSS 排版插件，样式与 Nuxt UI 组件和颜色匹配。
- **开箱即用的全文搜索**：Nuxt UI Pro 配备了现成的命令面板组件，无需再配置 Algolia DocSearch。
- **全面插槽支持**：每个组件都利用 Vue 的插槽功能，给予您构建任意内容的灵活性。
- **响应式设计**：Nuxt UI Pro 组件旨在构建您的内容结构，天生响应式，适应各种屏幕尺寸。

#right
  :::template-features
  ---
  features:
    - label: Nuxt 3
      content: 由 Nuxt 3 驱动，带来最佳性能和 SEO。
    - label: Markdown
      content: 借助 Nuxt Content 使用 MDC 编写页面。
    - label: Nuxt UI
      content: 提供大量完全可定制的组件。
    - label: TypeScript
      content: 享受完备的类型化开发体验。
    - label: Nuxt Studio
      content: 支持 Nuxt Studio，实现快速更新和预览。
    - label: 搜索
      content: 由 Fuse.js 驱动的全文搜索模态框。
  ---
  :::
::


# Docus

::template-core
> 一个美观、极简的 Docus 文档创建入门模板

这是默认的 Docus 入门模板，提供了使用 Markdown 和 Vue 组件构建漂亮文档网站所需的一切。

## ✨ 特性

- 🎨 **美观设计** - 干净、现代的文档主题
- 📱 **响应式** - 移动优先响应式设计
- 🌙 **暗黑模式** - 内置暗/亮模式支持
- 🔍 **搜索** - 全文搜索功能
- 📝 **增强 Markdown** - 支持带自定义组件的扩展 Markdown
- 🎨 **高度可定制** - 轻松主题和品牌定制
- ⚡ **快速性能** - 针对 Nuxt 4 优化
- 🔧 **TypeScript 支持** - 完全支持 TypeScript

## 🚀 快速开始

```bash
# 安装依赖
npm install

# 启动开发服务器
npm run dev
```

你的文档站点将运行在 `http://localhost:3000`

## 📁 项目结构

```text
my-docs/
├── content/              # 你的 Markdown 内容
│   ├── index.md          # 主页
│   ├── 1.getting-started/  # 入门部分
│   └── 2.essentials/     # 重要文档
├── public/               # 静态资源
└── package.json          # 依赖和脚本
```

## ⚡ 内置技术栈

此入门模板预配置了以下组件：

- [Nuxt 4](https://nuxt.com){rel=""nofollow""} - Web 框架
- [Nuxt Content](https://content.nuxt.com/){rel=""nofollow""} - 基于文件的 CMS
- [Nuxt UI](https://ui.nuxt.com){rel=""nofollow""} - 高级 UI 组件
- [Nuxt Image](https://image.nuxt.com/){rel=""nofollow""} - 优化图片加载
- [Tailwind CSS 4](https://tailwindcss.com/){rel=""nofollow""} - 原子化 CSS 框架
- [Docus Layer](https://www.npmjs.com/package/docus){rel=""nofollow""} - 文档主题

## 📖 文档

要获取关于定制你的 Docus 项目的详细文档，请访问 [Docus 文档](https://docus.dev){rel=""nofollow""}

## 🚀 部署

生产环境构建：

```bash
npm run build
```

构建好的文件会输出到 `.output` 目录，支持部署到任何支持 Node.js 的托管服务。

## 📄 许可证

[MIT License](https://opensource.org/licenses/MIT){rel=""nofollow""}

#right
  :::template-features
  ---
  features:
    - label: Nuxt 3
      content: 基于 Nuxt 3，性能与 SEO 表现优异。
    - label: Markdown
      content: 使用 Nuxt Content 支持的 MDC 编写页面内容。
    - label: Nuxt UI
      content: 提供大量完全可定制的组件。
    - label: TypeScript
      content: 完全类型化的开发体验。
    - label: Nuxt Studio
      content: 兼容 Nuxt Studio，实现快速更新与预览。
    - label: Search
      content: 由 Fuse.js 驱动的全文搜索模态框。
  ---
  :::
::


# Docus I18n

::template-core
> 一个漂亮的国际化入门模板，使用 Docus 创建多语言文档

这是一个 i18n Docus 入门模板，提供了构建漂亮多语言文档站点所需的一切，支持 Markdown 和 Vue 组件。

## ✨ 特性

- 🌍 **国际化** - 原生 i18n 支持多语言文档
- 🎨 **精美设计** - 简洁现代的文档主题
- 📱 **响应式** - 移动优先响应设计
- 🌙 **暗色模式** - 内建暗/亮模式支持
- 🔍 **搜索** - 每种语言的全文搜索功能
- 📝 **增强 Markdown** - 扩展的 Markdown 支持自定义组件
- 🎨 **可定制** - 轻松主题和品牌定制
- ⚡ **快速** - 针对 Nuxt 4 优化性能
- 🔧 **TypeScript** - 完整的 TypeScript 支持

## 🚀 快速开始

```bash
# 安装依赖
npm install

# 启动开发服务器
npm run dev
```

您的多语言文档站点将在 `http://localhost:3000` 运行

## 🌍 语言

此入门模板预配置了：

- 🇺🇸 **英语** (`en`) - 默认语言
- 🇫🇷 **法语** (`fr`) - 法语翻译

## 📁 项目结构

```text
my-docs/
├── content/              # 你的 Markdown 内容
│   ├── en/              # 英文内容
│   │   ├── index.md     # 英文首页
│   │   └── docs/        # 英文文档
│   └── fr/              # 法语内容
│       ├── index.md     # 法语首页
│       └── docs/        # 法语文档
├── public/              # 静态资源
├── nuxt.config.ts       # 配置了 i18n 的 Nuxt 配置
└── package.json         # 依赖和脚本
```

### 内容结构

内容按语言组织，方便管理翻译：

```text
content/
├── en/                   # 英文内容
│   ├── index.md
│   ├── 1.getting-started/
│   │   ├── installation.md
│   │   └── configuration.md
│   └── 2.essentials/
│       ├── markdown.md
│       └── components.md
└── fr/                   # 法语内容
    ├── index.md
    ├── 1.getting-started/
    │   ├── installation.md
    │   └── configuration.md
    └── 2.essentials/
        ├── markdown.md
        └── components.md
```

## 🔗 URL 结构

i18n 入门模板生成带语言前缀的 URL：

- 英语: `/en/getting-started/installation`
- 法语: `/fr/getting-started/installation`
- 默认语言回退: `/getting-started/installation` （重定向至英语）

## ⚡ 构建工具

此模板预配置了：

- [Nuxt 4](https://nuxt.com){rel=""nofollow""} - Web 框架
- [Nuxt Content](https://content.nuxt.com/){rel=""nofollow""} - 基于文件的 CMS
- [Nuxt i18n](https://i18n.nuxt.com/){rel=""nofollow""} - 国际化支持
- [Nuxt UI](https://ui.nuxt.com){rel=""nofollow""} - 高级 UI 组件
- [Nuxt Image](https://image.nuxt.com/){rel=""nofollow""} - 优化图片组件
- [Tailwind CSS 4](https://tailwindcss.com/){rel=""nofollow""} - 实用优先 CSS 框架
- [Docus Layer](https://www.npmjs.com/package/docus){rel=""nofollow""} - 文档主题

## 📖 文档

有关如何自定义你的 Docus 项目的详细说明，请访问 [Docus 文档](https://docus.dev){rel=""nofollow""}

## 🚀 部署

生产构建：

```bash
npm run build
```

构建好的文件将位于 `.output` 目录，可部署至任何支持 Node.js 的主机。

## 📄 许可

[MIT 许可证](https://opensource.org/licenses/MIT){rel=""nofollow""}

#right
  :::template-features
  ---
  features:
    - label: Nuxt 4
      content: Web 框架
    - label: Nuxt I18n
      content: 国际化支持
    - label: Nuxt UI
      content: 提供大量可完全定制的组件
    - label: TypeScript
      content: 完整的类型开发体验
    - label: Nuxt Studio
      content: 支持 Nuxt Studio，快速更新和预览
    - label: Search
      content: 基于 Fuse.js 的全文搜索模态框
    - label: Nuxt Image
      content: 强大的图片组件
    - label: Nuxt Content
      content: 强大的内容组件
  ---
  :::
::


# 登陆页

::template-core
[Nuxt UI](https://ui.nuxt.com){rel=""nofollow""} 是一套高级组件集合，旨在帮助您在几分钟内创建吸引人且响应迅速的 Nuxt 应用程序。

Nuxt UI 团队致力于提供最佳集成和定制体验，而 Studio 团队则提供与 Nuxt Studio 模块的完全兼容性。

- **完全可定制**：您可以通过应用配置更改 UI 样式，或通过 `index.yml` 文件编辑您的登陆页内容。
- **美观的排版样式**：预配置了 Tailwind CSS 排版插件，并且样式与 Nuxt UI 组件和配色相匹配。
- **响应式设计**：Nuxt UI 组件旨在构建您的内容，它们具有响应式设计，能够适应任何屏幕尺寸。

#right
  :::template-features
  ---
  features:
    - label: Nuxt 3
      content: 由 Nuxt 3 驱动，提供最佳性能和 SEO。
    - label: Content v3
      content: 使用 yaml 文件编写内容，或使用支持 MDC 语法的 Markdown。
    - label: Nuxt UI v3
      content: 提供大量完全可定制的组件。
    - label: TypeScript
      content: 完全类型化的开发体验。
    - label: Nuxt Studio
      content: 由 Nuxt Studio 支持，实现快速更新和预览。
  ---
  :::
::


# 极简入门

::template-core
释放你的想象力，使用我们的极简入门：

- 从一张白纸开始，打造你梦想中的应用。
- Nuxt Content 已全部配置完成。
- 使用 Markdown 和 Vue 组件轻松组合页面，配合直观的 MDC 语法增强体验。

#right
  :::template-features
  ---
  features:
    - label: Nuxt 架构
      content: 利用 Nuxt 3 及其模块生态系统的全部强大功能。
    - label: 支持 Nuxt Studio
      content: 在 Nuxt Studio 中通过实时预览编辑主题内容和外观。
    - label: Vue 组件
      content: 在内容中使用内置组件（或你自己的组件）。
    - label: 编写 Markdown
      content: 享受 Markdown 的简便与轻松，探索 MDC 语法。
    - label: 部署无忧
      content: 一键从 Studio 部署，或零配置部署到 Vercel 或 Netlify。可选择静态生成、按需渲染（Node）或 CloudFlare
        Worker 的边缘渲染。
  ---
  :::

\::>
::


# Minted 目录

::template-core
Minted 目录是一个高度可定制的模板，旨在快速构建成功的目录网站。

- 创建具有定制样式/品牌的目录网站
- 使用 Markdown 管理列表
- SEO 优化
- 通过标签实现搜索和分类
- 博客页面

#right
  :::template-features
  ---
  features:
    - label: Nuxt 架构
      content: 充分利用 Nuxt 3 及其模块生态系统的强大功能。
    - label: 支持 Nuxt Studio
      content: 在 Nuxt Studio 内实时预览，编辑主题内容和外观。
    - label: Vue 组件
      content: 在内容中插入内置组件（或自定义组件）。
    - label: 编写 Markdown
      content: 享受 Markdown 的简洁易用，并发现 MDC 语法。
    - label: 可部署于任何平台
      content: 通过 Studio 一键部署，或在 Vercel、Netlify 上零配置部署。可选择静态生成、按需渲染（Node）或在 CloudFlare
        Workers 上进行边缘渲染。
    - label: 可扩展
      content: 自定义整体设计，或使用插槽添加组件——可将 Minted 目录打造为专属于你的模板。
  ---
  :::
::


# 作品集

::template-core
[Nuxt UI Pro](https://ui.nuxt.com/pro){rel=""nofollow""} 是一套高级组件集合，是 [Nuxt UI](https://ui.nuxt.com){rel=""nofollow""} 的扩展，旨在帮助你在几分钟内创建吸引人且响应式的 Nuxt 应用程序。

Nuxt UI 团队致力于提供最佳的集成和定制体验，而 Studio 团队则提供与 Nuxt Studio 的完全兼容性。

- **完全可定制**：可以通过你的应用配置更改任何组件的样式，或通过 ui 属性专门定制它们。
- **轻松编写 Markdown**：Nuxt UI Pro 覆盖了 Nuxt Content 的 prose 组件，使其更加出色，还新增了 Callout、CodeGroup、Field 等组件。
- **优美的排版样式**：预配置了 Tailwind CSS 排版插件，并根据 Nuxt UI 组件和颜色进行了样式调整。
- **开箱即用的全文搜索**：Nuxt UI Pro 配备了即用的命令面板组件，无需再配置 Algolia DocSearch。
- **组件支持插槽**：每个组件都利用了 Vue 插槽的强大功能，给予你构建任何内容的灵活性。
- **响应式设计**：Nuxt UI Pro 组件旨在结构化你的内容，默认响应式，能适配任何屏幕尺寸。

#right
  :::template-features
  ---
  features:
    - label: Nuxt 3
      content: 由 Nuxt 3 驱动，提供最佳性能和 SEO。
    - label: Markdown
      content: 借助 Nuxt Content 使用 MDC 编写页面。
    - label: Nuxt UI
      content: 提供大量完全可定制的组件。
    - label: TypeScript
      content: 完全类型化的开发体验。
    - label: Nuxt Studio
      content: 由 Nuxt Studio 支持，快速更新和预览。
  ---
  :::
::


# Saas

::template-core
[Nuxt UI](https://ui.nuxt.com){rel=""nofollow""} 是一套高级组件集合，旨在帮助您在几分钟内创建美观且响应迅速的 Nuxt 应用。

Nuxt UI 团队致力于提供最佳的集成和定制体验，而 Studio 团队则提供与 Nuxt Studio 的完全兼容性。

- **完全可定制**：可以通过您的应用配置更改任何组件的样式，或通过 ui 属性进行特定定制。
- **轻松编写 Markdown**：Nuxt UI 重写了 Nuxt Content 的 prose 组件，使其更出色，还增加了如 Callout、CodeGroup、Field 等新组件。
- **优美的排版样式**：Tailwind CSS 排版插件预配置并调整样式以匹配 Nuxt UI 组件和颜色。
- **开箱即用的全文搜索**：Nuxt UI 自带一个可直接使用的命令面板组件，无需再设置 Algolia DocSearch。
- **插槽随处可用**：每个组件充分利用 Vue 的插槽功能，赋予您构建任意结构的灵活性。
- **响应式设计**：Nuxt UI 组件旨在构建内容结构，响应式设计能适应任何屏幕尺寸。

#right
  :::template-features
  ---
  features:
    - label: Nuxt 3
      content: 由 Nuxt 3 驱动，实现最佳性能和 SEO。
    - label: Markdown
      content: 借助 Nuxt Content 使用 MDC 编写页面。
    - label: Nuxt UI
      content: 提供一套高度可定制的丰富组件。
    - label: TypeScript
      content: 完整的类型化开发体验。
    - label: Nuxt Studio
      content: 使用 Nuxt Studio 模块实现快速更新和预览。
    - label: Search
      content: 由 Fuse.js 提供支持的全文搜索模态框。
  ---
  :::
::


# Docus，卷土重来

我们彻底重写了 [Docus](https://docus.dev){rel="&#x22;nofollow&#x22;"} 主题。以 Nuxt 生态系统为动力、由 Nuxt UI 设计，带来一个全新且现代的基础，旨在提供最佳的文档体验。

目标很简单：汲取 **Nuxt 生态系统中最优秀的部分**，交付一个强大、优雅且易于维护的文档主题。

## **Docus v3 有哪些新变化？**

### **📦 一个真正的** [Nuxt]{.text-primary} **应用，仅有一个依赖**

Docus 构建于 [Nuxt 3](https://nuxt.com){rel="&#x22;nofollow&#x22;"} 之上（已启用 4 版本兼容模式，已为 Nuxt 4 做好准备）。这意味着你的文档是一个完整的 Nuxt 应用，能够访问 Nuxt 的全部功能：组件、模块、插件、运行时配置等。

**但**，**最棒的是**…… 你只需安装 **docus** 这个包。它捆绑了所有必要的官方 Nuxt 模块，让你可以在几秒钟内开始编写文档。在你的项目里，只需一个 `package.json` 文件和一个包含 Markdown 文件的 `content/` 文件夹，立刻即可开始。

::prose-tip{to="https://docus.dev/concepts/nuxt"}
了解更多关于 Docus 中 Nuxt 层的专属章节。
::

### **✨ 由** [Nuxt]{.text-primary} **UI Pro 设计**

Docus v2 由 **Nuxt UI Pro** 驱动，开箱即用美观、响应式且无障碍的主题。配合 **Tailwind CSS v4**、**CSS 变量** 和 **Tailwind Variants API**，你的文档默认美观且完全可定制。

你可以通过简单修改 `app.config.ts` 文件，实现全局或逐组件调整颜色、更新排版或组件样式。

::prose-tip{to="https://docus.dev/concepts/theme"}
了解更多关于 Docus 中 UI 主题的专属章节。
::

::prose-note
目前需要 UI Pro 许可，但我们正努力让其对所有人免费开放。此外，如果你当前正在构建开源文档，可以通过 

`ui-pro@nuxt.com`

 申请 OSS 许可。
::

### **✍️ 带超能力的 Markdown（由** [Nuxt]{.text-primary} &#x2A;*Content 支持的 MDC 语法）**

撰写文档从未如此简便。只需一个 Markdown 文件夹即可。此外，借助 Nuxt Content 和 MDC 语法，你可以在 Markdown 中嵌入交互式 Vue 组件，使用任何 Nuxt UI 组件或自定义组件。

::prose-tip{to="https://docus.dev/concepts/edition"}
了解更多关于 Docus 中 MDC 语法的专属章节。
::

### 🖥️ 准备支持 [Nuxt]{.text-primary} Studio

Docus 完美配合 **Nuxt Studio**，让你完全在浏览器中管理和编辑文档。无需终端，无需本地环境设置，是与非技术贡献者协作或团队集中管理文档的理想方式。

::prose-tip{to="https://docus.dev/getting-started/studio"}
了解更多关于 Docus 中 Studio 编辑器的专属章节。
::

### **🔍 开箱即用的 SEO**

技术 SEO 既复杂又枯燥。Docus 提供了一个稳健的默认可选设置，开箱即用，同时让你完全控制 SEO 元数据—从页面元信息到社交分享图片。

::prose-tip{to="https://docus.dev/concepts/configuration"}
了解更多关于 Docus 中应用配置的专属章节。
::

### **🔧 通过组件覆盖实现完全自定义**

需要替换部分布局或 UI？Docus 使用 **Nuxt Layers** 让你覆盖我们定义的核心组件。只需在项目的 `components/` 目录中创建同名组件，Docus 会自动采用它。

::prose-tip{to="https://docus.dev/concepts/customization"}
了解更多关于 Docus 中组件覆盖的专属章节。
::

### **🤖 默认集成大型语言模型（LLMs）**

Docus 默认集成了 `nuxt-llms`，为大型语言模型（LLMs）准备你的内容。所有文档页面均被注入，且自动生成并预渲染 `/llms.txt` 文件。

::prose-tip{to="https://docus.dev/concepts/llms"}
了解更多关于 Docus 中 LLMs 集成的专属章节。
::

### **🧠 为即刻使用的文档提供智能默认**

Docus 含有贴心默认设置，节省你的时间：

- ✅ 根据文件夹结构自动生成侧边栏导航
- 🔍 使用 Fuse.js 支持全文搜索
- ✨ 优化排版和布局
- 🌙 支持开箱即用的暗黑模式
- 🖼️ 集成 Nuxt Image，实现响应式和优化图像

### **🔁 简单迁移**

从任何基于 Markdown 的系统迁移都非常简单：将 `.md` 文件放入 `content/` 文件夹，立即上线。

## **接下来是什么？**

### **🔧 今天就试试 Docus**

```bash
npx docus init docs
```

就这么简单 🚀 你可以编辑 `content/` 文件夹开始编写文档了。

::prose-tip{to="https://docus.dev"}
访问文档以了解 Docus 的全部内容。
::

### **🤝 贡献**

我们已将仓库迁移到 **NuxtLabs** GitHub 组织，并清理了问题跟踪器，重新开始。

无论是修复 Bug、建议新功能还是编写文档，我们都非常欢迎你的帮助。欢迎反馈、贡献和关于 Docus 未来的讨论！


# Nuxt Studio Alpha 版本发布

当 NuxtLabs 加入 Vercel 时，我们承诺将 [nuxt.studio](https://nuxt.studio){rel="&#x22;nofollow&#x22;"} 从一个托管平台转变为一个免费开源的模块。今天，我们很高兴宣布 Nuxt Studio 模块的**第一个 alpha 版本**发布。

::u-button
---
color: neutral
icon: i-simple-icons-github
target: _blank
to: https://github.com/nuxt-content/studio
variant: subtle
---
在 GitHub 上发现 Nuxt Studio 模块。
::

您现在可以直接在生产环境中启用内容编辑，配合实时预览和 GitHub 集成，全部在您自己的 Nuxt 应用内完成。

:video{controls loop src="https://res.cloudinary.com/nuxt/video/upload/v1733494722/contentv3final_rc8bvu.mp4"}

::u-button
---
external: ""
class: mt-4
color: neutral
icon: i-lucide-mouse-pointer-click
to: https://nuxt-content.zhcndoc.com/admin?redirect=/blog/studio-module-alpha
---
试着编辑这页内容
::

## 🏠 从托管平台到自托管模块

没有 Vercel 的支持，这一里程碑是不可能实现的。他们的支持使我们能够投入资源将 Studio 重构为一个开源模块。

### 有什么不同？

Studio 最初作为托管平台提供，位于 [nuxt.studio](https://nuxt.studio){rel="&#x22;nofollow&#x22;"}，现在变成了一个免费的开源 Nuxt 模块，可与您的 Nuxt Content 网站一起部署。

这意味着内容编辑者可以直接在生产环境的自己网站上管理和更新内容，无需本地开发工具或 Git 知识。

- **自托管** — 完全运行在您的基础设施中，和 Nuxt 应用一起
- **无外部依赖** — 不依赖任何 API 或第三方服务
- **免费开源** — 在 MIT 许可证下发布
- **直接集成** — 只需一个简单的 GitHub OAuth 应用即可开始使用

唯一的权衡是 Studio 现在需要一个服务器端路由来做身份验证。尽管 [Nuxt 混合渲染](https://nuxt.com/docs/4.x/guide/concepts/rendering#hybrid-rendering){rel="&#x22;nofollow&#x22;"} 仍支持静态生成，但您的站点必须部署在支持 SSR 的平台。

## 📦 Alpha 版本内容

Alpha 版本侧重于 **核心基础设施和稳定性**，避免引入可视化编辑器可能带来的任何漏洞。我们使用 Monaco 编辑器来确保所有文件操作和 GitHub 工作流的稳健性，然后再引入可视化编辑功能。

**Monaco 代码编辑器** → 拥有 Markdown、YAML 和 JSON 语法高亮的 IDE 编辑体验，支持完整的 MDC 语法，带冲突的分屏差异查看器。

**文件操作** → 针对您的 `content/` 目录提供完整的增删改查操作。创建、编辑、删除、重命名和移动文件，内置草稿管理。

**媒体管理** → 集中管理 `public/` 目录中的资源，支持上传、整理、预览和集成。

**Git 集成** → 通过 OAuth 直接向 GitHub 提交，支持冲突检测、作者归属和自定义提交信息。

**实时预览** → 在生产网站上实时预览草稿更改，支持即时更新和并排编辑。

## 🗺️ 未来规划

### Beta 版本 `2025 年第 4 季度`

以我们在 [nuxt.studio](https://nuxt.studio){rel="&#x22;nofollow&#x22;"} 上打造的内容为灵感，Beta 阶段将引入开源可视化编辑器，使 Studio 对非技术用户更友好：

- **Markdown 编辑器** — 类似 Notion 的 Markdown 体验
- **基于表单的编辑** — 针对 Markdown frontmatter、YAML 和 JSON 文件的模式表单
- **Vue 组件编辑** — 可视化界面编辑组件的属性和插槽
- **Google OAuth** — 为非 GitHub 用户提供的认证方式

### 稳定版本 `2025 年底`

生产就绪功能、性能优化和稳定性增强。

::warning
年底时，托管平台将关闭，模块将成为编辑 Nuxt Content 网站的唯一方式。
::

### 2026 年及以后

AI 驱动的内容建议、更多 Git 提供商支持和社区驱动的功能。

## 🗄️ 存储架构

Studio 使用三层存储架构以保持内容在浏览器和 GitHub 之间同步。

### 生产数据库 `SQLite WASM`

当您的 Nuxt Content 网站加载时，Nuxt Content v3 会从服务器下载一个 SQLite 数据库快照，并初始化包含您已部署分支全部内容的本地 WASM 数据库。该数据库保持与 GitHub 同步，只要您最后一次部署成功。这是 Studio 编辑内容时更新的生产数据库。

### 草稿存储 `IndexedDB`

Studio 使用基于 IndexedDB 的 [unstorage](https://unstorage.unjs.io/){rel="&#x22;nofollow&#x22;"} 维护一个独立草稿层。当您编辑内容时，更改会以草稿形式保存在您的浏览器本地。每次 Studio 加载时，这些草稿会与 SQLite 数据库合并，以渲染生产网站的草稿版本。

::note
草稿仅保存在您的浏览器中，不会在编辑者或设备间共享。
::

### GitHub 仓库 `API 集成`

当您发布时，Studio 通过 GitHub API 直接将草稿更改提交到 GitHub。之后 CI/CD 流水线会自动重新构建并重新部署网站。部署完成后，您需要刷新页面以用最新内容更新浏览器数据库。

## 🔄 同步流程

### 初次加载

::prose-steps{level="4"}
#### 数据库初始化

Nuxt Content 下载构建过程中生成的 SQLite 数据库快照。 :br
此文件包含 `content/` 目录中所有已解析的内容。

#### 草稿恢复

Studio 检查 IndexedDB 中之前会话中存在的草稿，并将其加载到 SQLite 数据库中。

#### 预览

Studio 刷新网站预览，您可以直接在生产网站上查看最新的草稿和编辑内容。
::

### 编辑内容

::prose-steps{level="4"}
#### 草稿修改

更改立即保存到 IndexedDB 作为草稿，状态包括 `created`、`modified` 或 `deleted`。

#### 数据库更新

本地 SQLite 数据库更新以包含草稿内容，实现即时视觉预览。

#### 冲突检测

Studio 将您的草稿内容与 GitHub 上的最新版本进行比对以检测可能的冲突。

  :::note
  **冲突可能发生在：**

  :br

  - 其他人推送了修改同一文件的提交且该版本正在构建中。
  - 部署失败或未完成，导致生产环境内容落后且与 GitHub 不同步。
  :::
::

### 发布更改

::prose-steps{level="4"}
#### 草稿收集

Studio 汇总所有包含更改的草稿项。

#### GitHub 提交

通过 GitHub API，Studio 创建包含所有更新文件的新提交。

#### 触发部署

您的 CI/CD 平台检测到提交后，自动重新构建并重新部署网站。

#### 等待部署

发布后，Studio 清除本地草稿并等待部署完成。 :br
此期间显示加载状态，生产 SQLite 数据库同步至最新提交。

  :::warning
  在提交部署完成之前，Studio 处于等待状态，生产数据库尚未更新。
  :::
::

## 🚀 立即开始

安装模块并配置您的 GitHub OAuth 应用，开始在生产环境中编辑内容：

```bash
npx nuxi module add nuxt-studio@alpha
```

查看 [安装指南](https://nuxt-content.zhcndoc.com/docs/studio/setup) 以获取完整的安装和配置说明。

---

我们期待看到您使用 Nuxt Studio 构建的作品。加入 [GitHub Discussions](https://github.com/nuxt-content/studio/discussions){rel="&#x22;nofollow&#x22;"} 讨论或 [加入我们的 Discord](https://discord.gg/sBXDm6e8SP){rel="&#x22;nofollow&#x22;"}，共同塑造模块的未来。


# 介绍 Nuxt Studio v2

::warning
本文发表于 2025 年 1 月 6 日 

[Content](https://github.com/nuxt/content){rel=""nofollow""}

 和 

[Studio](https://github.com/nuxtlabs/studio-module){rel=""nofollow""}

 模块合并之前。因此，内容可能存在一些不一致。Studio 模块现已废弃，作为 Content 模块的可选功能提供。了解如何在

[此指南](https://nuxt-content.zhcndoc.com/docs/getting-started)

中启用它。
::

我们很高兴宣布 Nuxt Studio v2 的发布，这是一次重大更新，带来了全新界面，特别基于用户反馈为用户量身设计。

::tip
Studio 针对 

**Nuxt Content**

 项目进行了优化，但唯一真正的要求是拥有包含 Markdown 文件的 

*content*

 文件夹。这个简单配置足以开始使用该平台编辑和发布文件。
::

## **更加直观的界面**

![Nuxt studio v2 界面](https://nuxt-content.zhcndoc.com/blog/v2-interface.webp)

版本 2 的主要改进是对界面的**全面重构**。我们将其设计得更直观、更易用，尤其对非技术用户更友好。我们的目标是简化用户体验，让创建和设置项目变得更轻松。新界面简洁明快，旨在优化您的工作流程。

## **谷歌认证**

![谷歌和 GitHub 认证](https://nuxt-content.zhcndoc.com/blog/google-github.webp)

我们现在提供两种不同的认证方式。您可以用 **GitHub** 或 **Google** 登录。这两种方式赋予相同的编辑权限，但由于 Studio 与 GitHub 同步，部分功能专属 GitHub 用户，尤其是项目创建。

::warning
由于 Google 用户无法创建项目，需

**加入已有项目的团队**

以进行编辑。
::

## **最简配置即可编辑文件**

您现在无需任何配置即可编辑内容，只需导入您的仓库即可。您可以浏览文件和媒体，编辑内容并发布到 GitHub。

团队协作功能也已支持。

![类 Notion 编辑器支持协作](https://nuxt-content.zhcndoc.com/blog/collaborate.webp)

::warning
编辑器中的媒体在未设置实时预览前不会显示（详见下文）。
::

## 简化的实时预览设置

![实时预览开启于类 Notion 编辑器与网站之间](https://nuxt-content.zhcndoc.com/blog/preview.webp)

由于实时预览功能需要部署的 URL，我们使设置尽可能简单。

虽然 GitHub Pages 部署依然可用且无需您配置，但自托管项目的要求已简化，移除了令牌校验。[启用 Studio 模块](https://nuxt.studio/docs/get-started/setup#enable-the-live-preview){rel="&#x22;nofollow&#x22;"} 是&#x2A;*唯一剩下的要求。**

::warning{to="https://github.com/nuxtlabs/studio-module"}
务必使用最新版本的 

**Studio 模块**

 以确保兼容性及访问新功能。
::

## 全新的文档

随着全新平台上线，带来了[新文档](https://nuxt.studio/docs/get-started/introduction){rel="&#x22;nofollow&#x22;"}。欢迎查阅，深入了解全新的 Studio。

无论您是[编辑者](https://nuxt.studio/docs/editors/introduction){rel="&#x22;nofollow&#x22;"}还是[开发者](https://nuxt.studio/docs/developers/introduction){rel="&#x22;nofollow&#x22;"}，现在都有专属的文档章节。

## Studio 的新方向

大多数可用 CMS 解决方案要么面向开发者提供高度可定制化，要么面向内容编辑者非常友好，Studio 希望兼顾二者。

**开发者提供工具，使编辑者专注内容，无需任何技术知识。**

::tip
我们的类 Notion 编辑器前景广阔，期待与社区共同发展。
::

##


# 如何将您的 Nuxt 文档网站升级到 Content x UI v3

**2025 年以「三」的力量开启！**

新年伊始，我们喜爱的工具迎来了重大更新。UI 团队即将发布 **UI / UI Pro 库** 的 **3 版本**（目前处于 alpha 版本），而 Content 团队已经发布了 **Nuxt Content v3**。

这些更新意味着所有结合了 **Content** 和 **UI** 的入门模板都需要更新以适配最新版本。为帮助您顺利完成迁移，本指南将演示如何将 **Nuxt UI Pro Docs Starter** 迁移到全新的 **Content v3 和 Nuxt UI v3** 包。

::prose-tip{to="https://github.com/nuxt-ui-pro/docs/tree/v3"}
查看 UI Pro 文档入门模板仓库源码。
::

## Content 迁移（v2 → v3）

### 1. 将包更新到 v3

::code-group
```bash [pnpm]
pnpm add @nuxt/content@^3
```

```bash [yarn]
yarn add @nuxt/content@^3
```

```bash [npm]
npm install @nuxt/content@^3
```

```bash [bun]
bun add @nuxt/content@^3
```
::

### 2. 创建 `content.config.ts` 文件

该配置文件定义数据结构。集合（collection）代表一组相关内容。以 docs starter 为例，包含两个不同的集合，`landing` 集合代表主页，另一个 `docs` 集合包含文档页面。

```js [content.config.ts]
import { defineContentConfig, defineCollection, z } from '@nuxt/content'

export default defineContentConfig({
  collections: {
    landing: defineCollection({
      type: 'page',
      source: 'index.yml'
    }),
    docs: defineCollection({
      type: 'page',
      source: {
        include: '**',
        exclude: ['index.yml']
      },
      schema: z.object({
        links: z.array(z.object({
          label: z.string(),
          icon: z.string(),
          to: z.string(),
          target: z.string().optional()
        })).optional()
      })
    })
  }
})
```

在 [`page`](https://nuxt-content.zhcndoc.com/docs/collections/types#page-type) 类型提供的内置字段基础上，我们为 `docs` 集合额外添加了 `links` 字段，以便在文档的 [页面头部](https://ui3.nuxt.dev/components/page-header){rel="&#x22;nofollow&#x22;"} 有选择地显示它们。

::prose-tip
`type: page`

 表示内容文件与网站页面之间存在一一对应关系。
::

### 3. 迁移 `app.vue`

::prose-steps{level="4"}
#### 导航抓取方法更新：从 `fetchContentNavigation` 迁移为 `queryCollectionNavigation`

  :::prose-code-group
  ```ts [app.vue (v3)]
  const { data: navigation } = await useAsyncData('navigation', () => queryCollectionNavigation('docs'))

  ```

  ```ts [app.vue (v2)]
  const { data: navigation } = await useAsyncData('navigation', () => fetchContentNavigation())
  ```
  :::

#### 内容搜索命令面板数据使用新方法 `queryCollectionSearchSections`

  :::prose-code-group
  ```ts [app.vue (v3)]
  const { data: files } = useLazyAsyncData('search', () => queryCollectionSearchSections('docs'), {
    server: false,
  })
  ```

  ```ts [app.vue (v2)]
  const { data: files } = useLazyFetch<ParsedContent[]>('/api/search.json', {
    default: () => [],
    server: false
  })
  ```
  :::
::

### 4. 迁移首页

::prose-steps{level="4"}
#### 首页数据抓取方法更新：从 `queryContent` 迁移为 `queryCollection`

  :::prose-code-group
  ```ts [index.vue (v3)]
  const { data: page } = await useAsyncData('index', () => queryCollection('landing').path('/').first())
  ```

  ```ts [index.vue (v2)]
  const { data: page } = await useAsyncData('index', () => queryContent('/').findOne())
  ```
  :::

#### 使用 [`page`](https://nuxt-content.zhcndoc.com/docs/collections/types#page-type) 类型提供的 `seo` 字段填充 `useSeoMeta`

```ts [index.vue]
useSeoMeta({
  title: page.value.seo.title,
  ogTitle: page.value.seo.title,
  description: page.value.seo.description,
  ogDescription: page.value.seo.description
})
```

  :::prose-note
  请注意，当未设置时，

  `seo`

   字段会被根级的 

  `title`

   和 

  `description`

   自动覆盖。
  :::
::

### 5. 迁移捕获全部文档页面

::prose-steps{level="4"}
#### 文档页面及其周边内容抓取更新为使用 `queryCollection` 和 `queryCollectionItemSurroundings`

  :::prose-code-group
  ```ts [docs/[...slug\\].vue (v3)]
  const { data } = await useAsyncData(route.path, () => Promise.all([
    queryCollection('docs').path(route.path).first(),
    queryCollectionItemSurroundings('docs', route.path, {
      fields: ['title', 'description'],
    }),
  ]), {
    transform: ([page, surround]) => ({ page, surround }),
  })

  const page = computed(() => data.value?.page)
  const surround = computed(() => data.value?.surround)
  ```

  ```ts [docs/[...slug\\].vue (v2)]
  const { data: page } = await useAsyncData(route.path, () => queryContent(route.path).findOne())

  const { data: surround } = await useAsyncData(`${route.path}-surround`, () => queryContent()
    .where({ _extension: 'md', navigation: { $ne: false } })
    .only(['title', 'description', '_path'])
    .findSurround(withoutTrailingSlash(route.path))
  )
  ```
  :::

#### 使用 [`page`](https://nuxt-content.zhcndoc.com/docs/collections/types#page-type) 类型提供的 `seo` 字段填充 `useSeoMeta`

```ts [index.vue]
useSeoMeta({
  title: page.value.seo.title,
  ogTitle: `${page.value.seo.title} - ${seo?.siteName}`,
  description: page.value.seo.description,
  ogDescription: page.value.seo.description
})
```

  :::prose-note
  请注意，当未设置时，

  `seo`

   字段会被根级的 

  `title`

   和 

  `description`

   自动覆盖。
  :::
::

### 6. 更新类型

Content v3 大幅改进了类型支持，大部分手动声明类型的需求已无，类型将由 Nuxt Content API 直接提供。

文档入门模板中唯一需要关注的是导航项类型，将 `NavItem` 替换为 `ContentNavigationItem` 。

```ts
import type { ContentNavigationItem } from '@nuxt/content'

const navigation = inject<Ref<ContentNavigationItem[]>>('navigation')
```

### 7. 替换文件夹元数据文件

所有 `_dir.yml` 文件命名改为 `.navigation.yml`

### 8. 迁移 Studio 激活方式

由于 [studio 模块](https://nuxt.studio){rel="&#x22;nofollow&#x22;"} 已废弃，且新的通用 `Preview API` 已直接集成到 Nuxt Content，我们可以从依赖和 `nuxt.config.ts` 的模块列表中移除 `@nuxthq/studio` 包。

只需在 Nuxt 配置文件中启用预览模式，将 Studio API 绑定即可。

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  content: {
    preview: {
      api: 'https://api.nuxt.studio'
    }
  },
})
```

最后，为了保持 [app config 文件可由 Studio 更新](https://nuxt-content.zhcndoc.com/docs/studio/config)，只需将 `nuxt.schema.ts` 文件中的辅助导入由 `@nuxthq/studio/theme` 更改为 `@nuxt/content/preview`。

::prose-tip
到此为止，内容已使用 Content v3 驱动。接下来让我们迁移到 

[Nuxt UI / UI Pro](https://ui3.nuxt.dev){rel=""nofollow""}

 版本 3。
::

## Nuxt UI Pro 迁移（v1 → v3）

::prose-caution
这是一次迁移指导，不涵盖所有破坏性变更。请检查文档中使用的每个组件，确认是否需要更新属性、插槽或样式。
::

### 1. 将包设置为 v3

::prose-note
为与 UI 版本统一（从 v1 直接跳至 v2），Nuxt UI Pro 跳过了版本 2，直接更新到 v3。
::

::prose-steps{level="4"}
#### 安装 Nuxt UI v3 alpha 版

  :::code-group{sync="pm"}
  ```bash [pnpm]
  pnpm add @nuxt/ui-pro@next
  ```

  ```bash [yarn]
  yarn add @nuxt/ui-pro@next
  ```

  ```bash [npm]
  npm install @nuxt/ui-pro@next
  ```

  ```bash [bun]
  bun add @nuxt/ui-pro@next
  ```
  :::

#### 在 Nuxt 配置中添加模块

无需再在模块中添加 `@nuxt/ui`，因为它已被 `@nuxt/ui-pro` 自动引入。

  :::prose-code-group
  ```ts [nuxt.config.ts (v3)]
  export default defineNuxtConfig({
    modules: ['@nuxt/ui-pro']
  })
  ```

  ```ts [nuxt.config.ts (v1)]
  export default defineNuxtConfig({
    extends: ['@nuxt/ui-pro'],
    modules: ['@nuxt/ui']
  })
  ```
  :::

  :::prose-note
  **Nuxt UI Pro V3**

   被视为模块，而非层（layer）。
  :::

#### 在 CSS 中引入 Tailwind CSS 和 Nuxt UI Pro

```css [assets/css/main.css]
@import "tailwindcss" theme(static);
@import "@nuxt/ui-pro";
```

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  modules: ['@nuxt/ui-pro'],
  css: ['~/assets/css/main.css']
})
```

#### 移除 tailwind 配置文件，使用 CSS 优先的主题定制

Nuxt UI v3 使用 Tailwind CSS v4，采用 CSS 优先的配置方式。现可在 `@theme` 指令内使用 CSS 变量定制主题。

- 删除 `tailwind.config.ts` 文件
- 在 `main.css` 文件中使用 `@theme` 指令应用主题
- 使用 `@source` 指令让 Tailwind 能检测 `markdown` 文件中的类名

```css [assets/css/main.css]
@import "tailwindcss" theme(static);
@import "@nuxt/ui-pro";

@source "../content/**/*";

@theme {
  --font-sans: 'DM Sans', sans-serif;

  --color-green-50: #EFFDF5;
  --color-green-100: #D9FBE8;
  --color-green-200: #B3F5D1;
  --color-green-300: #75EDAE;
  --color-green-400: #00DC82;
  --color-green-500: #00C16A;
  --color-green-600: #00A155;
  --color-green-700: #007F45;
  --color-green-800: #016538;
  --color-green-900: #0A5331;
  --color-green-950: #052E16;
}

```
::

### 2. 更新 `app.config.ts` 中的 `ui` 配置

::prose-caution{to="https://ui3.nuxt.dev/getting-started/theme#customize-theme"}
组件中的 

`ui`

 属性或 

`app.config.ts`

 中的 

`ui`

 键的所有重载已废弃，请参考 

**UI / UI Pro**

 文档进行核查。
::

::prose-code-group
```ts [app.config.ts (v3)]
export default defineAppConfig({
  ui: {
    colors: {
      primary: 'green',
      neutral: 'slate'
    }
  },
  uiPro: {
    footer: {
      slots: {
        root: 'border-t border-gray-200 dark:border-gray-800',
        left: 'text-sm text-gray-500 dark:text-gray-400'
      }
    }
  },
}
```

```ts [app.config.ts (v1)]
export default defineAppConfig({
  ui: {
    primary: 'green',
    gray: 'slate',
    footer: {
      bottom: {
        left: 'text-sm text-gray-500 dark:text-gray-400',
        wrapper: 'border-t border-gray-200 dark:border-gray-800'
      }
    }
  },
})
```
::

### 3. 迁移 `error.vue` 页面

可以使用新的 `UError` 组件作为完整的页面结构。

::prose-code-group
```vue [error.vue (v3)]
<template>
  <div>
    <AppHeader />

    <UError :error="error" />

    <AppFooter />

    <ClientOnly>
      <LazyUContentSearch
        :files="files"
        :navigation="navigation"
      />
    </ClientOnly>
  </div>
</template>
```

```vue [error.vue (v1)]
<template>
  <div>
    <AppHeader />

    <UMain>
      <UContainer>
        <UPage>
          <UPageError :error="error" />
        </UPage>
      </UContainer>
    </UMain>

    <AppFooter />

    <ClientOnly>
      <LazyUContentSearch
        :files="files"
        :navigation="navigation"
      />
    </ClientOnly>

    <UNotifications />
  </div>
</template>
```
::

### 4. 迁移 `app.vue` 页面

- `Main`、`Footer` 和 `LazyUContentSearch` 组件在本例中无需更新。
- `Notification` 组件可以移除，因为 `Toast` 由 `App` 组件直接管理。
- `NavigationTree` 组件可替换为 `NavigationMenu` 或 `ContentNavigation` 组件展示内容导航。

::prose-code-group
```vue [Header.vue (v3)]
<script>
// 内容导航由 queryCollectionNavigation('docs') 提供
const navigation = inject<Ref<ContentNavigationItem[]>>('navigation')
</script>

<template>
  <UHeader>
    <template #content>
      <UContentNavigation
        highlight
        :navigation="navigation"
      />
     </template>
   </UHeader>
</template>
```

```vue [Header.vue (v1)]
<script>
// 内容导航由 fetchContentNavigation() 提供
const navigation = inject<Ref<NavItem[]>>('navigation')
</script>

<template>
  <UHeader>
    <template #panel>
      <UNavigationTree :links="mapContentNavigation(navigation)" />
     </template>
   </UHeader>
</template>
```
::

### 5. 更新首页

我们决定将首页内容从 `YML` 迁移到 `Markdown` 。

::prose-tip
这么做是因为 Markdown 中使用的组件不再需要全局暴露（也不必创建在 

`components/content`

 文件夹中），Content v3 会自动处理这些。
::

::prose-steps{level="4"}
#### 更新内容配置

```ts [content.config.ts]
export default defineContentConfig({
  collections: {
    landing: defineCollection({
      type: 'page',
      source: 'index.md'
    }),
    docs: defineCollection({
      type: 'page',
      source: {
        include: '**',
        exclude: ['index.md']
      },
      ...
    })
  }
})
```

#### 使用 `ContentRenderer` 渲染 `Markdown`

  :::prose-note
  由于首页包含非 prose Vue 组件，需将 

  `ContentRenderer`

   组件的 

  `prose`

   属性设置为 

  `false`

  ，以避免 Markdown 应用 prose 样式。
  :::

  :::prose-code-group
  ```vue [index.vue (v3)]
  <template>
    <UContainer>
      <ContentRenderer
        v-if="page"
        :value="page"
        :prose="false"
      />
    </UContainer>
  </template>
  ```

  ```vue [index.vue (v1)]
  <template>
    <div>
      <ULandingHero
        v-if="page.hero"
        v-bind="page.hero"
      >
        <template #headline>
          <UBadge
            v-if="page.hero.headline"
            variant="subtle"
            size="lg"
            class="relative rounded-full font-semibold"
          >
            <NuxtLink
              :to="page.hero.headline.to"
              target="_blank"
              class="focus:outline-none"
              tabindex="-1"
            >
              <span
                class="absolute inset-0"
                aria-hidden="true"
              />
            </NuxtLink>

            {{ page.hero.headline.label }}

            <UIcon
              v-if="page.hero.headline.icon"
              :name="page.hero.headline.icon"
              class="ml-1 w-4 h-4 pointer-events-none"
            />
          </UBadge>
        </template>

        <template #title>
          <MDC cache-key="head-title" :value="page.hero.title" />
        </template>

        <MDC
          :value="page.hero.code"
          cache-key="head-code"
          class="prose prose-primary dark:prose-invert mx-auto"
        />
      </ULandingHero>

      <ULandingSection
        :title="page.features.title"
        :links="page.features.links"
      >
        <UPageGrid>
          <ULandingCard
            v-for="(item, index) of page.features.items"
            :key="index"
            v-bind="item"
          />
        </UPageGrid>
      </ULandingSection>
    </div>
  </template>
  ```
  :::

#### 迁移 Vue 组件到 MDC 语法

请将 `index.md` 中的所有组件迁移至遵循 [MDC 语法](https://nuxt-content.zhcndoc.com/docs/files/markdown) 格式。

首页组件已重组并标准化为通用的 `Page` 组件。

- `LandingHero` 改为 `PageHero`
- `LandingSection` 改为 `PageSection`
- `LandingCard` 改为 `PageCard`（但我们将使用 `PageFeature`）

  :::prose-tip{to="https://github.com/nuxt-ui-pro/docs/blob/v3/content/index.md"}
  在 GitHub 上查看最终的 

  `Markdown`

   文件示例。
  :::
::

### 6. 迁移文档页面

::prose-steps{level="4"}
#### 布局

- `Aside` 组件已重命名为 `PageAside`。
- 可使用 `ContentNavigation` 组件（替代旧的 `NavigationTree`）展示由 `queryCollectionNavigation` 返回的内容导航。

  :::prose-code-group
  ```vue [layout/docs.vue (v3)]
  <template>
    <UContainer>
      <UPage>
        <template #left>
          <UPageAside>
            <UContentNavigation
              highlight
              :navigation="navigation"
            />
          </UPageAside>
        </template>

        <slot />
      </UPage>
    </UContainer>
  </template>
  ```

  ```vue [layout/docs.vue (v1)]
  <template>
    <UContainer>
      <UPage>
        <template #left>
          <UAside>
            <UNavigationTree :links="mapContentNavigation(navigation)" />
          </UAside>
        </template>

        <slot />
      </UPage>
    </UContainer>
  </template>
  ```
  :::

#### 捕获全部页面

- `Divider` 改名为 `Separator`
- `findPageHeadline` 必须从 `#ui-pro/utils/content` 导入
- `PageBody` 组件不再存在 `prose` 属性
::

::prose-tip{to="https://github.com/nuxt-ui-pro/docs/tree/v3"}
完成！文档入门模板现已完全运行于 UI 和 Content v3 🎉
::

## 在 Studio 中编辑

如果您使用 Nuxt Studio 编辑文档，也需要迁移相关代码。

Studio 模块已废弃，新的通用 `Preview API` 已内嵌于 Nuxt Content，您可移除依赖及 `nuxt.config.ts` 中的 `@nuxthq/studio` 模块，只需在 Nuxt 配置中启用预览模式并绑定 Studio API。

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  content: {
    preview: {
      api: 'https://api.nuxt.studio'
    }
  },
})
```

要保持 app 配置文件可由 Studio 更新，请将 `nuxt.schema.ts` 文件中的辅助导入由 `@nuxthq/studio/theme` 切换为 `@nuxt/content/preview`。

:video{autoplay controls loop poster="https://res.cloudinary.com/nuxt/video/upload/v1737458923/studio/docs-v3_lqfasl.png" src="https://res.cloudinary.com/nuxt/video/upload/v1737458923/studio/docs-v3_lqfasl.mp4"}


# **发布 Nuxt Content 3.0**

我们非常激动地宣布 Nuxt Content 3.0.0 的首个稳定版本 ✨

## 🚀 性能提升

Nuxt Content v3 放弃了基于文件的存储方式，转而采用 SQL 数据库系统。使用数据库代替基于文件的存储可减少查询大规模数据集时的许多 I/O 操作。

::prose-note
全新的数据库系统优化了数据文件的存储和结构方式，确保更佳的性能和可扩展性。此更新完全是幕后进行，不影响您在 Content 中可使用的文件类型（

`yml`

、

`json`

 和 

`markdown`

）。
::

这一切对用户透明，Nuxt Content 依然支持零配置下的开发模式、[服务器托管](https://nuxt-content.zhcndoc.com/docs/deploy/server)和[静态生成](https://nuxt-content.zhcndoc.com/docs/deploy/static)。

此外，现在支持[无服务器托管](https://nuxt-content.zhcndoc.com/docs/deploy/serverless)，客户端导航性能也得到提升。

### 无服务器兼容性

Nuxt Content v2 的一个关键挑战是为了存储所有内容文件导致捆绑包体积过大。这在部署到无服务器或边缘平台如 [Netlify](https://netlify.com){rel="&#x22;nofollow&#x22;"}、[NuxtHub](https://hub.nuxt.com){rel="&#x22;nofollow&#x22;"} 或 [Vercel](https://vercel.com){rel="&#x22;nofollow&#x22;"} 时是个问题。

在无服务器环境中，每个用户请求都会触发 Nuxt 服务器的新实例，每次都是从零开始。此“无状态”特性意味着无法在服务器内存中存储数据，亦不能使用基于文件的数据库如 SQLite。因此，我们实现了数据库适配器，可以独立于你的服务器实例持久化数据。

::prose-note
我们会根据你配置中的

[数据库类型](https://cfec52f9.content-f0q.pages.dev/docs/getting-started/configuration#database){rel=""nofollow""}

手动切换到对应的服务提供者（如 Vercel / Postgres，NuxtHub / D1……）。
::

### 浏览器端的 WASM SQLite

对于客户端导航，模块使用类似的方法。当应用执行第一条内容查询时，会从服务器下载生成的转储文件，并在浏览器内初始化本地 SQLite 数据库。从此之后，所有查询都在本地执行，无需再调用服务器：极大提升了应用响应速度，带来无缝的用户体验。

## 🗄️ 内容集合

集合是 Nuxt Content 项目中相关内容项的分组。它们帮助更高效地组织和管理大型数据集。

### **定义集合**

你现在可以在 [`content.config.ts`](https://nuxt-content.zhcndoc.com/docs/getting-started/configuration) 文件中定义集合，以配置数据库结构、实用类型以及查找、解析和查询内容的方法。

### **集合模式**

模式确保集合内数据的一致性，并提升 TypeScript 的类型推断，以更好地集成 Nuxt Content 工具。

```ts [content.config.ts]
import { defineCollection, z } from '@nuxt/content'

// 导出集合
export const collections = {
  // 使用 `defineCollection` 工具定义集合
  posts: defineCollection({
    // 指定此集合中的内容类型
    type: 'page',
    // 加载匹配此模式的所有文件
    source: 'blog/**/*.md',
    // 为此集合定义自定义模式
    schema: z.object({
      date: z.date(),
      image: z.object({
        src: z.string(),
        alt: z.string()
      }),
      badge: z.object({
        label: z.string(),
        color: z.string()
      })
    })
  }),
}
```

::prose-tip{to="https://nuxt-content.zhcndoc.com/docs/collections/define"}
在文档中了解更多关于集合的内容。
::

## 🔧 简化的 Vue 工具

我们简化了工具，现暴露：

- [queryCollection](https://nuxt-content.zhcndoc.com/docs/utils/query-collection) 用于通过强大的查询构建器获取集合
- [queryCollectionNavigation](https://nuxt-content.zhcndoc.com/docs/utils/query-collection-navigation) 用于获取特定集合生成的导航
- [queryCollectionItemSurroundings](https://nuxt-content.zhcndoc.com/docs/utils/query-collection-item-surroundings) 用于获取特定路径的相邻内容
- [queryCollectionSearchSections](https://nuxt-content.zhcndoc.com/docs/utils/query-collection-search-sections) 用于从集合获取可搜索的章节，增强内容发现

这四个工具允许你在 Vue 页面和组件中高效获取和查询内容：

```vue [pages/blog.vue]
<script setup lang="ts">
const { data: posts } = await useAsyncData('blog', () => {
  return queryCollection('blog').all()
})
</script>

<template>
  <div>
    <h1>博客</h1>
    <ul>
      <li v-for="post in posts" :key="post.id">
        <NuxtLink :to="post.path">{{ post.title }}</NuxtLink>
      </li>
    </ul>
  </div>
</template>
```

## 📦 内置组件

我们更新了组件，只包含必要的部分：

- [ContentRenderer](https://nuxt-content.zhcndoc.com/docs/components/content-renderer) 用于渲染解析后的 Markdown 为 HTML 和 Vue 组件
- [Slot](https://nuxt-content.zhcndoc.com/docs/components/slot) 取代了 `ContentSlot`，因我们现在支持用指令解包，使你的 Vue 组件能完美兼容 Vue 和 Markdown 中的使用
- [Prose 组件](https://nuxt-content.zhcndoc.com/docs/components/prose) 是为 MDC 语法量身打造的预设计组件，集成了样式以提升外观表现

以下是显示 Markdown 文件内容的示例：

```vue [pages/about.vue]
<script lang="ts" setup>
const { data: page } = await useAsyncData(() => {
  return queryCollection('content').path('/about').first()
})
</script>

<template>
  <ContentRenderer v-if="page" :value="page" />
  <p v-else>关于页面尚未编写。</p>
</template>
```

## 🔷 TypeScript 集成

新的集合系统为所有数据自动提供 TypeScript 类型。每个工具和 API 均基于你的集合定义实现强类型，确保开发过程中的类型安全。

## ⬆️ 从 V2 迁移

迁移尽可能简便，因此我们编写了 [迁移指南](https://nuxt-content.zhcndoc.com/docs/getting-started/migration)。

::prose-note
注意，我们决定移除基于文档的驱动模式，以简化模块使用。
::

## 🖼️ Studio 集成

[Nuxt Studio](https://nuxt-content.zhcndoc.com/studio) 是一个可视化编辑运行中 **Nuxt Content** 项目的平台。支持 `Markdown`、`YAML` 和 `JSON` 文件，编辑器确保灵活与易用。

### 预览 API

之前独立的模块 [Studio 模块](https://github.com/nuxtlabs/studio-module){rel="&#x22;nofollow&#x22;"} 已升级得更加通用，现直接集成在 Nuxt Content 作为一个 `预览 API`。

启用 Studio 的预览功能比以往更简单 —— 只需在 Nuxt Content 配置中将 Studio API 设置为你的 `Preview API`：

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  content: {
    preview: {
      api: 'https://api.nuxt.studio'
    }
  }
})
```

这一简化意味着不再需要额外安装模块来支持 Studio，设置更快更简便。此外，预览 API 现已泛化，支持其他服务提供提供顶级的编辑体验。

### **统一文档**

除了集成，我们还将 **Content** 和 **Studio** 的文档与网站统一成一个全面的资源。仅 Studio 平台（用户登录后可用）保持为一个[独立站点](https://nuxt.studio){rel="&#x22;nofollow&#x22;"}。

**我们现在可以在 Studio 中利用数据结构和集合**。Studio 平台支持并适配 **集合** 和 **用户自定义模式**。此改进将支持针对 `YAML` 和 `JSON` 文件及 Markdown 文件中的 front-matter 自动生成表单。


# Nuxt Studio 可视化编辑器幕后揭秘

## **简介**

Nuxt Studio 为开发者和内容撰写者提供了多功能的工作空间，允许他们在两个截然不同的编辑器之间进行选择，用于内容的创建和管理：Markdown 编辑器和可视化编辑器。

![从项目设置中选择你喜欢的编辑器](https://nuxt-content.zhcndoc.com/blog/favorite-editor.webp)

每个编辑器都有其独特的用途——有些用户习惯于 Markdown 编辑，而另一些则更喜欢非技术化的可视化方式。

最终，**这两种编辑器的最终输出都是 Markdown 语法**。

本文将阐述可视化编辑器背后的技术流程，探讨它如何解析 Markdown、如何转换回 Markdown，以及为何这一过程有时可能会导致与原始内容的差异。

## **Markdown 编辑器**

![在 Nuxt Studio 中直接编辑 Markdown](https://nuxt-content.zhcndoc.com/blog/markdown-editor.webp)

Nuxt Studio 中的 Markdown 编辑器允许你完全控制内容，可以直接编写 [MDC](https://nuxt-content.zhcndoc.com/docs/files/markdown)（增强型 Markdown 语法）。该语法支持直接将 Vue 组件集成到 Markdown 文件中，提供了更灵活的页面结构编排能力。

当你在 Markdown 编辑器中保存文件时，内容会完全保持你所编写的形式，保留所有特定语法与格式。对于熟悉 Markdown 并希望精确控制内容布局和结构的用户来说，这款编辑器是理想选择。

## **可视化编辑器**

![在 Nuxt Studio 中使用可视化编辑器编辑你的内容](https://nuxt-content.zhcndoc.com/blog/visual-editor.webp)

可视化编辑器是一种基于 [TipTap](https://tiptap.zhcndoc.com/){rel="&#x22;nofollow&#x22;"} 和 [ProseMirror](https://prosemirror.net/){rel="&#x22;nofollow&#x22;"} 构建的所见即所得（WYSIWYG）工具，旨在屏蔽 Markdown 语法的复杂性，提供更直观的视觉编辑体验。对于不想直接处理原始 Markdown 代码的用户，这款编辑器尤其友好。

### **可视化编辑器如何处理文件**

当你用可视化编辑器打开 Markdown 文件时，Nuxt Studio 首先会解析原始 Markdown 文件。借助 [MDC 模块](https://github.com/nuxt-modules/mdc){rel="&#x22;nofollow&#x22;"}，它生成一个抽象语法树（AST）。随后，该 AST 被转换为 TipTap 兼容的格式（TipTap AST），以便编辑器能够精准地可视化渲染文档内容。

一旦可视化编辑器展示内容，用户便可通过直观的视觉方式进行更新。在幕后，编辑器持续地将 TipTap AST 转换回 MDC AST，再回转为 MDC 语法，确保内容始终保持 Markdown 格式。

### **为什么未修改内容时原始 Markdown 文件会发生变化**

![检测到自动 Markdown 解析时弹出提醒](https://nuxt-content.zhcndoc.com/blog/automatic-parsing-modal.webp)

#### **非关键性变化**

当可视化编辑器将视觉格式转换回 Markdown 时，会应用一套预设的 Markdown 标准解析算法。这些标准有时可能与原内容存在细微差别。这类变化通常影响不大，仅仅是 Markdown 语法的另一种有效写法，渲染后的网站表现应保持一致。

#### **关键性变化**

理想情况下，Markdown 的所有特性都能在可视化编辑器中有直接而准确的对应。我们已构建自定义 TipTap 扩展，以支持自定义 MDC 语法，例如 [Vue 组件](https://nuxt-content.zhcndoc.com/docs/files/markdown#vue-components)编辑或 [front-matter](https://nuxt-content.zhcndoc.com/docs/files/markdown#front-matter) 等。然而，在个别罕见的情况下，尤其是涉及复杂或不常见的 Markdown 元素时，可视化编辑器可能无法完全支持或正确解析这些元素。此时，编辑器可能会在解析过程中对这些元素进行近似处理、简化乃至省略。

这类差异可能导致转换回 Markdown 时出现数据丢失或回退。虽然这种情况较少发生，但有可能影响内容的展示效果或功能。

我们的主要目标是防止任何内容丢失，保持 Markdown 文件的完整性。如果你遇到从可视化编辑器切换回 Markdown 时出现不完美的情况，欢迎在我们的 Discord 服务器上反馈。你的反馈对我们改进和完善可视化编辑器极为重要，能确保满足所有用户的需求。

## **减少非预期变化的最佳实践**

为避免丢失重要格式或内容，请遵循以下建议：

- **避免使用复杂的 HTML 结构**。由于 MDC 语法允许集成 Vue 组件，更推荐创建可复用组件，方便插入 Markdown 并在编辑器内编辑，而不是依赖复杂的 HTML 代码。
- **保持编辑器的一致性**。尽可能选择最适合你需求的编辑器，并在整个页面编辑过程中保持使用同一编辑器。
- **切换编辑器后务必检查变更**。切换编辑器后，务必在审核页面检查 Markdown 内容，并通过预览确保没有重要元素被修改。

## **结语**

在 Nuxt Studio 中切换 Markdown 编辑器和可视化编辑器可以带来灵活的编辑体验，但需要注意背后的技术影响。

理解可视化编辑器如何处理和转换 Markdown，有助于确保你所撰写的 Markdown 内容能准确地在可视化编辑器中显示，使非技术用户能够轻松编辑所有内容，而不破坏原始 Markdown 文件。

###


# 可视化 Front-matter 编辑

::warning
本文发布于 2025 年 1 月 6 日 

[Content](https://github.com/nuxt/content){rel=""nofollow""}

 和 

[Studio](https://github.com/nuxtlabs/studio-module){rel=""nofollow""}

 模块合并之前。因此，本文可能存在一些不一致之处。Studio 模块现已弃用，作为 Content 模块的可选功能提供。请参阅

[这份指南](https://nuxt-content.zhcndoc.com/docs/getting-started)

了解如何启用。
::

## 可视化 Front-Matter 编辑

现在您无需编写 `YAML` 语法即可编辑 markdown front-matter。Nuxt Studio 会自动生成用户友好的表单，简化元数据编辑。

:video{autoplay controls loop poster="https://res.cloudinary.com/nuxt/video/upload/v1729157955/frontmatterform2_rmh58v.jpg" src="https://res.cloudinary.com/nuxt/video/upload/v1729157955/frontmatterform2_rmh58v.mp4"}

## 什么是 Front-matter？

Front-matter 是基于 Markdown 的 CMS 中用于为页面提供元数据（如描述、标题等）的约定。在 [Nuxt Content](https://nuxt-content.zhcndoc.com/docs/files/markdown#front-matter) 中，front-matter 使用的是 YAML 语法。

::callout
---
icon: i-ph-info
to: https://nuxt-content.zhcndoc.com/docs/files/markdown#front-matter
---
关于 front-matter 语法的详细信息，请参阅 Nuxt Content 文档。
::

## 我们非技术编辑器的最后一环

Nuxt Studio 从发布编辑器起就以非技术用户为设计核心。我们的目标是让每个人都能轻松编辑 markdown 和内容。

自动生成 front-matter 表单是下一步的合理进展。通过摆脱 YAML 语法的复杂性，简化了非开发者的编辑流程，提供动态输入选项，如图片选择器、日期选择器、布尔切换等。此增强使我们实现了完全可视化且用户友好的内容管理体验。

## 扩展至所有 YAML 和 JSON 文件

不久之后，表单生成功能将扩展至您在 Nuxt Studio 中编辑的所有 `YAML` 和 `JSON` 文件，让结构化数据的操作更为轻松便捷。

## 展望 Nuxt Content v3

::callout{icon="i-ph-lightbulb"}
本节内容仅为 

[Nuxt Content v3](https://github.com/nuxt/content/tree/v3){rel=""nofollow""}

 的预告，我们将很快发布更详尽的博文。
::

我们正积极开发下一重大版本 Nuxt Content，这将带来显著的性能提升和新功能，进一步提升内容管理体验。

### 性能优化

Nuxt Content v2 的一大挑战是需要较大的包体积来存储所有内容文件，这在向边缘平台（如 [NuxtHub](https://hub.nuxt.com/){rel="&#x22;nofollow&#x22;"}）部署时造成了问题。

为解决此问题，Nuxt Content v3 在生产环境中不再使用基于文件的存储方式，而是采用 SQL 数据库系统。此变更对用户透明。我们为开发模式、静态生成、服务器渲染及通过 NuxtHub 的边缘部署提供零配置支持。

### 引入 Collections（集合）

Collections 是 Nuxt Content 项目中相关内容项的分组，帮助更高效地组织和管理大型数据集。

#### 定义 Collections

您可以在 `content.config.ts` 文件中定义 collections，Nuxt Content 将用它配置数据库结构、类型工具及用于查找、解析和查询内容的方法。

#### Collections 方案（Schema）

方案可确保 collections 内部的一致性，并改善 TypeScript 类型定义，增强与 Nuxt Content 工具的集成。

```ts [content.config.ts]
import { defineCollection, z } from '@nuxt/content'

// 导出 collections
export const collections = {
  // 使用 `defineCollection` 工具定义 collection
  posts: defineCollection({
    // 指定该 collection 中内容的类型
    type: 'page',
    // 加载匹配此模式的所有文件
    source: 'blog/**/*.md',
    // 为该 collection 定义自定义 schema
    schema: z.object({
      date: z.date(),
      image: z.object({
        src: z.string(),
        alt: z.string()
      }),
      badge: z.object({
        label: z.string(),
        color: z.string()
      })
    })
  }),
}
```

### 针对 Nuxt Studio 精心打造

::warning
本文发布于 v3.7 之前，了解如何迁移请参考

[此指南](https://github.com/nuxt/content/blob/main/CHANGELOG.md#370-2025-09-12){rel=""nofollow""}

。
::

Nuxt Studio 最初与 Nuxt Content v2 同步开发，但在 v3 中，我们以 Nuxt Studio 体验为目标重构模块。我们的宗旨是打造最佳内容编辑 CMS 平台，同时提供极佳的开发者体验。

例如，collection schema 将助力我们进一步增强 Studio 中的表单生成。您甚至可以直接在 schema 中设置字段的编辑器类型。

```ts [content.config.ts]
image: z.object({
    src: z.string().editor({ type: 'media' }),
    alt: z.string()
}),
icon: z.string().editor({ type: 'icon' })
```

::callout{icon="i-ph-lightbulb" to="https://github.com/nuxt/content/tree/main"}
Nuxt Content v3 已正式发布。欢迎尝试并向我们反馈意见。
::


# Studio 表单自定义

::warning
本文发布于 v3.7 之前，请参考

[本指南](https://github.com/nuxt/content/blob/main/CHANGELOG.md#370-2025-09-12){rel=""nofollow""}

进行迁移。
::

[Studio](https://nuxt.studio){rel="&#x22;nofollow&#x22;"} 表单是基于您内容配置文件中定义的集合模式动态生成的。无论您是在编辑 `Markdown` 文件的 [frontmatter](https://nuxt-content.zhcndoc.com/docs/files/markdown#frontmatter)，还是 `JSON` / `YAML` 文件，这种行为都是适用的。

:video{autoplay controls poster="https://res.cloudinary.com/nuxt/video/upload/v1739982761/frontmatterform_yjafgt.png" src="https://res.cloudinary.com/nuxt/video/upload/v1739982761/frontmatterform_yjafgt.mp4"}

## **使用** `zod` **模式定义您的表单**

Nuxt Content 利用 [zod](https://github.com/colinhacks/zod){rel="&#x22;nofollow&#x22;"} 让您定义一种类型安全的内容模式。此模式不仅用于验证您的数据，还为 **Studio** 中的表单生成提供支持。

### **内置的 zod 辅助工具**

您可以通过向集合添加 `schema` 属性并使用 [zod](https://github.com/colinhacks/zod){rel="&#x22;nofollow&#x22;"} 模式来定义您的内容模式。

`@nuxt/content` 暴露了一个 `z` 对象，包含一组用于常见数据类型的 [Zod](https://nuxt-content.zhcndoc.com) 工具。

::prose-code-group
```ts [content.config.ts]
export default defineContentConfig({
  collections: {
    posts: defineCollection({
      type: 'page',
      source: 'blog/*.md',
      schema: z.object({
        draft: z.boolean().default(false),
        category: z.enum(['Alps', 'Himalaya', 'Pyrenees']).optional(),
        date: z.date(),
        image: z.object({
          src: z.string().editor({ input: 'media' }),
          alt: z.string(),
        }),
        slug: z.string().editor({ hidden: true }),
        icon: z.string().optional().editor({ input: 'icon' }),
        authors: z.array(z.object({
          slug: z.string(),
          username: z.string(),
          name: z.string(),
          to: z.string(),
          avatar: z.object({
            src: z.string(),
            alt: z.string(),
          }),
        })),
      }),
    }),
  },
})    
```

  :::code-preview{icon="i-lucide-eye" label="生成的表单"}
  ![表单预览](https://nuxt-content.zhcndoc.com/docs/studio/preview-schema.png)
  :::
::

### **原生输入映射**

原始 Zod 类型会自动映射为 **Studio** 中相应的表单输入：

- **字符串** → 文本输入框
- **日期** → 日期选择器
- **数字** → 数字输入（计数器）
- **布尔值** → 开关切换
- **枚举** → 下拉选择框
- **字符串数组** → 徽章输入列表
- **对象数组** → 可折叠项嵌套表单

:video{autoplay controls loop poster="https://res.cloudinary.com/nuxt/video/upload/v1740679550/arrayobjectandstring_r1jpvz.jpg" src="https://res.cloudinary.com/nuxt/video/upload/v1740679550/arrayobjectandstring_r1jpvz.mp4"}

### 自定义输入映射

内容不仅限于原始类型。您可以使用 `editor` 方法自定义表单字段，该方法通过元数据扩展 Zod 类型，以增强编辑器界面功能。

这使您能够定义自定义输入或者隐藏字段。

#### 用法

```ts [content.config.ts]
mainScreen: z.string().editor({ input: 'media' })
```

#### 选项

##### `input: 'media' | 'icon'`

您可以设置编辑器输入类型。目前支持 icon 和 media，因为它们已在 Studio 编辑器中被处理。

##### `hidden: Boolean`

此选项可用于避免字段在 Studio 编辑器中显示。

::prose-tip
Studio 输入完全可扩展。我们可以根据用户需求创建任意数量的输入控件。
::


# 视觉化 YAML 和 JSON 文件编辑

::warning
本文发表于 

[Content](https://github.com/nuxt/content){rel=""nofollow""}

 和 

[Studio](https://github.com/nuxtlabs/studio-module){rel=""nofollow""}

 模块于 2025 年 1 月 6 日合并之前。因此，文中内容可能存在一些不一致之处。Studio 模块现已废弃，并作为 Content 模块的可选功能提供。请参阅 

[此指南](https://nuxt-content.zhcndoc.com/docs/getting-started)

 了解如何启用。
::

## `YAML` 和 `JSON` 文件的自动生成表单

:video{controls loop src="https://res.cloudinary.com/nuxt/video/upload/v1730132248/yml-json-form_n9czcs.mp4"}

延续我们让 Nuxt Studio 成为非技术用户编辑 Nuxt 网站内容工具的旅程，我们很高兴地宣布，现在可以通过生成的视觉表单来编辑 `YAML` 和 `JSON` 文件。这次更新免去了用户直接操作复杂文件语法（如 YAML 或 JSON）的需求。

::callout{icon="i-ph-info"}
目前数组尚未通过表单支持，但我们计划在 Nuxt Content v3 发布集合和用户定义的 schema 后进行支持。详见下文章节。
::

### 同步导航

此次更新同时改进了非 Markdown 格式（如 YAML 和 JSON）预览与所选文件间的同步导航。请将 Studio 模块更新至最新版本 `v2.2.0` 以应用此修复。

## 迈向 Nuxt Content v3

我们很高兴地宣布，Nuxt Content v3 的第四个 alpha 版本已发布，且 [**草稿文档**](https://content.nuxt.com/){rel="&#x22;nofollow&#x22;"} 已开放。

### 下一步？

未来几个月，我们将专注于测试和优化 Nuxt Content v3，确保其稳健且适合生产环境发布。以下是与 Nuxt Studio 相关的主要改进：

- **合并 Studio 模块**：不久后，Studio 模块将直接集成进 Nuxt Content。Nuxt Content v3 发布后，只需在 `nuxt.config.ts` 文件中设置 `content.editor: true` 即可启用 Studio。该简化意味着无需额外模块，安装更快捷。
- **统一文档**：模块合并后，我们将把 [Content](https://content.nuxt.com){rel="&#x22;nofollow&#x22;"} 和 [Studio](https://nuxt.studio){rel="&#x22;nofollow&#x22;"} 的文档及网站合并为一个综合资源。Studio 平台本身（用户登录后可用）将作为独立站点保留。
- **充分利用 Studio 中的数据结构和集合**：借助 Nuxt Content v3，Studio 平台将支持并适配 [集合](https://nuxt-content.zhcndoc.com/docs/collections/define) 和用户定义的 schema，实现针对 YAML、JSON 文件及 Markdown 的 front-matter 的基于 schema 的表单生成。

这些更新体现了我们为您的 Nuxt 网站提供最佳内容编辑平台的承诺。敬请期待！
