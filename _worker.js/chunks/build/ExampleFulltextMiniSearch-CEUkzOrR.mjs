import{v as t,b as e,b0 as s,g as i,e as n}from"./server.mjs";import{_ as o}from"./Card-B-NiSkzk.mjs";import{_ as r}from"./Input-BIiLMz6d.mjs";import{bO as c,bU as a,c5 as u}from"../nitro/nitro.mjs";import"node:buffer";import"node:events";import"node:process";import"node:timers";import"node:async_hooks";import"cloudflare:workers";import"node:path";const l="KEYS",d="VALUES",h="";class TreeIterator{constructor(t,e){const s=t._tree,i=Array.from(s.keys());this.set=t,this._type=e,this._path=i.length>0?[{node:s,keys:i}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(0===this._path.length)return{done:!0,value:void 0};const{node:t,keys:e}=last$1(this._path);if(last$1(e)===h)return{done:!1,value:this.result()};const s=t.get(last$1(e));return this._path.push({node:s,keys:Array.from(s.keys())}),this.dive()}backtrack(){if(0===this._path.length)return;const t=last$1(this._path).keys;t.pop(),t.length>0||(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>last$1(t)).filter(t=>t!==h).join("")}value(){return last$1(this._path).node.get(h)}result(){switch(this._type){case d:return this.value();case l:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const last$1=t=>t[t.length-1],recurse=(t,e,s,i,n,o,r,c)=>{const a=o*r;t:for(const u of t.keys())if(u===h){const e=n[a-1];e<=s&&i.set(c,[t.get(u),e])}else{let a=o;for(let t=0;t<u.length;++t,++a){const i=u[t],o=r*a,c=o-r;let l=n[o];const d=Math.max(0,a-s-1),h=Math.min(r-1,a+s);for(let t=d;t<h;++t){const s=i!==e[t],r=n[c+t]+ +s,a=n[c+t+1]+1,u=n[o+t]+1,d=n[o+t+1]=Math.min(r,a,u);d<l&&(l=d)}if(l>s)continue t}recurse(t.get(u),e,s,i,n,a,r,c+u)}};class SearchableMap{constructor(t=new Map,e=""){this._size=void 0,this._tree=t,this._prefix=e}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[e,s]=trackDown(this._tree,t.slice(this._prefix.length));if(void 0===e){const[e,i]=last(s);for(const s of e.keys())if(s!==h&&s.startsWith(i)){const n=new Map;return n.set(s.slice(i.length),e.get(s)),new SearchableMap(n,t)}}return new SearchableMap(e,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,remove(this._tree,t)}entries(){return new TreeIterator(this,"ENTRIES")}forEach(t){for(const[e,s]of this)t(e,s,this)}fuzzyGet(t,e){return((t,e,s)=>{const i=new Map;if(void 0===e)return i;const n=e.length+1,o=n+s,r=new Uint8Array(o*n).fill(s+1);for(let t=0;t<n;++t)r[t]=t;for(let t=1;t<o;++t)r[t*n]=t;return recurse(t,e,s,i,r,1,n,""),i})(this._tree,t,e)}get(t){const e=lookup(this._tree,t);return void 0!==e?e.get(h):void 0}has(t){const e=lookup(this._tree,t);return void 0!==e&&e.has(h)}keys(){return new TreeIterator(this,l)}set(t,e){if("string"!=typeof t)throw new Error("key must be a string");this._size=void 0;return createPath(this._tree,t).set(h,e),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,e){if("string"!=typeof t)throw new Error("key must be a string");this._size=void 0;const s=createPath(this._tree,t);return s.set(h,e(s.get(h))),this}fetch(t,e){if("string"!=typeof t)throw new Error("key must be a string");this._size=void 0;const s=createPath(this._tree,t);let i=s.get(h);return void 0===i&&s.set(h,i=e()),i}values(){return new TreeIterator(this,d)}[Symbol.iterator](){return this.entries()}static from(t){const e=new SearchableMap;for(const[s,i]of t)e.set(s,i);return e}static fromObject(t){return SearchableMap.from(Object.entries(t))}}const trackDown=(t,e,s=[])=>{if(0===e.length||null==t)return[t,s];for(const i of t.keys())if(i!==h&&e.startsWith(i))return s.push([t,i]),trackDown(t.get(i),e.slice(i.length),s);return s.push([t,e]),trackDown(void 0,"",s)},lookup=(t,e)=>{if(0===e.length||null==t)return t;for(const s of t.keys())if(s!==h&&e.startsWith(s))return lookup(t.get(s),e.slice(s.length))},createPath=(t,e)=>{const s=e.length;t:for(let i=0;t&&i<s;){for(const n of t.keys())if(n!==h&&e[i]===n[0]){const o=Math.min(s-i,n.length);let r=1;for(;r<o&&e[i+r]===n[r];)++r;const c=t.get(n);if(r===n.length)t=c;else{const s=new Map;s.set(n.slice(r),c),t.set(e.slice(i,i+r),s),t.delete(n),t=s}i+=r;continue t}const n=new Map;return t.set(e.slice(i),n),n}return t},remove=(t,e)=>{const[s,i]=trackDown(t,e);if(void 0!==s)if(s.delete(h),0===s.size)cleanup(i);else if(1===s.size){const[t,e]=s.entries().next().value;merge(i,t,e)}},cleanup=t=>{if(0===t.length)return;const[e,s]=last(t);if(e.delete(s),0===e.size)cleanup(t.slice(0,-1));else if(1===e.size){const[s,i]=e.entries().next().value;s!==h&&merge(t.slice(0,-1),s,i)}},merge=(t,e,s)=>{if(0===t.length)return;const[i,n]=last(t);i.set(n+e,s),i.delete(n)},last=t=>t[t.length-1],f="or",m="and",p="and_not";class MiniSearch{constructor(t){if(null==(null==t?void 0:t.fields))throw new Error('MiniSearch: option "fields" must be provided');const e=null==t.autoVacuum||!0===t.autoVacuum?S:t.autoVacuum;this._options={...g,...t,autoVacuum:e,searchOptions:{...w,...t.searchOptions||{}},autoSuggestOptions:{...x,...t.autoSuggestOptions||{}}},this._index=new SearchableMap,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=v,this.addFields(this._options.fields)}add(t){const{extractField:e,tokenize:s,processTerm:i,fields:n,idField:o}=this._options,r=e(t,o);if(null==r)throw new Error(`MiniSearch: document does not have ID field "${o}"`);if(this._idToShortId.has(r))throw new Error(`MiniSearch: duplicate ID ${r}`);const c=this.addDocumentId(r);this.saveStoredFields(c,t);for(const o of n){const n=e(t,o);if(null==n)continue;const r=s(n.toString(),o),a=this._fieldIds[o],u=new Set(r).size;this.addFieldLength(c,a,this._documentCount-1,u);for(const t of r){const e=i(t,o);if(Array.isArray(e))for(const t of e)this.addTerm(a,c,t);else e&&this.addTerm(a,c,e)}}}addAll(t){for(const e of t)this.add(e)}addAllAsync(t,e={}){const{chunkSize:s=10}=e,i={chunk:[],promise:Promise.resolve()},{chunk:n,promise:o}=t.reduce(({chunk:t,promise:e},i,n)=>(t.push(i),(n+1)%s===0?{chunk:[],promise:e.then(()=>new Promise(t=>setTimeout(t,0))).then(()=>this.addAll(t))}:{chunk:t,promise:e}),i);return o.then(()=>this.addAll(n))}remove(t){const{tokenize:e,processTerm:s,extractField:i,fields:n,idField:o}=this._options,r=i(t,o);if(null==r)throw new Error(`MiniSearch: document does not have ID field "${o}"`);const c=this._idToShortId.get(r);if(null==c)throw new Error(`MiniSearch: cannot remove document with ID ${r}: it is not in the index`);for(const o of n){const n=i(t,o);if(null==n)continue;const r=e(n.toString(),o),a=this._fieldIds[o],u=new Set(r).size;this.removeFieldLength(c,a,this._documentCount,u);for(const t of r){const e=s(t,o);if(Array.isArray(e))for(const t of e)this.removeTerm(a,c,t);else e&&this.removeTerm(a,c,e)}}this._storedFields.delete(c),this._documentIds.delete(c),this._idToShortId.delete(r),this._fieldLength.delete(c),this._documentCount-=1}removeAll(t){if(t)for(const e of t)this.remove(e);else{if(arguments.length>0)throw new Error("Expected documents to be present. Omit the argument to remove all documents.");this._index=new SearchableMap,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldLength=new Map,this._avgFieldLength=[],this._storedFields=new Map,this._nextId=0}}discard(t){const e=this._idToShortId.get(t);if(null==e)throw new Error(`MiniSearch: cannot discard document with ID ${t}: it is not in the index`);this._idToShortId.delete(t),this._documentIds.delete(e),this._storedFields.delete(e),(this._fieldLength.get(e)||[]).forEach((t,s)=>{this.removeFieldLength(e,s,this._documentCount,t)}),this._fieldLength.delete(e),this._documentCount-=1,this._dirtCount+=1,this.maybeAutoVacuum()}maybeAutoVacuum(){if(!1===this._options.autoVacuum)return;const{minDirtFactor:t,minDirtCount:e,batchSize:s,batchWait:i}=this._options.autoVacuum;this.conditionalVacuum({batchSize:s,batchWait:i},{minDirtCount:e,minDirtFactor:t})}discardAll(t){const e=this._options.autoVacuum;try{this._options.autoVacuum=!1;for(const e of t)this.discard(e)}finally{this._options.autoVacuum=e}this.maybeAutoVacuum()}replace(t){const{idField:e,extractField:s}=this._options,i=s(t,e);this.discard(i),this.add(t)}vacuum(t={}){return this.conditionalVacuum(t)}conditionalVacuum(t,e){return this._currentVacuum?(this._enqueuedVacuumConditions=this._enqueuedVacuumConditions&&e,null!=this._enqueuedVacuum||(this._enqueuedVacuum=this._currentVacuum.then(()=>{const e=this._enqueuedVacuumConditions;return this._enqueuedVacuumConditions=v,this.performVacuuming(t,e)})),this._enqueuedVacuum):!1===this.vacuumConditionsMet(e)?Promise.resolve():(this._currentVacuum=this.performVacuuming(t),this._currentVacuum)}async performVacuuming(t,e){const s=this._dirtCount;if(this.vacuumConditionsMet(e)){const e=t.batchSize||y.batchSize,i=t.batchWait||y.batchWait;let n=1;for(const[t,s]of this._index){for(const[t,e]of s)for(const[i]of e)this._documentIds.has(i)||(e.size<=1?s.delete(t):e.delete(i));0===this._index.get(t).size&&this._index.delete(t),n%e===0&&await new Promise(t=>setTimeout(t,i)),n+=1}this._dirtCount-=s}await null,this._currentVacuum=this._enqueuedVacuum,this._enqueuedVacuum=null}vacuumConditionsMet(t){if(null==t)return!0;let{minDirtCount:e,minDirtFactor:s}=t;return e=e||S.minDirtCount,s=s||S.minDirtFactor,this.dirtCount>=e&&this.dirtFactor>=s}get isVacuuming(){return null!=this._currentVacuum}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}has(t){return this._idToShortId.has(t)}getStoredFields(t){const e=this._idToShortId.get(t);if(null!=e)return this._storedFields.get(e)}search(t,e={}){const{searchOptions:s}=this._options,i={...s,...e},n=this.executeQuery(t,e),o=[];for(const[t,{score:e,terms:s,match:r}]of n){const n=s.length||1,c={id:this._documentIds.get(t),score:e*n,terms:Object.keys(r),queryTerms:s,match:r};Object.assign(c,this._storedFields.get(t)),(null==i.filter||i.filter(c))&&o.push(c)}return t===MiniSearch.wildcard&&null==i.boostDocument||o.sort(byScore),o}autoSuggest(t,e={}){e={...this._options.autoSuggestOptions,...e};const s=new Map;for(const{score:i,terms:n}of this.search(t,e)){const t=n.join(" "),e=s.get(t);null!=e?(e.score+=i,e.count+=1):s.set(t,{score:i,terms:n,count:1})}const i=[];for(const[t,{score:e,terms:n,count:o}]of s)i.push({suggestion:t,terms:n,score:e/o});return i.sort(byScore),i}get documentCount(){return this._documentCount}get termCount(){return this._index.size}static loadJSON(t,e){if(null==e)throw new Error("MiniSearch: loadJSON should be given the same options used when serializing the index");return this.loadJS(JSON.parse(t),e)}static async loadJSONAsync(t,e){if(null==e)throw new Error("MiniSearch: loadJSON should be given the same options used when serializing the index");return this.loadJSAsync(JSON.parse(t),e)}static getDefault(t){if(g.hasOwnProperty(t))return getOwnProperty(g,t);throw new Error(`MiniSearch: unknown option "${t}"`)}static loadJS(t,e){const{index:s,documentIds:i,fieldLength:n,storedFields:o,serializationVersion:r}=t,c=this.instantiateMiniSearch(t,e);c._documentIds=objectToNumericMap(i),c._fieldLength=objectToNumericMap(n),c._storedFields=objectToNumericMap(o);for(const[t,e]of c._documentIds)c._idToShortId.set(e,t);for(const[t,e]of s){const s=new Map;for(const t of Object.keys(e)){let i=e[t];1===r&&(i=i.ds),s.set(parseInt(t,10),objectToNumericMap(i))}c._index.set(t,s)}return c}static async loadJSAsync(t,e){const{index:s,documentIds:i,fieldLength:n,storedFields:o,serializationVersion:r}=t,c=this.instantiateMiniSearch(t,e);c._documentIds=await objectToNumericMapAsync(i),c._fieldLength=await objectToNumericMapAsync(n),c._storedFields=await objectToNumericMapAsync(o);for(const[t,e]of c._documentIds)c._idToShortId.set(e,t);let a=0;for(const[t,e]of s){const s=new Map;for(const t of Object.keys(e)){let i=e[t];1===r&&(i=i.ds),s.set(parseInt(t,10),await objectToNumericMapAsync(i))}++a%1e3==0&&await wait(0),c._index.set(t,s)}return c}static instantiateMiniSearch(t,e){const{documentCount:s,nextId:i,fieldIds:n,averageFieldLength:o,dirtCount:r,serializationVersion:c}=t;if(1!==c&&2!==c)throw new Error("MiniSearch: cannot deserialize an index created with an incompatible version");const a=new MiniSearch(e);return a._documentCount=s,a._nextId=i,a._idToShortId=new Map,a._fieldIds=n,a._avgFieldLength=o,a._dirtCount=r||0,a._index=new SearchableMap,a}executeQuery(t,e={}){if(t===MiniSearch.wildcard)return this.executeWildcardQuery(e);if("string"!=typeof t){const s={...e,...t,queries:void 0},i=t.queries.map(t=>this.executeQuery(t,s));return this.combineResults(i,s.combineWith)}const{tokenize:s,processTerm:i,searchOptions:n}=this._options,o={tokenize:s,processTerm:i,...n,...e},{tokenize:r,processTerm:c}=o,a=r(t).flatMap(t=>c(t)).filter(t=>!!t).map(termToQuerySpec(o)).map(t=>this.executeQuerySpec(t,o));return this.combineResults(a,o.combineWith)}executeQuerySpec(t,e){const s={...this._options.searchOptions,...e},i=(s.fields||this._options.fields).reduce((t,e)=>({...t,[e]:getOwnProperty(s.boost,e)||1}),{}),{boostDocument:n,weights:o,maxFuzzy:r,bm25:c}=s,{fuzzy:a,prefix:u}={...w.weights,...o},l=this._index.get(t.term),d=this.termResults(t.term,t.term,1,t.termBoost,l,i,n,c);let h,f;if(t.prefix&&(h=this._index.atPrefix(t.term)),t.fuzzy){const e=!0===t.fuzzy?.2:t.fuzzy,s=e<1?Math.min(r,Math.round(t.term.length*e)):e;s&&(f=this._index.fuzzyGet(t.term,s))}if(h)for(const[e,s]of h){const o=e.length-t.term.length;if(!o)continue;null==f||f.delete(e);const r=u*e.length/(e.length+.3*o);this.termResults(t.term,e,r,t.termBoost,s,i,n,c,d)}if(f)for(const e of f.keys()){const[s,o]=f.get(e);if(!o)continue;const r=a*e.length/(e.length+o);this.termResults(t.term,e,r,t.termBoost,s,i,n,c,d)}return d}executeWildcardQuery(t){const e=new Map,s={...this._options.searchOptions,...t};for(const[t,i]of this._documentIds){const n=s.boostDocument?s.boostDocument(i,"",this._storedFields.get(t)):1;e.set(t,{score:n,terms:[],match:{}})}return e}combineResults(t,e=f){if(0===t.length)return new Map;const s=e.toLowerCase(),i=_[s];if(!i)throw new Error(`Invalid combination operator: ${e}`);return t.reduce(i)||new Map}toJSON(){const t=[];for(const[e,s]of this._index){const i={};for(const[t,e]of s)i[t]=Object.fromEntries(e);t.push([e,i])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}termResults(t,e,s,i,n,o,r,c,a=new Map){if(null==n)return a;for(const u of Object.keys(o)){const l=o[u],d=this._fieldIds[u],h=n.get(d);if(null==h)continue;let f=h.size;const m=this._avgFieldLength[d];for(const n of h.keys()){if(!this._documentIds.has(n)){this.removeTerm(d,n,e),f-=1;continue}const o=r?r(this._documentIds.get(n),e,this._storedFields.get(n)):1;if(!o)continue;const p=h.get(n),_=this._fieldLength.get(n)[d],g=s*i*l*o*calcBM25Score(p,f,this._documentCount,_,m,c),w=a.get(n);if(w){w.score+=g,assignUniqueTerm(w.terms,t);const s=getOwnProperty(w.match,e);s?s.push(u):w.match[e]=[u]}else a.set(n,{score:g,terms:[t],match:{[e]:[u]}})}}return a}addTerm(t,e,s){const i=this._index.fetch(s,createMap);let n=i.get(t);if(null==n)n=new Map,n.set(e,1),i.set(t,n);else{const t=n.get(e);n.set(e,(t||0)+1)}}removeTerm(t,e,s){if(!this._index.has(s))return void this.warnDocumentChanged(e,t,s);const i=this._index.fetch(s,createMap),n=i.get(t);null==n||null==n.get(e)?this.warnDocumentChanged(e,t,s):n.get(e)<=1?n.size<=1?i.delete(t):n.delete(e):n.set(e,n.get(e)-1),0===this._index.get(s).size&&this._index.delete(s)}warnDocumentChanged(t,e,s){for(const i of Object.keys(this._fieldIds))if(this._fieldIds[i]===e)return void this._options.logger("warn",`MiniSearch: document with ID ${this._documentIds.get(t)} has changed before removal: term "${s}" was not present in field "${i}". Removing a document after it has changed can corrupt the index!`,"version_conflict")}addDocumentId(t){const e=this._nextId;return this._idToShortId.set(t,e),this._documentIds.set(e,t),this._documentCount+=1,this._nextId+=1,e}addFields(t){for(let e=0;e<t.length;e++)this._fieldIds[t[e]]=e}addFieldLength(t,e,s,i){let n=this._fieldLength.get(t);null==n&&this._fieldLength.set(t,n=[]),n[e]=i;const o=(this._avgFieldLength[e]||0)*s+i;this._avgFieldLength[e]=o/(s+1)}removeFieldLength(t,e,s,i){if(1===s)return void(this._avgFieldLength[e]=0);const n=this._avgFieldLength[e]*s-i;this._avgFieldLength[e]=n/(s-1)}saveStoredFields(t,e){const{storeFields:s,extractField:i}=this._options;if(null==s||0===s.length)return;let n=this._storedFields.get(t);null==n&&this._storedFields.set(t,n={});for(const t of s){const s=i(e,t);void 0!==s&&(n[t]=s)}}}MiniSearch.wildcard=Symbol("*");const getOwnProperty=(t,e)=>Object.prototype.hasOwnProperty.call(t,e)?t[e]:void 0,_={[f]:(t,e)=>{for(const s of e.keys()){const i=t.get(s);if(null==i)t.set(s,e.get(s));else{const{score:t,terms:n,match:o}=e.get(s);i.score=i.score+t,i.match=Object.assign(i.match,o),assignUniqueTerms(i.terms,n)}}return t},[m]:(t,e)=>{const s=new Map;for(const i of e.keys()){const n=t.get(i);if(null==n)continue;const{score:o,terms:r,match:c}=e.get(i);assignUniqueTerms(n.terms,r),s.set(i,{score:n.score+o,terms:n.terms,match:Object.assign(n.match,c)})}return s},[p]:(t,e)=>{for(const s of e.keys())t.delete(s);return t}},calcBM25Score=(t,e,s,i,n,o)=>{const{k:r,b:c,d:a}=o;return Math.log(1+(s-e+.5)/(e+.5))*(a+t*(r+1)/(t+r*(1-c+c*i/n)))},termToQuerySpec=t=>(e,s,i)=>({term:e,fuzzy:"function"==typeof t.fuzzy?t.fuzzy(e,s,i):t.fuzzy||!1,prefix:"function"==typeof t.prefix?t.prefix(e,s,i):!0===t.prefix,termBoost:"function"==typeof t.boostTerm?t.boostTerm(e,s,i):1}),g={idField:"id",extractField:(t,e)=>t[e],tokenize:t=>t.split(b),processTerm:t=>t.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(t,e)=>{"function"==typeof(null===console||void 0===console?void 0:console[t])&&console[t](e)},autoVacuum:!0},w={combineWith:f,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:{k:1.2,b:.7,d:.5}},x={combineWith:"and",prefix:(t,e,s)=>e===s.length-1},y={batchSize:1e3,batchWait:10},v={minDirtFactor:.1,minDirtCount:20},S={...y,...v},assignUniqueTerm=(t,e)=>{t.includes(e)||t.push(e)},assignUniqueTerms=(t,e)=>{for(const s of e)t.includes(s)||t.push(s)},byScore=({score:t},{score:e})=>e-t,createMap=()=>new Map,objectToNumericMap=t=>{const e=new Map;for(const s of Object.keys(t))e.set(parseInt(s,10),t[s]);return e},objectToNumericMapAsync=async t=>{const e=new Map;let s=0;for(const i of Object.keys(t))e.set(parseInt(i,10),t[i]),++s%1e3==0&&await wait(0);return e},wait=t=>new Promise(e=>setTimeout(e,t)),b=/[\n\r\p{Z}\p{P}]+/u,z=t.defineComponent({__name:"ExampleFulltextMiniSearch",__ssrInlineRender:!0,async setup(l){let d,h;const f=t.ref(""),{data:m}=([d,h]=t.withAsyncContext(()=>e("search-data",()=>s("docs"))),d=await d,h(),d),p=new MiniSearch({fields:["title","content"],storeFields:["title","content"],searchOptions:{prefix:!0,fuzzy:.2}});p.addAll(t.toValue(m.value||[]));const _=t.computed(()=>p.search(t.toValue(f)).slice(0,10));return(e,s,l,d)=>{const h=o,m=r,p=i;s(c(n,t.mergeProps({class:"p-4"},d),{default:t.withCtx((e,s,i,n)=>{if(!s)return[t.createVNode(h,null,{default:t.withCtx(()=>[t.createVNode(m,{modelValue:t.unref(f),"onUpdate:modelValue":e=>t.isRef(f)?f.value=e:null,placeholder:"Search...",class:"w-full"},null,8,["modelValue","onUpdate:modelValue"]),t.createVNode("ul",null,[(t.openBlock(!0),t.createBlock(t.Fragment,null,t.renderList(t.unref(_),e=>(t.openBlock(),t.createBlock("li",{key:e.id,class:"mt-2"},[t.createVNode(p,{variant:"ghost",class:"w-full",to:e.id},{default:t.withCtx(()=>[t.createVNode("div",{class:"flex flex-col"},[t.createVNode("span",{class:"text-black dark:text-white font-semibold"},t.toDisplayString(e.title),1),t.createVNode("span",{class:"text-gray-500 text-xs truncate"},t.toDisplayString(e.content?.slice(0,100))+"... ",1)])]),_:2},1032,["to"])]))),128))])]),_:1})];s(c(h,null,{default:t.withCtx((e,s,i,n)=>{if(!s)return[t.createVNode(m,{modelValue:t.unref(f),"onUpdate:modelValue":e=>t.isRef(f)?f.value=e:null,placeholder:"Search...",class:"w-full"},null,8,["modelValue","onUpdate:modelValue"]),t.createVNode("ul",null,[(t.openBlock(!0),t.createBlock(t.Fragment,null,t.renderList(t.unref(_),e=>(t.openBlock(),t.createBlock("li",{key:e.id,class:"mt-2"},[t.createVNode(p,{variant:"ghost",class:"w-full",to:e.id},{default:t.withCtx(()=>[t.createVNode("div",{class:"flex flex-col"},[t.createVNode("span",{class:"text-black dark:text-white font-semibold"},t.toDisplayString(e.title),1),t.createVNode("span",{class:"text-gray-500 text-xs truncate"},t.toDisplayString(e.content?.slice(0,100))+"... ",1)])]),_:2},1032,["to"])]))),128))])];s(c(m,{modelValue:t.unref(f),"onUpdate:modelValue":e=>t.isRef(f)?f.value=e:null,placeholder:"Search...",class:"w-full"},null,i,n)),s(`<ul${n}>\x3c!--[--\x3e`),a(t.unref(_),e=>{s(`<li class="mt-2"${n}>`),s(c(p,{variant:"ghost",class:"w-full",to:e.id},{default:t.withCtx((s,i,n,o)=>{if(!i)return[t.createVNode("div",{class:"flex flex-col"},[t.createVNode("span",{class:"text-black dark:text-white font-semibold"},t.toDisplayString(e.title),1),t.createVNode("span",{class:"text-gray-500 text-xs truncate"},t.toDisplayString(e.content?.slice(0,100))+"... ",1)])];i(`<div class="flex flex-col"${o}><span class="text-black dark:text-white font-semibold"${o}>${u(e.title)}</span><span class="text-gray-500 text-xs truncate"${o}>${u(e.content?.slice(0,100))}... </span></div>`)}),_:2},i,n)),s("</li>")}),s("\x3c!--]--\x3e</ul>")}),_:1},i,n))}),_:1},l))}}}),k=z.setup;z.setup=(e,s)=>{const i=t.useSSRContext();return(i.modules||(i.modules=new Set)).add("components/example/ExampleFulltextMiniSearch.vue"),k?k(e,s):void 0};const I=Object.assign(z,{__name:"ExampleFulltextMiniSearch"});export{I as default};
//# sourceMappingURL=ExampleFulltextMiniSearch-CEUkzOrR.mjs.map
