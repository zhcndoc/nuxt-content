import{A as e,e as r,r as s,y as t,z as a,B as n}from"../../../../nitro/nitro.mjs";import{r as i}from"../../../../_/auth.mjs";import"node:buffer";import"node:events";import"node:process";import"node:timers";import"node:async_hooks";import"cloudflare:workers";import"node:path";var c=1e3,o=60*c,u=60*o,m=24*u,l=7*m,d=365.25*m;function plural(e,r,s,t){var a=r>=1.5*s;return Math.round(e/s)+" "+t+(a?"s":"")}const h=e(function(e,r){r=r||{};var s=typeof e;if("string"===s&&e.length>0)return function(e){if((e=String(e)).length>100)return;var r=/^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(e);if(!r)return;var s=parseFloat(r[1]);switch((r[2]||"ms").toLowerCase()){case"years":case"year":case"yrs":case"yr":case"y":return s*d;case"weeks":case"week":case"w":return s*l;case"days":case"day":case"d":return s*m;case"hours":case"hour":case"hrs":case"hr":case"h":return s*u;case"minutes":case"minute":case"mins":case"min":case"m":return s*o;case"seconds":case"second":case"secs":case"sec":case"s":return s*c;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return s;default:return}}(e);if("number"===s&&isFinite(e))return r.long?function(e){var r=Math.abs(e);if(r>=m)return plural(e,r,m,"day");if(r>=u)return plural(e,r,u,"hour");if(r>=o)return plural(e,r,o,"minute");if(r>=c)return plural(e,r,c,"second");return e+" ms"}(e):function(e){var r=Math.abs(e);if(r>=m)return Math.round(e/m)+"d";if(r>=u)return Math.round(e/u)+"h";if(r>=o)return Math.round(e/o)+"m";if(r>=c)return Math.round(e/c)+"s";return e+"ms"}(e);throw new Error("val is not a non-empty string or a valid number. val="+JSON.stringify(e))}),p=r(async e=>{await i(e),s("cache");const r=(t(e,"key")||"").replace(/\//g,":");if(/\.[a-z0-9]{2,5}$/i.test(r)){const e=await a("cache").getItem(r);if(e)return e}const c=`${r}:`,o=n(),u=[];let m;do{const e=await o.list({prefix:c,cursor:m});u.push(...e.keys),m=e.list_complete?void 0:e.cursor}while(m);const l={groups:{},cache:[]};return await Promise.all(u.map(async({name:e,metadata:r})=>{const s=e.slice(c.length);if(s.includes(":")){const e=s.split(":")[0];return void(l.groups[e]=(l.groups[e]||0)+1)}if(!r){const s=await a("cache").getItem(e);if(!s)return;r={size:JSON.stringify(s).length,mtime:s.mtime,expires:s.expires}}!r.expires&&r.ttl&&(r.expires=r.mtime+1e3*r.ttl);const t={key:s,...r};try{t.duration=h(r.expires-r.mtime,{long:!0})}catch(e){t.duration="never"}l.cache.push(t)})),l});export{p as default};
//# sourceMappingURL=_...key_.get.mjs.map
